/* @sabre/spark - v3.9.7 - 2023-4-18 DO NOT MODIFY THIS FILE DIRECTLY OR YOU WILL NOT BE ABLE TO UPDATE YOUR VERSION OF SPARK. */
import {createjQueryPlugin} from "./spark.jquery.js";

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Spark = f()}})(function(){var define,module,exports;return (function(){function r(e, n, t){function o(i, f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0; i<t.length; i++)o(t[i]);return o}return r})()({1:[function(require, module, exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));
var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/includes"));
var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));
var _from = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/from"));
var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));
var _base = _interopRequireDefault(require("./base"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _getParent = _interopRequireDefault(require("../helpers/traversal/get-parent"));
var _matches = _interopRequireDefault(require("../helpers/traversal/matches"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Accordion
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Spark.Accordion(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/accordion.js
                                                                                                                                                                                                                                                                                                                                              * @since 2.13.0
                                                                                                                                                                                                                                                                                                                                              */
var onOpenEvent = document.createEvent('Event');
var onCloseEvent = document.createEvent('Event');
onOpenEvent.initEvent('open', true, true);
onCloseEvent.initEvent('close', true, true);

/**
 * Private Helper Method to Expand an Accordion Drawer
 * @param {String} drawer
 * @return {Promise}
 * @private
 */
var expand = function expand(drawer) {
  var _this = this;
  var self = this;
  return new _promise.default(function (resolve) {
    var control = _this.el.querySelector('.spark-accordion__header[aria-controls="' + drawer + '"]');
    var content = _this.el.querySelector('#' + drawer);
    var height = Math.round(content.scrollHeight);
    control.setAttribute('aria-expanded', true);
    content.style.visibility = 'visible';
    content.style.height = height + 'px';
    content.addEventListener('transitionend', function onExpand() {
      var _context;
      content.removeEventListener('transitionend', onExpand);
      content.style.height = (0, _includes.default)(_context = self.expanded).call(_context, drawer) ? 'auto' : 0 + 'px';
      onOpenEvent.drawer = drawer;
      self.el.dispatchEvent(onOpenEvent);
      resolve();
    });
  });
};

/**
 * Private Helper Method to Collapse an Accordion Drawer
 * @param {String} drawer
 * @return {Promise}
 * @private
 */
var collapse = function collapse(drawer) {
  var _this2 = this;
  var self = this;
  return new _promise.default(function (resolve) {
    var control = _this2.el.querySelector('.spark-accordion__header[aria-controls="' + drawer + '"]');
    var content = _this2.el.querySelector('#' + drawer);
    var height = content.scrollHeight;
    var transition = content.style.transition;
    content.style.visibility = 'visible';
    content.style.transition = '';
    content.addEventListener('transitionend', function onCollapse() {
      content.removeEventListener('transitionend', onCollapse);
      control.setAttribute('aria-expanded', false);
      content.style.visibility = 'hidden';
    });
    requestAnimationFrame(function () {
      // Define height explicitly, because transitions on "auto" won't visually animate
      content.style.height = height + 'px';

      // trigger another transition
      content.style.transition = transition;
      requestAnimationFrame(function () {
        // set height to 0, so that the transition may animate from the fixed height to 0
        content.style.height = 0 + 'px';
      });
      control.setAttribute('aria-expanded', false);
      onCloseEvent.drawer = drawer;
      self.el.dispatchEvent(onCloseEvent);
      resolve();
    });
  });
};

/**
 * Accordion
 * @class creates an Accordion
 * @extends {BaseComponent}
 */
var Accordion = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(Accordion, _BaseComponent);
  var _super = _createSuper(Accordion);
  /**
   * Accordion constructor.
   * @param {Element} el
   * @param {Object} params
   * @constructor
   */
  function Accordion(el) {
    var _this3;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Accordion);
    _this3 = _super.call(this, el, params);
    _this3._bindEventListenerCallbacks();
    _this3._addEventListeners();
    if (_this3.radio) {
      _this3.multiExpand = false;
      _this3.collapsible = false;
      if (!(0, _hasClass.default)(_this3.el, 'spark-accordion--radio')) {
        (0, _addClass.default)(_this3.el, 'spark-accordion--radio');
      }
    }
    return _this3;
  }

  /**
   * Sets up references
   * @param  {Element} el base DOM element
   * @private
   */
  (0, _createClass2.default)(Accordion, [{
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      if ((0, _hasClass.default)(this.el, 'spark-accordion--radio')) {
        this.radio = true;
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     * @private
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onClickBound = this._onClick.bind(this);
      this._onKeyDownBound = this._onKeyDown.bind(this);
      this._onChangeBound = this._onChange.bind(this);
      this._onOpenBound = this._onOpen.bind(this);
      this._onCloseBound = this._onClose.bind(this);
      this._onFocusBound = this._onFocus.bind(this);
      this._onBlurBound = this._onBlur.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     * @private
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      if (this.el) {
        this.el.addEventListener('click', this._onClickBound, true);
        this.el.addEventListener('keydown', this._onKeyDownBound, true);
        this.el.addEventListener('change', this._onChangeBound, true);
        this.el.addEventListener('open', this._onOpenBound, true);
        this.el.addEventListener('close', this._onCloseBound, true);

        // Added as MS Hack, for enabling the addition and removal of a `focus` class,
        // to circumvent a lack of support in Internet Explorer & Edge for :focus-within
        // TODO: Remove focus/blur based event code & associated .focus CSS styles,
        // upon Edge browser support for :focus-within, and dropping of Internet Explorer
        this.el.addEventListener('focus', this._onFocusBound, true);
        this.el.addEventListener('blur', this._onBlurBound, true);
      }
    }

    /**
     * Remove event listeners for DOM events..
     * @private
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      if (this.el) {
        this.el.removeEventListener('click', this._onClickBound, true);
        this.el.removeEventListener('keydown', this._onKeyDownBound, true);
        this.el.removeEventListener('change', this._onChangeBound, true);
        this.el.removeEventListener('open', this._onOpenBound, true);
        this.el.removeEventListener('close', this._onCloseBound, true);
        this.el.removeEventListener('focus', this._onFocusBound, true);
        this.el.removeEventListener('blur', this._onBlurBound, true);
      }
    }

    /**
     * On Key Down (ENTER or ARROW UP/DOWN keys), trigger accordion controls
     * @param {Event} e
     * @private
     */
  }, {
    key: "_onKeyDown",
    value: function _onKeyDown(e) {
      var _context2, _context3;
      var ENTER_KEY_CODE = 13;
      var SPACE_KEY_CODE = 32;
      var ARROW_UP_KEY_CODE = 38;
      var ARROW_DOWN_KEY_CODE = 40;
      if (this.radio && e.keyCode !== ENTER_KEY_CODE) return;
      var control = (0, _hasClass.default)(e.target, 'spark-accordion__header') ? e.target : (0, _getParent.default)(e.target, '.spark-accordion__header', this.el);
      var drawer = control && this._isActionable(control.getAttribute('aria-controls')) ? control.getAttribute('aria-controls') : undefined;
      if (drawer) {
        switch (e.keyCode) {
          case ENTER_KEY_CODE:
          case SPACE_KEY_CODE:
            if (this.radio) {
              this.select(drawer);
            } else {
              this.toggle(drawer);
            }
            break;
          case ARROW_DOWN_KEY_CODE:
            if ((0, _includes.default)(_context2 = this.collapsed).call(_context2, drawer)) {
              this.open(drawer);
            } else {
              e.preventDefault();
            }
            break;
          case ARROW_UP_KEY_CODE:
            if ((0, _includes.default)(_context3 = this.expanded).call(_context3, drawer)) {
              this.close(drawer);
            } else {
              e.preventDefault();
            }
            break;
        }
      }
    }

    /**
     * On Click, if target is a radio control, emulate `ENTER` key for Windows Browsers
     * @params {Object} e
     * @private
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      var headerClick = (0, _hasClass.default)(e.target, 'spark-accordion__header');
      var header = headerClick ? e.target : (0, _getParent.default)(e.target, '.spark-accordion__header', this.el);
      if (header) {
        var drawer = header.getAttribute('aria-controls');
        var isActionable = this._isActionable(drawer);
        if (isActionable && this.radio) {
          this.select(drawer);
        } else if (isActionable) {
          this.toggle(drawer);
        }
      }
    }

    /**
     * On Focus, add a class for Internet Explorer styles
     * @param {Object} e
     * @private
     */
  }, {
    key: "_onFocus",
    value: function _onFocus(e) {
      if ((0, _matches.default)(e.target, 'header')) {
        (0, _addClass.default)(e.target, 'focus');
      } else if ((0, _matches.default)(e.target, '.spark-radio__input')) {
        var header = (0, _getParent.default)(e.target, '.spark-accordion__header', this.el);
        (0, _addClass.default)(header, 'focus');
      }
    }

    /**
     * On Blur, remove class added for Internet Explorer styles
     * @param {Object} e
     * @private
     */
  }, {
    key: "_onBlur",
    value: function _onBlur(e) {
      if ((0, _matches.default)(e.target, 'header')) {
        (0, _removeClass.default)(e.target, 'focus');
      } else if ((0, _matches.default)(e.target, '.spark-radio__input')) {
        var header = (0, _getParent.default)(e.target, '.spark-accordion__header', this.el);
        (0, _removeClass.default)(header, 'focus');
      }
    }

    /**
     * On Radio change, make sure drawers match selection
     * @param {Event} e
     * @private
     */
  }, {
    key: "_onChange",
    value: function _onChange(e) {
      if ((0, _matches.default)(e.target, '.spark-accordion__header > .spark-radio > .spark-radio__input')) {
        var _context4;
        var header = (0, _getParent.default)(e.target, '.spark-accordion__header', this.el);
        var drawer = header && (0, _includes.default)(_context4 = this.drawers).call(_context4, header.getAttribute('aria-controls')) ? header.getAttribute('aria-controls') : undefined;
        if (drawer) this.select(drawer);
      }
    }

    /**
     * Fire `onOpen` callback
     * @param {Event} e
     * @private
     */
  }, {
    key: "_onOpen",
    value: function _onOpen(e) {
      this.onOpen.call(this, e);
    }

    /**
     * Fire `onClose` callback
     * @param {Event} e
     * @private
     */
  }, {
    key: "_onClose",
    value: function _onClose(e) {
      this.onClose.call(this, e);
    }

    /**
     * Returns whether or not a drawer exists, and it’s current expanded/collapsed state can be changed
     * @param {String} drawer
     * @return {Boolean}
     * @private
     */
  }, {
    key: "_isActionable",
    value: function _isActionable(drawer) {
      var _context5, _context6, _context7;
      var isExpanded = (0, _includes.default)(_context5 = this.expanded).call(_context5, drawer);
      var isCollapsed = (0, _includes.default)(_context6 = this.collapsed).call(_context6, drawer);
      if (!(0, _includes.default)(_context7 = this.drawers).call(_context7, drawer)) {
        return false;
      } else if (this.radio) {
        var radio = this.el.querySelector('.spark-accordion__header[aria-controls="' + drawer + '"] .spark-radio .spark-radio__input');
        return radio && !radio.checked && !radio.hasAttribute('disabled') ? true : false;
      } else if (!this.collapsible) {
        if (isExpanded && this.expanded.length === 1) {
          return false;
        } else if (isExpanded && this.expanded.length > 1) {
          return true;
        } else if (isCollapsed) {
          return true;
        }
      } else if (!this.multiExpand) {
        if (isExpanded && this.collapsible) {
          return true;
        } else if (!this.collapsible && isExpanded) {
          return false;
        } else if (isCollapsed) {
          return true;
        }
      } else {
        return true;
      }
    }

    /**
     * Return collection of all drawers
     * @return {Array}
     * @public
     */
  }, {
    key: "drawers",
    get: function get() {
      var _context8;
      var drawerControls = this.el.querySelectorAll('.spark-accordion__header');
      var drawerContents = this.el.querySelectorAll('.spark-accordion__content');
      var drawerNames = drawerControls.length ? (0, _map.default)(_context8 = (0, _from.default)(drawerControls)).call(_context8, function (control) {
        return control.getAttribute('aria-controls');
      }) : [];
      return (0, _filter.default)(drawerNames).call(drawerNames, function (drawer) {
        return (0, _from.default)(drawerContents).some(function (content) {
          return content.id === drawer;
        });
      });
    }

    /**
     * Return collection of currently expanded drawers
     * @return {Array}
     * @public
     */
  }, {
    key: "expanded",
    get: function get() {
      var _context9;
      var openDrawerControls = this.el.querySelectorAll('.spark-accordion__header[aria-expanded="true"]');
      return openDrawerControls.length ? (0, _map.default)(_context9 = (0, _from.default)(openDrawerControls)).call(_context9, function (control) {
        return control.getAttribute('aria-controls');
      }) : [];
    }

    /**
     * Explicitly set which drawers are currently expanded
     * @param {Array} drawers
     * @public
     */,
    set: function set(drawers) {
      var _this4 = this;
      if (!this.radio) {
        var _context10;
        var toClose = (0, _filter.default)(_context10 = this.expanded).call(_context10, function (expanded) {
          return !(0, _includes.default)(drawers).call(drawers, expanded);
        });
        toClose.forEach(function (drawer) {
          return _this4.close(drawer).catch(function () {});
        });
        drawers.forEach(function (drawer) {
          return _this4.open(drawer).catch(function () {});
        });
      } else if (drawers.length >= 1) {
        this.select(drawers.pop());
      }
    }

    /**
     * Return collection of currently collapsed drawers
     * @return {Array}
     * @public
     */
  }, {
    key: "collapsed",
    get: function get() {
      var _context11;
      var openDrawerControls = this.el.querySelectorAll('.spark-accordion__header[aria-expanded="false"]');
      return openDrawerControls.length ? (0, _map.default)(_context11 = (0, _from.default)(openDrawerControls)).call(_context11, function (control) {
        return control.getAttribute('aria-controls');
      }) : [];
    }

    /**
     * Explicitly set which drawers are currently expanded
     * @param {Array} drawers
     * @public
     */,
    set: function set(drawers) {
      var _this5 = this;
      if (!this.radio) {
        var _context12;
        var toOpen = (0, _filter.default)(_context12 = this.collapsed).call(_context12, function (collapsed) {
          return !(0, _includes.default)(drawers).call(drawers, collapsed);
        });
        toOpen.forEach(function (drawer) {
          return _this5.open(drawer).catch(function () {});
        });
        drawers.forEach(function (drawer) {
          return _this5.close(drawer).catch(function () {});
        });
      } else {
        throw new Error('Cannot be used to control radio accordions');
      }
    }

    /**
     * Returns the current radio value
     * @return {String}
     * @public
     */
  }, {
    key: "selected",
    get: function get() {
      if (!this.radio) {
        return undefined;
      } else {
        var checkedRadio = this.el.querySelector('.spark-accordion__header .spark-radio > .spark-radio__input:checked');
        return checkedRadio ? checkedRadio.value : undefined;
      }
    }

    /**
     * Activate an accordion drawer by radio value
     * @param {String} value
     * @public
     */,
    set: function set(value) {
      if (!this.radio) {
        return;
      } else if (!value) {
        this.clearValue();
      } else {
        var _context13;
        var radio = this.el.querySelector('.spark-accordion__header .spark-radio > .spark-radio__input[value="' + value + '"]');
        var drawer = (0, _getParent.default)(radio, '.spark-accordion__header', this.el).getAttribute('aria-controls');
        if ((0, _includes.default)(_context13 = this.drawers).call(_context13, drawer)) this.select(drawer);
      }
    }

    /**
     * Expand accordion drawer
     * @param {String} drawer
     * @return {Promise}
     * @public
     */
  }, {
    key: "open",
    value: function open(drawer) {
      var self = this;
      return new _promise.default(function (resolve, reject) {
        var drawers = self.drawers;
        var expanded = self.expanded;
        var collapsed = self.collapsed;
        var isActionable = self._isActionable(drawer);
        if (!(0, _includes.default)(drawers).call(drawers, drawer)) {
          reject(new Error('Drawer either does not exist, or configured incorrectly'));
        } else if ((0, _includes.default)(expanded).call(expanded, drawer)) {
          resolve();
        } else if ((0, _includes.default)(collapsed).call(collapsed, drawer) && !isActionable) {
          reject(new Error('Drawer could not be opened'));
        } else if ((0, _includes.default)(collapsed).call(collapsed, drawer) && isActionable && self.radio) {
          self.select(drawer).then(resolve);
        } else if ((0, _includes.default)(collapsed).call(collapsed, drawer) && isActionable && self.multiExpand) {
          expand.call(self, drawer).then(resolve);
        } else if ((0, _includes.default)(collapsed).call(collapsed, drawer) && isActionable && !self.multiExpand) {
          if (expanded.length > 0) {
            collapse.call(self, expanded[0]).then(function () {
              expand.call(self, drawer).then(resolve);
            });
          } else {
            expand.call(self, drawer).then(resolve);
          }
        } else {
          resolve();
        }
      });
    }

    /**
     * Collapse accordion drawer
     * @param {String} drawer
     * @return {Promise}
     * @public
     */
  }, {
    key: "close",
    value: function close(drawer) {
      var self = this;
      return new _promise.default(function (resolve, reject) {
        var drawers = self.drawers;
        var expanded = self.expanded;
        var collapsed = self.collapsed;
        var isActionable = self._isActionable(drawer);
        if (!(0, _includes.default)(drawers).call(drawers, drawer)) {
          reject(new Error('Drawer either does not exist, or configured incorrectly'));
        } else if ((0, _includes.default)(collapsed).call(collapsed, drawer)) {
          resolve();
        } else if ((0, _includes.default)(expanded).call(expanded, drawer) && !isActionable) {
          reject(new Error('Drawer could not be closed'));
        } else if (isActionable) {
          collapse.call(self, drawer).then(resolve);
        } else {
          resolve();
        }
      });
    }

    /**
     * Tell the accordion to toggle drawer if drawer is valid
     * @param {String} drawer
     * @public
     */
  }, {
    key: "toggle",
    value: function toggle(drawer) {
      var self = this;
      return new _promise.default(function (resolve, reject) {
        var _context14, _context15, _context16, _context17, _context18;
        var isActionable = self._isActionable(drawer);
        if (!(0, _includes.default)(_context14 = self.drawers).call(_context14, drawer)) {
          reject(new Error('Drawer either does not exist, or configured incorrectly'));
        } else if (self.radio && isActionable) {
          self.clearValue().then(function () {
            return self.select(drawer);
          }).then(resolve).catch(function () {
            reject(new Error('Radio Drawer could not be opened'));
          });
        } else if ((0, _includes.default)(_context15 = self.expanded).call(_context15, drawer) && isActionable) {
          self.close(drawer).then(resolve);
        } else if ((0, _includes.default)(_context16 = self.expanded).call(_context16, drawer) && !isActionable) {
          reject(new Error('Drawer could not be closed'));
        } else if ((0, _includes.default)(_context17 = self.collapsed).call(_context17, drawer) && isActionable) {
          if (self.multiExpand) {
            self.open(drawer).then(resolve);
          } else {
            self.hide().then(function () {
              self.open(drawer).then(resolve);
            });
          }
        } else if ((0, _includes.default)(_context18 = self.collapsed).call(_context18, drawer) && !isActionable) {
          reject(new Error('Drawer could not be opened'));
        }
      });
    }

    /**
     * Check radio
     * @param {String} drawer
     * @return {Promise}
     * @public
     */
  }, {
    key: "select",
    value: function select(drawer) {
      var self = this;
      return new _promise.default(function (resolve, reject) {
        var _context19;
        if (self.radio && drawer === self.expanded[0]) {
          resolve();
        } else if (self.radio && (0, _includes.default)(_context19 = self.drawers).call(_context19, drawer)) {
          var radio = self.el.querySelector('.spark-accordion__header[aria-controls="' + drawer + '"] .spark-radio__input:enabled');
          if (radio) {
            self.clearValue().then(function () {
              radio.checked = true;
              expand.call(self, drawer).then(resolve);
            });
          } else {
            reject(new Error('Cannot select radio button "' + drawer + '"'));
          }
        } else {
          reject(new Error('Not a radio accordion'));
        }
      });
    }

    /**
     * Uncheck all radios and collapse open drawers - only works for Radio Accordions
     * @return {Promise}
     * @public
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      var self = this;
      return new _promise.default(function (resolve) {
        if (self.radio && self.expanded.length) {
          var drawer = self.expanded[0];
          var radio = self.el.querySelector('.spark-accordion__header[aria-controls="' + drawer + '"] .spark-radio__input');
          radio.checked = false;
          collapse.call(self, drawer).then(resolve);
        } else if (!self.radio) {
          console.info('clearValue() only effects radio accordions, but was run anyway');
        } else {
          resolve();
        }
      });
    }

    /**
     * Expand all drawers (Chevron - `multiExpand`) or enable radio buttons (Radio)
     * @return {Promise}
     * @public
     */
  }, {
    key: "show",
    value: function show() {
      var self = this;
      return new _promise.default(function (resolve, reject) {
        if (self.radio) {
          var radioButtons = self.el.querySelectorAll('.spark-accordion__header .spark-radio__input');
          if (radioButtons.length >= 1) {
            radioButtons.forEach(function (radio) {
              return radio.removeAttribute('disabled');
            });
            resolve();
          } else {
            reject(new Error('Accordion is either misconfigured, or there are no drawers to enable'));
          }
        } else if (self.multiExpand) {
          var collapsed = self.collapsed;
          switch (collapsed.length) {
            case 0:
              resolve();
              break;
            case 1:
              expand.call(self, collapsed[0]).then(resolve);
              break;
            default:
              {
                var changes = [];
                do {
                  changes.push(expand.call(self, collapsed.shift()));
                } while (collapsed.length);
                _promise.default.all(changes).then(resolve).catch(reject);
                break;
              }
          }
        } else {
          var expanded = self.expanded;
          if (expanded.length && expanded[0] !== self.drawers[0]) {
            collapse.call(self, expanded[0]);
            expand.call(self, self.drawers[0]).then(resolve);
          } else if (expanded.length) {
            resolve();
          } else {
            reject(new Error('Accordion is either misconfigured, or there are no drawers to open'));
          }
        }
      });
    }

    /**
     * Collapse all drawers (Chevron) or disable radio buttons (radio)
     * @return {Promise}
     * @public
     */
  }, {
    key: "hide",
    value: function hide() {
      var self = this;
      return new _promise.default(function (resolve, reject) {
        if (self.radio) {
          var radioButtons = self.el.querySelectorAll('.spark-accordion__header .spark-radio__input');
          if (radioButtons.length >= 1) {
            radioButtons.forEach(function (button) {
              var disabled = document.createAttribute('disabled');
              button.attributes.setNamedItem(disabled);
            });
            resolve();
          } else {
            reject(new Error('Accordion is either misconfigured, or there are no drawers to disable'));
          }
        } else {
          var expanded = self.expanded;
          switch (expanded.length) {
            case 0:
              resolve();
              break;
            case 1:
              collapse.call(self, expanded[0]).then(resolve);
              break;
            default:
              {
                var changes = [];
                do {
                  changes.push(collapse.call(self, expanded.shift()));
                } while (expanded.length);
                _promise.default.all(changes).then(resolve).catch(reject);
                break;
              }
          }
        }
      });
    }

    /**
     * Remove component from DOM.
     * @param {Boolean} leaveElement
     * @public
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(Accordion.prototype), "remove", this).call(this, leaveElement);
    }

    /**
     * Update the element in use and the position.
     * @param {Element} el
     * @public
     */
  }, {
    key: "update",
    value: function update(el, params) {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(Accordion.prototype), "update", this).call(this, el, params);
    }
  }]);
  return Accordion;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
Accordion.prototype._whitelistedParams = ['radio', 'multiExpand', 'collapsible', 'onOpen', 'onClose'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
Accordion.prototype.defaults = {
  el: null,
  radio: false,
  multiExpand: true,
  collapsible: true,
  onOpen: function onOpen() {},
  onClose: function onClose() {}
};
var _default = Accordion;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/add-class":59,"../helpers/dom/has-class":61,"../helpers/dom/remove-class":67,"../helpers/traversal/get-parent":87,"../helpers/traversal/matches":92,"./base":3,"@babel/runtime-corejs3/core-js-stable/array/from":107,"@babel/runtime-corejs3/core-js-stable/instance/filter":110,"@babel/runtime-corejs3/core-js-stable/instance/includes":112,"@babel/runtime-corejs3/core-js-stable/instance/map":113,"@babel/runtime-corejs3/core-js-stable/promise":124,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],2:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _parseAttribute = require("../helpers/dom/parse-attribute");
var _debounce = _interopRequireDefault(require("../helpers/util/debounce"));
var _hasParent = _interopRequireDefault(require("../helpers/traversal/has-parent"));
var _getParent = _interopRequireDefault(require("../helpers/traversal/get-parent"));
var _messaging = _interopRequireDefault(require("../mixins/messaging"));
var _mixin = _interopRequireDefault(require("../helpers/util/mixin"));
var _makeElement = _interopRequireDefault(require("../helpers/dom/make-element"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * Auto Suggest
                                                                                                                                                                                                                                                                                                                                              * An auto suggest container.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new AutoSuggest(el, {
                                                                                                                                                                                                                                                                                                                                              *   // Optional. Callback for when the input value changes.
                                                                                                                                                                                                                                                                                                                                              *   onChange(value, inputInstance) {}
                                                                                                                                                                                                                                                                                                                                              * });
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/auto-suggest.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var AutoSuggest = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(AutoSuggest, _BaseComponent);
  var _super = _createSuper(AutoSuggest);
  /**
   * AutoSuggest constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function AutoSuggest(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, AutoSuggest);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    if (_this.inputEl.value) {
      _this.show();
      _this._onInput();
    }
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Cache elements.
   * @param {Element} el
   */
  (0, _createClass2.default)(AutoSuggest, [{
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.inputEl = this.el.querySelector('.spark-auto-suggest__field');
      this.labelEl = this.el.querySelector('.spark-label');
      this.listBoxEl = this.el.querySelector('.spark-auto-suggest__listbox');
      this.clearButtonEl = this.el.querySelector('.spark-auto-suggest__clear-btn');
      if (!this.inputEl) {
        throw new Error('No <input> element present in input container!', this.el);
      }
      this.messageEl = this.el.querySelector('.spark-input__message') || (0, _makeElement.default)('<span class="spark-input__message"></span>');
    }

    /**
     * Parse parameters from the elements.
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      this.clickedWithinAutoSuggest = false;
      this.isActive = this.inputEl.value ? true : false;
      this.autoSuggestTerms = this.autoSuggestTerms !== null && Array.isArray(this.autoSuggestTerms) ? this.autoSuggestTerms : null;
      this.minLength = this.minLength !== null ? this.minLength : (0, _parseAttribute.number)(this.el, 'data-min-length', 2);
      this.maxSuggestions = this.maxSuggestions !== null ? this.maxSuggestions : (0, _parseAttribute.number)(this.el, 'data-max-suggestions', 2);
      this.showAllTerms = this.showAllTerms !== null ? this.showAllTerms : (0, _parseAttribute.boolean)(this.el, 'data-show-all-terms', false);
      this.showNoResultsFound = this.showNoResultsFound !== null ? this.showNoResultsFound : (0, _parseAttribute.boolean)(this.el, 'data-show-no-results-found', false);
      this.noResultsFoundText = this.noResultsFoundText !== null ? this.noResultsFoundText : 'No results found';
      if (this.autoSuggestTerms) {
        this.termsObject = (0, _typeof2.default)(this.autoSuggestTerms[0]) === 'object' ? true : false;
      }
      if (this.autoSuggestTerms === null && this.customGetSuggestions === null) {
        throw new Error('No Auto Suggest terms or custom search function provided!', this.el);
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onFocusBound = this._onFocus.bind(this);
      this._onBlurBound = (0, _debounce.default)(this._onBlur.bind(this), 100);
      this._onInputBound = this._onInput.bind(this);
      this._onClearClickBound = this._onClearClick.bind(this);
      this._onWindowClickBound = this._onWindowClick.bind(this);
      this._onKeyupBound = this._onKeyup.bind(this);
      this._onKeydownBound = this._onKeydown.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.inputEl.addEventListener('focus', this._onFocusBound);
      this.inputEl.addEventListener('blur', this._onBlurBound);
      this.inputEl.addEventListener('input', this._onInputBound);
      if (this.clearButtonEl) {
        this.clearButtonEl.addEventListener('click', this._onClearClickBound);
      }
      this._addWindowEventListeners();
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.inputEl.removeEventListener('focus', this._onFocusBound);
      this.inputEl.removeEventListener('blur', this._onBlurBound);
      this.inputEl.removeEventListener('input', this._onInputBound);
      if (this.clearButtonEl) {
        this.clearButtonEl.removeEventListener('click', this._onClearClickBound);
      }
      this._removeWindowEventListeners();
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addWindowEventListeners",
    value: function _addWindowEventListeners() {
      this._removeWindowEventListeners();
      window.addEventListener('click', this._onWindowClickBound);
      window.addEventListener('keyup', this._onKeyupBound);
      window.addEventListener('keydown', this._onKeydownBound);
    }

    /**
     * Remove event listeners for DOM events.
     */
  }, {
    key: "_removeWindowEventListeners",
    value: function _removeWindowEventListeners() {
      window.removeEventListener('click', this._onWindowClickBound);
      window.removeEventListener('keyup', this._onKeyupBound);
      window.removeEventListener('keydown', this._onKeydownBound);
    }

    /**
     * When the input element gains focus.
     * @param {Object} e
     */
  }, {
    key: "_onFocus",
    value: function _onFocus() {
      this.show();
      (0, _toggleClass.default)(this.inputEl, 'focus', true);

      // Hide the Clear button if it is visible but there is no entry in the field
      // Also adjust padding on input depending on presence and visibility of the Clear Button
      if (this.clearButtonEl && this.inputEl.value === '') {
        (0, _toggleClass.default)(this.clearButtonEl, 'visible', false);
        (0, _toggleClass.default)(this.inputEl, 'clear-btn-visible', false);
      }

      // Show all terms on initial focus if configured and there isn't an initial entry
      if (this.showAllTerms && !this.listBoxElOpen && !this.inputEl.value && this.customGetSuggestions === null) {
        this._displayAllSuggestions();
        return;
      }

      // If input has a value, display the list if there are matches
      if (this.inputEl.value && !this.listBoxElOpen) {
        var inputString = this.inputEl.value;
        if (inputString.length > 0) {
          if (this.clearButtonEl) {
            (0, _toggleClass.default)(this.clearButtonEl, 'visible', true);
            (0, _toggleClass.default)(this.inputEl, 'clear-btn-visible', true);
          }
        }
        if (inputString.length >= this.minLength) {
          this._updateSuggestionsDisplay();
        }
      }
    }

    /**
     * When the input element loses focus.
     * @param {Object} e
     */
  }, {
    key: "_onBlur",
    value: function _onBlur() {
      if (this.clickedWithinAutoSuggest) {
        this.clickedWithinAutoSuggest = false;
        this.inputEl.focus();
        return;
      }
      var activeElement = document.activeElement;
      if (!(0, _hasParent.default)(activeElement, this.el)) {
        if (!this.inputEl.value) {
          this.hide();
        }
        this._closeListbox();
        (0, _toggleClass.default)(this.inputEl, 'focus', false);
      }
    }

    /**
     * When the input receives a value or the value is about to change, update the displayed suggestions
     * @param {Object} e
     */
  }, {
    key: "_onInput",
    value: function _onInput() {
      this.listBoxEl.innerHTML = '';
      (0, _toggleClass.default)(this.listBoxEl, 'visible', false);
      var inputString = this.inputEl.value;

      // If a value was set using value="" but focus is not on the input, do not show suggestions
      // However, show the Clear button since a value is indeed present
      if (document.activeElement !== this.inputEl && inputString.length > 0) {
        if (this.clearButtonEl) {
          (0, _toggleClass.default)(this.clearButtonEl, 'visible', true);
          (0, _toggleClass.default)(this.inputEl, 'clear-btn-visible', true);
        }
        return;
      }
      this.showingAllTerms = inputString.length === 0 && this.showAllTerms ? true : false;
      if (this.showingAllTerms) {
        this._displayAllSuggestions();
      }
      if (inputString.length > 0 && this.clearButtonEl) {
        (0, _toggleClass.default)(this.clearButtonEl, 'visible', true);
        (0, _toggleClass.default)(this.inputEl, 'clear-btn-visible', true);
      } else {
        (0, _toggleClass.default)(this.clearButtonEl, 'visible', false);
        (0, _toggleClass.default)(this.inputEl, 'clear-btn-visible', false);
      }
      if (inputString.length >= this.minLength) {
        this._updateSuggestionsDisplay();
      }
      (this.onChange || noop)(this.inputEl.value, this);
    }

    /**
     * Create the HTML markup of a suggestion term
     * @param {String} text The suggestion value in HTML format
     * @param {Number} index The index of the suggestion value
     */
  }, {
    key: "_createSuggestionMarkup",
    value: function _createSuggestionMarkup(term, index) {
      if (this.termsObject) {
        // Add icon if available
        if (this.autoSuggestTerms[index].icon && this.autoSuggestTerms[index].icon !== '') {
          term = this.autoSuggestTerms[index].icon + '<span class="spark-auto-suggest__list-item__value" data-term-index="' + index + '">' + term + '</span>';
        } else {
          term = '<span class="spark-auto-suggest__list-item__value" data-term-index="' + index + '">' + term + '</span>';
        }

        // Add description if available
        if (this.autoSuggestTerms[index].description && this.autoSuggestTerms[index].description !== '') {
          term += '<span class="spark-auto-suggest__list-item__description">' + this.autoSuggestTerms[index].description + '</span>';
        }
      }
      return term;
    }

    /**
     * Create the HTML markup of a list item
     * @param {String} text The suggestion string in HTML format, including icon and description markup if set
     * @param {Number} index The index of the list item
     */
  }, {
    key: "_createSuggestionsListItemMarkup",
    value: function _createSuggestionsListItemMarkup(htmlStr, index) {
      var item = document.createElement('li');
      item.setAttribute('role', 'option');
      item.setAttribute('id', 'spark-auto-suggest__list-item--' + index);
      item.setAttribute('class', 'spark-auto-suggest__list-item');
      item.setAttribute('tabindex', '-1');
      if (this.termsObject) {
        item.setAttribute('data-suggestion-object', true);
      }
      item.innerHTML = htmlStr;
      return item;
    }

    /**
     * Display all Auto Suggest terms. Should not be used in conjunction with showNoResultsFound
     */
  }, {
    key: "_displayAllSuggestions",
    value: function _displayAllSuggestions() {
      if (this.autoSuggestTerms.length < 1) {
        return;
      }
      this.showingAllTerms = true;
      var suggestionResults = [];
      for (var i = 0; i < this.autoSuggestTerms.length; i++) {
        var suggestion = this.termsObject ? this.autoSuggestTerms[i].value : this.autoSuggestTerms[i];
        suggestion = this._createSuggestionMarkup(suggestion, i);
        suggestionResults.push(suggestion);
      }
      if (suggestionResults.length) {
        for (var _i = 0; _i < suggestionResults.length; _i++) {
          var resultItem = this._createSuggestionsListItemMarkup(suggestionResults[_i], _i);
          this.listBoxEl.appendChild(resultItem);
        }
        this._openListbox();
        this.resultsCount = suggestionResults.length;
      }
    }

    /**
     * Get and display Auto Suggest terms based on user entry
     */
  }, {
    key: "_updateSuggestionsDisplay",
    value: function _updateSuggestionsDisplay() {
      var suggestionResults = [];

      // If custom filtering and display functionality is provided, call it and exit
      if (this.customGetSuggestions) {
        this.customGetSuggestions.bind(this)();
        return;
      }
      for (var i = 0; i < this.autoSuggestTerms.length; i++) {
        var term = this.termsObject ? this.autoSuggestTerms[i].value : this.autoSuggestTerms[i];
        if (term.toLowerCase().indexOf(this.inputEl.value.toLowerCase()) !== -1) {
          var regex = new RegExp(this.inputEl.value, 'gi');
          var suggestion = term.replace(regex, function (string) {
            return '<mark>' + string + '</mark>';
          });
          suggestion = this._createSuggestionMarkup(suggestion, i);
          suggestionResults.push(suggestion);
        }
        if (suggestionResults.length === this.maxSuggestions) {
          break;
        }
      }
      if (suggestionResults.length) {
        // Ensure that listbox is empty before appending content. IE adds "null" to empty <ul> elements
        this.listBoxEl.innerHTML = '';
        for (var _i2 = 0; _i2 < suggestionResults.length; _i2++) {
          var resultItem = this._createSuggestionsListItemMarkup(suggestionResults[_i2], _i2);
          this.listBoxEl.appendChild(resultItem);
        }
        this._openListbox();
        this.resultsCount = suggestionResults.length;
      } else {
        this.resultsCount = 0;
        if (this.showNoResultsFound) {
          var noResult = document.createElement('li');
          noResult.setAttribute('role', 'presentation');
          noResult.setAttribute('class', 'spark-auto-suggest__list-item spark-auto-suggest__list-item--no-results');
          noResult.innerHTML = this.noResultsFoundText;
          this.listBoxEl.appendChild(noResult);
          this._openListbox();
        }
      }
    }

    /**
     * When the Clear Button is clicked, clear the entered value and close the listbox if it is open
     * If showAllTerms is true, display all the terms once the field is clear
     * @param {Object} e
     */
  }, {
    key: "_onClearClick",
    value: function _onClearClick(e) {
      e.preventDefault();
      this.inputEl.value = '';
      this.oldVal = null;
      this.inputEl.focus();
      this._closeListbox();
      this.clickedWithinAutoSuggest = false;
      if (this.clearButtonEl) {
        (0, _toggleClass.default)(this.clearButtonEl, 'visible', false);
        (0, _toggleClass.default)(this.inputEl, 'clear-btn-visible', false);
      }

      // If showAllTerms is true we need to show the full list on click
      if (this.showAllTerms && !this.listBoxElOpen && !this.inputEl.value && this.customGetSuggestions === null) {
        this._displayAllSuggestions();
      }

      // Manually call onChange method with newly empty input
      (this.onChange || noop)(this.inputEl.value, this);
    }

    /**
     * Show the input by adding the active state
     */
  }, {
    key: "_updateClass",
    value: function _updateClass() {
      (0, _toggleClass.default)(this.el, 'active', this.isActive);
    }

    /**
     * When the window is clicked and the area clicked is not part of the Auto Suggest, close the suggestions list
     * If an item in the suggestions list is clicked, set it as the active/selected item
     * @param {Object} e
     */
  }, {
    key: "_onWindowClick",
    value: function _onWindowClick(e) {
      // Check if we have clicked outside of the Auto Suggest component and collapse the Suggestions list if so
      if (e.target !== this.el && !(0, _hasParent.default)(e.target, this.el) && e.target !== this.listBoxEl && !(0, _hasParent.default)(e.target, this.listBoxEl)) {
        this._closeListbox();
        (0, _toggleClass.default)(this.inputEl, 'focus', false);
        return;
      }

      // If we clicked the label, input field or clear button, exit
      if (e.target === this.inputEl || e.target === this.labelEl || e.target === this.clearButtonEl) {
        return;
      }

      // If a valid suggestion wasn't clicked, exit
      if (e.target.getAttribute('role') !== 'option' && !(0, _hasParent.default)(e.target, this.listBoxEl)) {
        this.clickedWithinAutoSuggest = true;
        return;
      }

      // Set the selected suggestion as the input's value
      var targetID;
      if (e.target.tagName !== 'li') {
        var li = (0, _getParent.default)(e.target, 'li', this.listBoxEl);
        targetID = li.getAttribute('id');
      } else {
        targetID = e.target.getAttribute('id');
      }
      this._setActiveSuggestion(targetID);

      // Set focus back to input but dismiss listbox
      this.inputEl.focus();

      // Ensure that _closeListbox is triggered after focus above in IE
      setTimeout(function () {
        this._closeListbox();
      }.bind(this), 0);

      // Allow additional behavior on mouse click of a suggestion
      (this.onSelection || noop)(this.inputEl.value, this);
    }

    /**
     * Set the selected item
     */
  }, {
    key: "_setActiveSuggestion",
    value: function _setActiveSuggestion(id) {
      var activeSuggestion = document.getElementById(id);
      if (activeSuggestion) {
        if (this.termsObject) {
          var valueEl = activeSuggestion.querySelector('.spark-auto-suggest__list-item__value');
          this.inputEl.value = valueEl.innerText;
          this.selectedTermsObjectIndex = valueEl.getAttribute('data-term-index');
        } else {
          this.inputEl.value = activeSuggestion.innerText;
          this.oldVal = this.inputEl.value;
        }

        // Show the Clear button if an entry has been selected via keyboard arrows or direct mouseclick
        if (this.clearButtonEl && this.inputEl.value !== '') {
          (0, _toggleClass.default)(this.clearButtonEl, 'visible', true);
          (0, _toggleClass.default)(this.inputEl, 'clear-btn-visible', true);
        }
      }
    }

    /**
     * When a key is pressed on the window and it's an ESC, close the suggestions list
     * @param {Object} e
     */
  }, {
    key: "_onKeyup",
    value: function _onKeyup(e) {
      if (e.keyCode === 27 && document.activeElement === this.inputEl) {
        this._closeListbox();
        this.inputEl.value = '';
        if (this.oldVal !== this.inputEl.value) (this.onChange || noop)(this.inputEl.value, this);
      }
      if (e.keyCode !== 38 && e.keyCode !== 40) {
        this.oldVal = this.inputEl.value;
      }
    }

    /**
     * When a key is pressed and it is the Enter key, set the current suggestion as the selected one.
     * If it is the tab key, determine where to shift focus and whether to manage the component's display classes
     * If it is the arrow keys, navigate the suggestions list
     * @param {Object} e
     */
  }, {
    key: "_onKeydown",
    value: function _onKeydown(e) {
      // Remove focus from component if navigating away from it via Tab key
      if (e.keyCode === 9 && document.activeElement === this.clearButtonEl) {
        this._closeListbox();
        (0, _toggleClass.default)(this.inputEl, 'focus', false);
      }
      if (this.resultsCount < 1) {
        return;
      }

      // Set focus back to input if printable keys are pressed
      if (e.keyCode !== 13 && e.keyCode !== 38 && e.keyCode !== 40 && document.activeElement !== this.inputEl) {
        this.inputEl.focus();
        return;
      }

      // Enter key
      if (e.keyCode === 13) {
        e.preventDefault();
        if (document.activeElement !== this.inputEl) {
          this.inputEl.focus();

          // Ensure that _closeListbox is triggered after focus above in IE
          setTimeout(function () {
            this._closeListbox();
          }.bind(this), 0);

          // Allow form submission or other behavior on Enter
          // @deprecated Remove onEnterKey in v4.0.0
          (this.onSelection || this.onEnterKey || noop)(this.inputEl.value, this);
        }
        return;
      }

      // Get the current suggestion which will become "previous" suggestion
      var currentSuggestion = this.getAutoSuggestItem(this.activeSuggestionIndex);

      // Up arrow
      if (e.keyCode === 38) {
        e.preventDefault();
        if (document.activeElement === this.inputEl) {
          this.activeSuggestionIndex = this.resultsCount - 1;
        } else if (this.activeSuggestionIndex <= 0) {
          this.activeSuggestionIndex = -1;

          // Reset value back to what was initially typed
          this.inputEl.value = this.oldVal;
          this.inputEl.setAttribute('aria-activedescendant', '');
          this.inputEl.focus();
        } else {
          this.activeSuggestionIndex--;
        }

        // Down arrow
      } else if (e.keyCode === 40) {
        e.preventDefault();
        if (document.activeElement === this.inputEl) {
          this.activeSuggestionIndex = 0;
        } else if (this.activeSuggestionIndex >= this.resultsCount - 1) {
          this.activeSuggestionIndex = -1;

          // Reset value back to what was initially typed
          this.inputEl.value = this.oldVal;
          this.inputEl.setAttribute('aria-activedescendant', '');
          this.inputEl.focus();
        } else {
          this.activeSuggestionIndex++;
        }
      }

      // Exit at this point if not Up/Down arrow keys
      if (e.keyCode !== 38 && e.keyCode !== 40) {
        return;
      }

      // Find the item at the activeSuggestionIndex
      var newSuggestion;
      if (this.activeSuggestionIndex >= 0) {
        newSuggestion = this.getAutoSuggestItem(this.activeSuggestionIndex);
      }
      if (currentSuggestion) {
        // Remove focus from single action variation if it exists
        var link = currentSuggestion.querySelector('.spark-link');
        if (link) link.blur();
        currentSuggestion.setAttribute('aria-selected', 'false');
        (0, _toggleClass.default)(currentSuggestion, 'focus', false);
      }
      if (newSuggestion) {
        // If this is the single action variation, we need to ignore it
        if ((0, _hasClass.default)(newSuggestion, 'spark-auto-suggest__list-item--action')) {
          var _link = newSuggestion.querySelector('.spark-link');
          if (_link) _link.focus();

          // Reset value of input to initially typed item
          this.inputEl.value = this.oldVal;
          this.inputEl.setAttribute('aria-activedescendant', '');
          return;
        }
        this.inputEl.setAttribute('aria-activedescendant', 'spark-auto-suggest__list-item--' + this.activeSuggestionIndex);
        (0, _toggleClass.default)(newSuggestion, 'focus', true);
        newSuggestion.setAttribute('aria-selected', 'true');
        newSuggestion.focus();

        // Make this new selection the value of the text input but store old value for cycling purposes
        var targetID = 'spark-auto-suggest__list-item--' + this.activeSuggestionIndex;
        this._setActiveSuggestion(targetID);
      }
    }

    /**
     * Display the suggestions list
     */
  }, {
    key: "_openListbox",
    value: function _openListbox() {
      (0, _toggleClass.default)(this.listBoxEl, 'visible', true);
      this.showingAllTerms === true ? (0, _toggleClass.default)(this.listBoxEl, 'show-all-terms', true) : (0, _toggleClass.default)(this.listBoxEl, 'show-all-terms', false);
      this.listBoxElOpen = true;
      this.el.setAttribute('aria-expanded', 'true');
    }

    /**
     * Hide the suggestions list
     */
  }, {
    key: "_closeListbox",
    value: function _closeListbox() {
      if (!this.listBoxElOpen) {
        return;
      }

      // Manage visibility of suggestions list, and associated ARIA attributes
      (0, _toggleClass.default)(this.listBoxEl, 'visible', false);
      (0, _toggleClass.default)(this.listBoxEl, 'show-all-terms', false);
      this.listBoxElOpen = false;
      this.listBoxEl.innerHTML = '';
      this.el.setAttribute('aria-expanded', 'false');
      this.inputEl.setAttribute('aria-activedescendant', '');

      // Reset whether we are showing all terms
      this.showingAllTerms = false;

      // Reset index and results counter
      this.activeSuggestionIndex = -1;
      this.resultsCount = 0;
    }

    /**
    * Get a listbox element
    * @param {Number} index The index of the element to retrieve
    */
  }, {
    key: "getAutoSuggestItem",
    value: function getAutoSuggestItem(index) {
      return document.getElementById('spark-auto-suggest__list-item--' + index);
    }

    /**
     * Show the input by adding the active state
     */
  }, {
    key: "show",
    value: function show() {
      this.isActive = true;
      this._updateClass();
      return this;
    }

    /**
     * Hide the input by removing the active state.
     */
  }, {
    key: "hide",
    value: function hide() {
      this.isActive = false;
      this._updateClass();
      return this;
    }

    /**
     * Set the value of the input
     * @param {Mixed} value
     */
  }, {
    key: "setValue",
    value: function setValue(value) {
      this.inputEl.value = value;
      if (value) {
        this.show();
        (0, _toggleClass.default)(this.clearButtonEl, 'visible', true);
        (0, _toggleClass.default)(this.inputEl, 'clear-btn-visible', true);
      } else {
        this.hide();
      }
      return this;
    }

    /**
     * Get the value of the input.
     * @return {String}
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return this.inputEl.value;
    }

    /**
     * Clear the value of the input.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      this.inputEl.value = '';
      return this;
    }

    /**
     * Disable the Auto Suggest.
     */
  }, {
    key: "disable",
    value: function disable() {
      this._closeListbox();
      this.inputEl.blur();
      this.inputEl.setAttribute('disabled', true);
      if (this.clearButtonEl) {
        this.clearButtonEl.setAttribute('disabled', true);
      }
      return this;
    }

    /**
     * Enable the Auto Suggest.
     */
  }, {
    key: "enable",
    value: function enable() {
      this.inputEl.removeAttribute('disabled');
      if (this.clearButtonEl) {
        this.clearButtonEl.removeAttribute('disabled');
      }
      return this;
    }

    /**
     * Remove component from DOM.
     * @param {Boolean} leaveElement
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(AutoSuggest.prototype), "remove", this).call(this, leaveElement);
    }

    /**
     * Update the element in use and the position.
     * @param {Element} el
     */
  }, {
    key: "update",
    value: function update(el) {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(AutoSuggest.prototype), "update", this).call(this, el);
    }
  }]);
  return AutoSuggest;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
AutoSuggest.prototype._whitelistedParams = ['onChange', 'onEnterKey', 'onSelection', 'autoSuggestTerms', 'showAllTerms', 'showNoResultsFound', 'minLength', 'maxSuggestions', 'noResultsFoundText', 'customGetSuggestions'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
AutoSuggest.prototype.defaults = {
  el: null,
  inputEl: null,
  labelEl: null,
  clearButtonEl: null,
  listBoxEl: null,
  isActive: false,
  clickedWithinAutoSuggest: false,
  oldVal: null,
  showingAllTerms: false,
  resultsCount: 0,
  activeSuggestionIndex: -1,
  termsObject: null,
  selectedTermsObjectIndex: null,
  listBoxElOpen: false,
  minLength: null,
  maxSuggestions: 7,
  autoSuggestTerms: null,
  showNoResultsFound: null,
  showAllTerms: null,
  noResultsFoundText: null,
  customGetSuggestions: null,
  onChange: null,
  onEnterKey: null,
  onSelection: null,
  _onFocusBound: null,
  _onBlurBound: null,
  _onInputBound: null,
  _onClearClickBound: null,
  _onKeyupBound: null,
  _onKeydownBound: null,
  _onWindowClickBound: null
};
(0, _mixin.default)(AutoSuggest.prototype, _messaging.default);
var _default = AutoSuggest;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/has-class":61,"../helpers/dom/make-element":62,"../helpers/dom/parse-attribute":66,"../helpers/dom/toggle-class":68,"../helpers/traversal/get-parent":87,"../helpers/traversal/has-parent":91,"../helpers/util/debounce":93,"../helpers/util/mixin":96,"../mixins/messaging":104,"./base":3,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155,"@babel/runtime-corejs3/helpers/typeof":162}],3:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _each = _interopRequireDefault(require("../helpers/util/each"));
/**
 * # Base Component
 * The base class for Spark JS components. This class should never be
 * instantiated directly.
 *
 * @param {Element} el
 * @param {Object} params
 *
 * @module components/base.js
 */

var noop = function noop() {};
var Base = /*#__PURE__*/function () {
  /**
   * Set parameters and cache elements.
   */
  function Base(el) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Base);
    if (params.elRequired && !el) {
      return;
    }
    this.setParams(this.defaults || {}, true);
    this.setParams(params);
    (this._cacheElements || noop).call(this, el, params);
    (this._parseParams || noop).call(this);
  }

  /**
   * Remove the component from the DOM and prepare for garbage collection by dereferencing values.
   * @param {Boolean} leaveElement Leave the element intact.
   */
  (0, _createClass2.default)(Base, [{
    key: "remove",
    value: function remove(leaveElement) {
      if (this._removeEventListeners) {
        this._removeEventListeners();
      }
      if (!leaveElement && this.el && this.el.parentNode) {
        this.el.parentNode.removeChild(this.el);
      }
      this.unsetParams(this.defaults);
      return this;
    }

    /**
     * Update the component to use a new element or reparse from
     * the existing element.
     * @param {Element} el Optional
     * @param {Object} params Optional
     */
  }, {
    key: "update",
    value: function update(el) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (this._removeEventListeners) {
        this._removeEventListeners();
      }
      (this._cacheElements || noop).call(this, el || this.el, params);
      (this._parseParams || noop).call(this);
      if (this._addEventListeners) {
        this._addEventListeners();
      }
      return this;
    }

    /**
     * Set a hash of parameters if they're whitelisted or we're told to force the set.
     * This is used to set initial values as well as set passed parameters.
     * @param {Object} params
     * @param {Boolean} force Force setting even if the param is not whitelisted.
     */
  }, {
    key: "setParams",
    value: function setParams(params, force) {
      var _this = this;
      (0, _each.default)(params, function (k, v) {
        if (_this._whitelistedParams.indexOf(k) !== -1 || force) {
          _this[k] = v;
        }
      });
      return this;
    }

    /**
     * Unset all parameters.
     * @param {Array|Object} keys
     * @param {Object} scope The object to unset the params from. Defaults to `this`.
     */
  }, {
    key: "unsetParams",
    value: function unsetParams(keys, scope) {
      keys = keys instanceof Array ? keys : (0, _keys.default)(keys);
      scope = scope || this;
      (0, _each.default)(keys, function (k) {
        delete scope[k];
      });
      return this;
    }
  }]);
  return Base;
}();
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
Base.prototype._whitelistedParams = [];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
Base.prototype.defaults = {};
var _default = Base;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/util/each":94,"@babel/runtime-corejs3/core-js-stable/object/keys":123,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],4:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Button
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * new Button(el, { });
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/button.js
                                                                                                                                                                                                                                                                                                                                              */
var Button = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(Button, _BaseComponent);
  var _super = _createSuper(Button);
  /**
   * Button Constructor
   * @param {Element} el          root element to attach the button
   * @param {Object} [params={}]  button parameters see defaults
   */
  function Button(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Button);
    _this = _super.call(this, el, params);
    _this._bindEventListenerCallbacks();
    return _this;
  }

  /**
   * Bind listener call backs.
   */
  (0, _createClass2.default)(Button, [{
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onAnimationCompleteBound = this._onAnimationComplete.bind(this);
      this._resetBound = this._reset.bind(this);
    }

    /**
     * Set up references.
     * @param {Element} el base DOM element
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
    }

    /**
     * Return active state.
     * @return {Boolean}
     */
  }, {
    key: "getActive",
    value: function getActive() {
      return this._active;
    }

    /**
     *  Set the active state of the Button.
     *  @param {Boolean} activeState
     */
  }, {
    key: "setActive",
    value: function setActive(activeState) {
      this._resetBound();
      this._active = activeState;
      if (this._active === true) {
        (0, _addClass.default)(this.el, 'spark-btn--active');
      }
    }

    /**
     * When animation finishes clean up and call onComplete.
     * @param {TransitionEvent} _evt
     */
  }, {
    key: "_onAnimationComplete",
    value: function _onAnimationComplete(_evt) {
      this._resetBound();
      this.onComplete(_evt);
    }

    /**
     * Reset animation classes and remove animation listener.
     */
  }, {
    key: "_reset",
    value: function _reset() {
      this.el.querySelector('.spark-btn__label').removeEventListener('transitionend', this._onAnimationCompleteBound);
      (0, _removeClass.default)(this.el, 'spark-btn--active', 'spark-btn--complete');
    }

    /**
     * Action was successful, complete animation cycle
     */
  }, {
    key: "success",
    value: function success() {
      if (this._active === true) {
        this._active = false;
        (0, _addClass.default)(this.el, 'spark-btn--complete');
        this.el.querySelector('.spark-btn__label').addEventListener('transitionend', this._onAnimationCompleteBound);
      }
    }

    /**
     * Action failed reset the button
     */
  }, {
    key: "fail",
    value: function fail() {
      if (this._active === true) {
        this._active = false;
        this._onAnimationCompleteBound();
      }
    }
  }]);
  return Button;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
Button.prototype._whitelistedParams = ['onComplete'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
Button.prototype.defaults = {
  el: null,
  _active: false,
  onComplete: function onComplete() {}
};
var _default = Button;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/add-class":59,"../helpers/dom/remove-class":67,"./base":3,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],5:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/assertThisInitialized"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/values"));
var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));
var _splice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/splice"));
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));
var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));
var _base = _interopRequireDefault(require("./base"));
var _parseFormat = _interopRequireDefault(require("../helpers/date/parse-format"));
var _date = _interopRequireDefault(require("../helpers/date/date"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _appendChildren = _interopRequireDefault(require("../helpers/manipulation/append-children"));
var _getParent = _interopRequireDefault(require("../helpers/traversal/get-parent"));
var _triggerEvent = _interopRequireDefault(require("../helpers/dom/trigger-event"));
var _breakpoint = require("../helpers/dom/breakpoint");
var _scrollTo = _interopRequireDefault(require("../helpers/animation/scroll-to"));
var _getSiblingBefore = _interopRequireDefault(require("../helpers/traversal/get-sibling-before"));
var _getSiblingAfter = _interopRequireDefault(require("../helpers/traversal/get-sibling-after"));
var _getChildren = _interopRequireDefault(require("../helpers/traversal/get-children"));
var _getIndex = _interopRequireDefault(require("../helpers/traversal/get-index"));
var _debounce = _interopRequireDefault(require("../helpers/util/debounce"));
var _outerWidth = _interopRequireDefault(require("../helpers/dom/outer-width"));
var _parseAttribute = require("../helpers/dom/parse-attribute");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Inline Calendar
                                                                                                                                                                                                                                                                                                                                              * Create a calendar from which dates can be selected.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new InlineCalendar(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/calendar.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var domDateFormat = 'YYYY-MM-DD';
var parsedDomFormat = (0, _parseFormat.default)(domDateFormat);
function createDefaultElement() {
  var el = document.createElement('span');
  el.className = 'spark-input spark-date';
  el.innerHTML = '<input class="spark-input__field" type="date"><span class="spark-label"></span>';
  return el;
}

/**
 * Parse the proper params for initialization
 * @param  {Element} el
 * @param  {Object} params
 * @return {Objec}
 */
function parseInitParams(el, params) {
  // If the first element is an array or array-like (NodeList),
  // we will be working with a range.
  if (el && el.hasOwnProperty('length')) {
    params.els = el;

    // If the first argument is a plain object, create a default element
    // since the user MUST provide additional params but the element
    // is optional. Doing it this way to keep the parity the same
    // as other components.
  } else if (!(el instanceof HTMLElement)) {
    params = el || {};
    params.els = [createDefaultElement()];

    // A single element is passed.
  } else {
    params.els = [el];
  }
  params.visibleCounts = params.visibleCounts || (params.visibleCount ? [params.visibleCount] : null);
  params.mins = params.mins || (params.min ? [params.min] : []);
  params.maxes = params.maxes || (params.max ? [params.max] : []);
  params.values = (0, _values.default)(params) || (params.value ? [params.value] : []);
  return params;
}
var CalendarInline = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(CalendarInline, _BaseComponent);
  var _super = _createSuper(CalendarInline);
  /**
   * Calendar constructor
   * @param {Element} el Optional
   * @param {Object} params Optional
   */
  function CalendarInline(el) {
    var _context;
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, CalendarInline);
    params = parseInitParams(el, params);
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }

    // Create a calendar element if we weren't passed one.
    (_this.calendarEl ? noop : _this._createCalendar).call((0, _assertThisInitialized2.default)(_this));
    _this.calendarEl.setAttribute('role', 'application');
    _this.activeDate = null;
    _this.userFocusedIndex = null;
    _this._cacheCalendarElements();
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    _this._initDatesToShow();
    _this.updateValues();
    _this._createInlineCalendar();
    _this.inlineCalendar.innerHTML = '';
    _this.inlineCalendar.appendChild(_this.calendarEl);

    // Ensure the cached values are in line with the input values.
    (0, _map.default)(_context = (0, _values.default)(_this)).call(_context, function (value, index) {
      _this.setValue(value, index);
      _this.activeIndex = index;
    });

    // Create a calendar or calendars
    _this._setDatesToShow();
    _this.render();
    _this.activeIndex = 0;
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Update the component to use a new element or reparse from
   * the existing element.
   * @param {Element} el Optional
   */
  (0, _createClass2.default)(CalendarInline, [{
    key: "update",
    value: function update(el) {
      if (el) {
        this._removeEventListeners();
        this.els = el instanceof Array ? el : [el];
        this._cacheElements();
        this._addEventListeners();
      }
      this._parseInputElsParams();
      this._initDatesToShow();
      if (this.activeIndex !== null) {
        this.render();
        this._checkSize();
      }
      this._addTabbableDate();
      return this;
    }

    /**
     * Get the value.
     * @param {Number|Element} index Optional
     * @return {Mixed}
     */
  }, {
    key: "getValue",
    value: function getValue(index) {
      return (0, _values.default)(this)[index || 0];
    }

    /**
     * Set the date for a given element.
     * @param {String|Object} value
     * @param {Number|Element} index
     * @param {Boolean} skipRangeCheck Optional Don't check for sequential range values.
     */
  }, {
    key: "setValue",
    value: function setValue(value, index, skipRangeCheck) {
      var obj = (0, _typeof2.default)(value) === 'object' ? value : parsedDomFormat.getValues(value);
      var el;

      // If we are passed an element instead of an index, use that.
      if (index instanceof HTMLElement) {
        el = index;
        index = this.inputEls.indexOf(el);

        // Otherwise, find the element in our list.
      } else {
        index = index || 0;
        el = this.inputEls[index];
      }

      // Update the stored value
      (0, _values.default)(this)[index] = obj;

      // If we are working with a range, make sure that the values are in order.
      if (value) {
        this._checkValues(index, skipRangeCheck);
      }

      // Set the value on the input element. Make sure we don't get into an infinite
      // loop since we listen to the change event on the input. We have to trigger it
      // so that other components listening to it get the update.
      el.value = value && obj === value ? parsedDomFormat.getString(value) : value || '';
      this._inputsChanging = this._inputsChanging || [];
      if (this._inputsChanging.indexOf(index) === -1) {
        var _context2;
        this._inputsChanging.push(index);
        (0, _triggerEvent.default)(el, 'change');
        (this.onChange || noop)(el, el.value, this);
        var pos = this._inputsChanging.indexOf(index);
        (0, _splice.default)(_context2 = this._inputsChanging).call(_context2, pos, 1);
      }
      this.render({
        clearCache: true
      });
      this.update();
      return this;
    }

    /**
     * Clear the selected values.
     */
  }, {
    key: "clearValues",
    value: function clearValues() {
      var els = this.inputEls;
      var i = 0;
      var len = els.length;
      for (; i < len; i++) {
        this.clearValue(i);
        this.setValue(null, i, true);
      }
      return this;
    }

    /**
     * Clear the selected value.
     * @param {Number} index
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.values = (0, _values.default)(this) || [];
      if (!this.inputEls[index]) throw new Error("Cannot clear value at index ".concat(index, ". No input element exists with that index!"));
      this.setValue(null, index, true);
      return this;
    }

    /**
     * Take the date values from the inputs and set them as dates on the calendar.
     */
  }, {
    key: "updateValues",
    value: function updateValues() {
      var els = this.inputEls;
      var i = 0;
      var len = els.length;
      for (; i < len; i++) {
        this.updateValue(i);
      }
      return this;
    }

    /**
     * Take the date values from the inputs and set them as dates on the calendar.
     * @param {Number} index
     */
  }, {
    key: "updateValue",
    value: function updateValue() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.values = (0, _values.default)(this) || [];
      if (!this.inputEls[index]) throw new Error("Cannot update value at index ".concat(index, ". No input element exists with that index!"));
      (0, _values.default)(this)[index] = this.inputEls[index].value ? parsedDomFormat.getValues(this.inputEls[index].value) : null;
      return this;
    }

    /**
     * Disable the calendar functionality.
     */
  }, {
    key: "disable",
    value: function disable() {
      (0, _addClass.default)(this.inlineCalendar, 'spark-calendar--disabled');
      this.els.forEach(function (element) {
        (0, _addClass.default)(element, 'disabled');
        element.querySelectorAll('input').forEach(function (input) {
          input.setAttribute('disabled', '');
        });
      });
      this.inlineCalendar.querySelectorAll('.spark-calendar__day').forEach(function (day) {
        (0, _addClass.default)(day, 'spark-calendar__day--disabled');
      });
      this.inlineCalendar.querySelectorAll('button').forEach(function (button) {
        button.setAttribute('disabled', '');
        button.setAttribute('tabindex', '-1');
      });
      this._removeEventListeners();
      return this;
    }

    /**
     * Enable the calendar functionality.
     */
  }, {
    key: "enable",
    value: function enable() {
      (0, _removeClass.default)(this.inlineCalendar, 'spark-calendar--disabled');
      this.els.forEach(function (element) {
        (0, _removeClass.default)(element, 'disabled');
        element.querySelectorAll('input').forEach(function (input) {
          input.removeAttribute('disabled', '');
        });
      });
      this.inlineCalendar.querySelectorAll('.spark-calendar__footer button').forEach(function (button) {
        button.removeAttribute('disabled', '');
        button.removeAttribute('tabindex', '-1');
      });
      this.activeIndex = 0;
      this.render({
        clearCache: true
      });
      this._addEventListeners();
      return this;
    }

    /**
     * Render the calendar or calendars.
     * @param {Object} params
     */
  }, {
    key: "render",
    value: function render(params) {
      params = params || {};

      // If we don't have a inline calendar yet, create it.
      if (!this.inlineCalendar) {
        this._createInlineCalendar();
      }
      var content;

      // Clear the cache so that we don't show out-of-date values.
      if (params.clearCache) {
        this._renderCache = {};
      }

      // Create the visible days, weeks, months or years
      if (this.viewRange === 'year') content = this._renderYears();else if (this.viewRange === 'week') content = this._renderWeeks();else if (this.viewRange === 'day') content = this._renderDays();else content = this._renderMonths();
      this._insertContent(content, params);

      // Update attributes
      this._updateAttributes();
      if (this.activeDate) {
        var activeButton = this.calendarContentEl.querySelector("[data-date='" + this.activeDate.getAttribute('data-date') + "']");
        if (activeButton) {
          activeButton.setAttribute('tabindex', 0);
        }
      }
      return this;
    }

    /**
     * Cleans up event listeners and removes helpers.
     * @param {Boolean} leaveElement Leave the element intact.
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      this.inlineCalendar && this.inlineCalendar.remove();
      return (0, _get2.default)((0, _getPrototypeOf2.default)(CalendarInline.prototype), "remove", this).call(this, leaveElement);
    }

    /**
     * Move to the next set of dates.
     */
  }, {
    key: "next",
    value: function next() {
      if (this._atMax) return this;
      this._setDatesToShow(1);
      this.render({
        append: 1
      });
      return this;
    }

    /**
     * Move to the previous set of dates.
     */
  }, {
    key: "previous",
    value: function previous() {
      if (this._atMin) return this;
      this._setDatesToShow(-1);
      this.render({
        prepend: 1
      });
      return this;
    }

    /**
     * Show a specific date on the calendar.
     * @param {Object} params
     */
  }, {
    key: "showDate",
    value: function showDate(params) {
      var _context3;
      var month = params.month || null;
      var year = params.year || null;
      var day = params.day || null;

      // Nothing to do.
      if (!month && !year && !day) {
        return this;
      }
      var showing = this._datesToShow[this.activeIndex].clone();
      var noun = this.viewRange.charAt(0).toUpperCase() + (0, _slice.default)(_context3 = this.viewRange).call(_context3, 1);

      // Only change the values we were given
      if (year) {
        showing.year = year;
      }
      if (month) {
        showing.month = month;
      }
      if (day) {
        showing.day = day;
      }

      // Check min
      var min = this.mins[this.activeIndex];
      if (min && showing['before' + noun](min)) {
        showing = min.clone();
      }

      // Check max
      var max = this.maxes[this.activeIndex];
      if (max && showing['after' + noun](max)) {
        showing = max.clone();
      }
      this._datesToShow[this.activeIndex] = showing;

      // Populate the rest of the dates
      this._setDatesToShow();
      return this.render();
    }

    /**
     * Render the appropriate number of years.
     * @return {Array}
     */
  }, {
    key: "_renderYears",
    value: function _renderYears() {
      throw new Error('Displaying years in the calendar is not yet supported!');
    }

    /**
     * Render the appropriate number of weeks.
     * @return {Array}
     */
  }, {
    key: "_renderWeeks",
    value: function _renderWeeks() {
      throw new Error('Displaying weeks in the calendar is not yet supported!');
    }

    /**
     * Render the appropriate number of days.
     * @return {Array}
     */
  }, {
    key: "_renderDays",
    value: function _renderDays() {
      throw new Error('Displaying days in the calendar is not yet supported!');
    }

    /**
     * Render the appropriate number of months.
     * @return {Array}
     */
  }, {
    key: "_renderMonths",
    value: function _renderMonths() {
      var months = [];
      var i = 0;
      var len = this._datesToShow.length;
      var current = _date.default.now();
      for (; i < len; i++) {
        months.push(this._renderMonth(this._datesToShow[i], current));
      }
      return months;
    }
  }, {
    key: "_addTabbableDate",
    value: function _addTabbableDate() {
      this.calendarContentEl.querySelectorAll(".spark-calendar__day[tabindex='0']").forEach(function (date) {
        return date.setAttribute("tabindex", "-1");
      });
      var elTabbable = null;
      if (this.activeDate) {
        elTabbable = this.calendarContentEl.querySelector("[data-date='" + this.activeDate.getAttribute('data-date') + "']");
      } else if (this.calendarContentEl.querySelector('.spark-calendar__day--selected.spark-calendar__range-start')) {
        // if date is selected, use this element for tab focus
        elTabbable = this.calendarContentEl.querySelector('.spark-calendar__day--selected.spark-calendar__range-start');
      } else if (this.calendarContentEl.querySelector('.spark-calendar__day--selected.spark-calendar__range-end.spark-calendar__range-last')) {
        elTabbable = this.calendarContentEl.querySelector('.spark-calendar__day--selected.spark-calendar__range-end.spark-calendar__range-last');
      } else if (this.calendarContentEl.querySelector('.spark-calendar__day--today:not([disabled])')) {
        // else if today, use this element for tab focus
        elTabbable = this.calendarContentEl.querySelector('.spark-calendar__day--today:not([disabled])');
      } else {
        // else use first available date, use this element for tab focus
        elTabbable = this.calendarContentEl.querySelector('button:not([disabled])');
      }
      if (elTabbable) {
        elTabbable.setAttribute('tabindex', 0);
      }
    }

    /**
     * Render a month.
     * @param {Object} date
     * @param {Object} current
     * @return {Element}
     */
  }, {
    key: "_renderMonth",
    value: function _renderMonth(date, current) {
      if ((0, _hasClass.default)(document.activeElement, 'spark-calendar__day')) {
        this.activeDate = document.activeElement;
      } else {
        this.activeDate = null;
      }

      // A unique key for this month used for caching
      var key = date.year + '-' + date.month;

      // Ensure we have a cache
      this._renderCache = this._renderCache || {};

      // Return a cached instance
      if (this._renderCache[key]) {
        return this._renderCache[key];
      }

      // Create the element
      var el = document.createElement('div');
      var html = '';
      el.className = 'spark-calendar__month ' + this._getMonthClassNames(date);

      // Add the title or dropdowns.
      html += '<div class="spark-calendar__month-title">';
      html += '<span>' + date.monthName + ' ' + date.year + '</span>';
      html += '</div>';

      // Add the days of the week headings
      html += this._renderMonthDaysOfWeek();

      // Add the days
      html += this._renderMonthDays(date, current);
      el.innerHTML = html;

      // Store in the cache and return
      return this._renderCache[key] = el;
    }

    /**
     * Render the days of week row for a month calendar.
     * @return {String}
     */
  }, {
    key: "_renderMonthDaysOfWeek",
    value: function _renderMonthDaysOfWeek() {
      var daysOfWeek = _date.default.getDayNames();
      var i = 0;
      var len = daysOfWeek.length;
      var str = '<div class="spark-calendar__days-of-week">';
      for (; i < len; i++) {
        str += '<span class="spark-calendar__day-of-week">' + daysOfWeek[i][0] + '</span>';
      }
      return str += '</div>';
    }

    /**
     * Render the days of week row for a month calendar.
     * @param {Object} date
     * @param {Object} current
     * @return {String}
     */
  }, {
    key: "_renderMonthDays",
    value: function _renderMonthDays(date, current) {
      var dayOfWeek = date.monthStart.dayOfWeek;
      var startOfWeek = dayOfWeek > 1 ? date.monthStart.weekStart : null;
      var monthEnd = date.monthEnd;
      var weeks = 6;
      var i = 0;
      var j = 0;
      var str = '<div class="spark-calendar__days" role="grid">';
      var day = 0;
      var month = startOfWeek ? startOfWeek.month : date.month;
      var year = startOfWeek ? startOfWeek.year : date.year;
      var isCurrentMonth = current.year === date.year && current.month === date.month;

      // If we have days that come before the first of the month, the days will start as
      // inactive. We use a 1 here to indicate the date is inactive and _before_
      // the start of the month.
      var inactive = startOfWeek ? 1 : null;
      for (; i < weeks; i++) {
        for (; j < 7; j++) {
          day = startOfWeek ? startOfWeek.day + j : day + 1;
          str += this._renderMonthDay(day, month, year, isCurrentMonth, current, inactive);
          if (startOfWeek && j + 1 >= dayOfWeek - 1) {
            startOfWeek = null;
            inactive = null;
            day = 0;
            month = date.month;
            year = date.year;
            isCurrentMonth = current.year === date.year && current.month === date.month;
          } else if (day >= monthEnd.day && i > 0) {
            // Inactive days that come _after_ the last of the month are denoted with a 2.
            // _renderMonthDay handles 1s and 2s differently, but both add the inactive class.
            inactive = 2;
            isCurrentMonth = false;
            day = 0;
            month++;
            if (month > 12) {
              year++;
              month = 1;
            }
          }
        }
        j = 0;
      }
      return str += '</div>';
    }

    /**
     * Render a day of the month.
     * @param {Number} day
     * @param {Number} month
     * @param {Number} year
     * @param {Boolean} isCurrentMonth
     * @param {Object} current
     * @param {Boolean} inactive
     */
  }, {
    key: "_renderMonthDay",
    value: function _renderMonthDay(day, month, year, isCurrentMonth, current, inactive) {
      var date = _date.default.create({
        year: year,
        month: month,
        day: day
      });
      var str = '<button';
      var disabled = inactive || this._isDayDisabled(date);
      var ariaDateLabel = date.dayName + ' ' + day + ' ' + date.monthName + ' ' + year;
      if (this.inputEls.length === 1 && this._isDaySelected(date)) {
        str += ' aria-label="' + this.ariaSelectedLabel + ' ' + ariaDateLabel + '"';
      } else if (this._isDayRangeStart(date)) {
        str += ' aria-label="' + this.ariaStartDateLabel + ' ' + ariaDateLabel + '"';
      } else if (this._isDayRangeEnd(date)) {
        str += ' aria-label="' + this.ariaEndDateLabel + ' ' + ariaDateLabel + '"';
      } else if (this._isDayRangeMiddle(date)) {
        str += ' aria-label="' + this.ariaSelectedLabel + ' ' + ariaDateLabel + '"';
      } else {
        str += ' aria-label="' + ariaDateLabel + '"';
      }
      str += ' aria-label="' + date.dayName + ' ' + day + ' ' + date.monthName + ' ' + year + '"';
      str += !disabled ? ' data-date="' + parsedDomFormat.getString(date) + '"' : '';
      str += inactive ? ' data-direction="' + (inactive === 2 ? 'next' : 'previous') + '"' : '';
      str += disabled ? ' aria-hidden="true"' : '';
      str += ' class="spark-calendar__day';
      str += isCurrentMonth && current.day === day && current.month === month && current.year === year ? ' spark-calendar__day--today' : '';
      str += inactive ? ' spark-calendar__day--inactive' : '';
      str += disabled ? ' spark-calendar__day--disabled' : '';
      str += this._isDaySelected(date) ? ' spark-calendar__day--selected' : '';
      str += this._isDayRangeStart(date) && (0, _values.default)(this).length > 1 ? ' spark-calendar__range-start' : '';
      str += this._isDayRangeMiddle(date) ? ' spark-calendar__range-middle' : '';
      str += this._isDayRangeEnd(date) ? ' spark-calendar__range-end' : '';
      str += this._isDayRangeLast(date) ? ' spark-calendar__range-last' : '';
      str += '"';
      str += disabled ? 'disabled' : '';
      str += ' tabindex="-1"';
      str += '><span class="spark-calendar__day--number">';
      str += day;
      str += this._getDayInfo(date);
      str += '</span></button>';
      return str;
    }

    /**
     * Render the children into the content.
     * @param {Array} content
     */
  }, {
    key: "_insertContent",
    value: function _insertContent(content, params) {
      if (!this.calendarContentEl) {
        return;
      }
      this._currentContent = this._currentContent || [];
      params = params || {};
      var keep;
      var i = 0;
      var len;

      // If we've been asked to prepend or append, add the new elements in front,
      // save the number of old elements we're sliding out, animate,
      // then clean up.
      if (this.animate) {
        if (params.prepend) {
          var _context4;
          // Get the last elements to keep
          keep = (0, _slice.default)(_context4 = this._currentContent).call(_context4, -params.prepend);
          len = keep.length;
          for (; i < len; i++) {
            content.push(keep[i]);
          }
          this.calendarEl.setAttribute('data-prepend-count', len);
          this._animateContent(function () {
            this.calendarEl.removeAttribute('data-prepend-count');
            this._animateContent(function () {
              content = (0, _slice.default)(content).call(content, 0, -params.prepend);
              this._insertContent(content);
            }, this.animationDuration);
          }, 10);

          // Same but appending
        } else if (params.append) {
          var _context5;
          // Get the first elements to keep
          keep = (0, _slice.default)(_context5 = this._currentContent).call(_context5, 0, params.append);
          len = keep.length;
          for (; i < len; i++) {
            content.unshift(keep[i]);
          }
          this.calendarEl.setAttribute('data-append-count', len);
          this._animateContent(function () {
            (0, _addClass.default)(this.calendarEl, 'no-animate');
            content = (0, _slice.default)(content).call(content, params.append);
            this._insertContent(content);
            this.calendarEl.removeAttribute('data-append-count');
            this._animateContent(function () {
              (0, _removeClass.default)(this.calendarEl, 'no-animate');
            }, 10);
          }, this.animationDuration);
        }
      }
      (0, _appendChildren.default)(this.calendarContentEl, this._currentContent = content, true);
    }

    /**
     * Is a given day selected?
     * @param {Object} date
     * @return {Boolean}
     */
  }, {
    key: "_isDaySelected",
    value: function _isDaySelected(date) {
      return (0, _values.default)(this) && date.equal((0, _values.default)(this));
    }

    /**
     * Is a given day the start of a range?
     * @param {Object} date
     * @return {Boolean}
     */
  }, {
    key: "_isDayRangeStart",
    value: function _isDayRangeStart(date) {
      return this.inputEls.length > 1 && (0, _values.default)(this) && date.equal((0, _values.default)(this)[0]);
    }

    /**
     * Is a given day the middle of a range?
     * @param {Object} date
     * @return {Boolean}
     */
  }, {
    key: "_isDayRangeMiddle",
    value: function _isDayRangeMiddle(date) {
      return this.inputEls.length > 1 && (0, _values.default)(this) && (0, _values.default)(this).length > 1 && date.after((0, _values.default)(this)[0]) && date.before((0, _values.default)(this)[(0, _values.default)(this).length - 1]);
    }

    /**
     * Is a given day the end of a range?
     * @param {Object} date
     * @return {Boolean}
     */
  }, {
    key: "_isDayRangeEnd",
    value: function _isDayRangeEnd(date) {
      return this.inputEls.length > 1 && (0, _values.default)(this) && (0, _values.default)(this).length > 1 && date.equal((0, _values.default)(this)[(0, _values.default)(this).length - 1]);
    }

    /**
     * Is a given day currently the last
     * @param {Object} date
     * @return {Boolean}
     */
  }, {
    key: "_isDayRangeLast",
    value: function _isDayRangeLast(date) {
      var i = (0, _values.default)(this).length - 1;
      for (; i > 0; i--) {
        // We have a value and it's not the same as the date.
        if ((0, _values.default)(this)[i]) {
          if (!date.equal((0, _values.default)(this)[i])) {
            return false;
          }
          break;
        }
      }
      return true;
    }

    /**
     * Is a given day disabled?
     * @param {Object} date
     * @return {Boolean}
     */
  }, {
    key: "_isDayDisabled",
    value: function _isDayDisabled(date) {
      return this.daysDisabled && this.daysDisabled[date.year] && this.daysDisabled[date.year][date.month] && this.daysDisabled[date.year][date.month].indexOf(date.day) !== -1 || this.mins[this.activeIndex] && date.before(this.mins[this.activeIndex], true) || this.maxes[this.activeIndex] && date.after(this.maxes[this.activeIndex], true);
    }

    /**
     * Get any "info" for a given day.
     * @param {Object} date
     * @return {String}
     */
  }, {
    key: "_getDayInfo",
    value: function _getDayInfo(date) {
      return this.daysInfo && this.daysInfo[date.year] && this.daysInfo[date.year][date.month] && this.daysInfo[date.year][date.month][date.day] ? '<span class="spark-calendar__day-note">' + this.daysInfo[date.year][date.month][date.day] + '</span>' : '';
    }

    /**
     * Get the class names for a month.
     * @param {Object} date
     * @return {String}
     */
  }, {
    key: "_getMonthClassNames",
    value: function _getMonthClassNames(date) {
      var cls = [];

      // Do we have a value in this month?
      if (date.equalMonth((0, _values.default)(this))) {
        cls.push('has-value');
      }

      // Does this month have the start, middle or end of a range?
      if (this._isRange && this.els.length > 1) {
        var _context6;
        var start = date.equalMonth((0, _values.default)(this)[0]);
        var end = date.equalMonth((0, _values.default)(this)[(0, _values.default)(this).length - 1]);
        var middle = date.equalMonth((0, _slice.default)(_context6 = (0, _values.default)(this)).call(_context6, 1, -1));
        var valBefore = date.afterMonth((0, _values.default)(this));
        var valAfter = date.beforeMonth((0, _values.default)(this));
        var afterEnd = (0, _values.default)(this)[(0, _values.default)(this).length - 1] && date.after((0, _values.default)(this)[(0, _values.default)(this).length - 1]);
        if (start) {
          cls.push('range-start');
        }
        if (end) {
          cls.push('range-end');
        }
        if (middle) {
          cls.push('range-middle');
        }
        if (valBefore) {
          cls.push('value-before');
        }
        if (valAfter) {
          cls.push('value-after');
        }
        if (afterEnd) {
          cls.push('after-range-end');
        }
      }
      return cls.join(' ');
    }

    /**
     * Create the calendar.
     */
  }, {
    key: "_createCalendar",
    value: function _createCalendar() {
      var el = document.createElement('div');
      (0, _addClass.default)(el, 'spark-calendar');
      if (this.showTodayButton) {
        var todayButtonStr = '<button type="button" class="spark-calendar__today spark-btn spark-btn--text">' + this.todayButtonLabel + '</button>';
        el.innerHTML = '<nav class="spark-calendar__nav"><button class="spark-calendar__previous spark-icon-chevron-left" aria-label="Previous month"></button><button class="spark-calendar__next spark-icon-chevron-right" aria-label="Next month"></button></nav><div class="spark-calendar__overflow spark-calendar__overflow--has-footer"><div class="spark-calendar__content"></div><div class="spark-calendar__footer">' + todayButtonStr + '</div></div>';
      } else {
        el.innerHTML = '<nav class="spark-calendar__nav"><button class="spark-calendar__previous spark-icon-chevron-left" aria-label="Previous month" type="button"></button><button class="spark-calendar__next spark-icon-chevron-right" aria-label="Next month" type="button"></button></nav><div class="spark-calendar__overflow"><div class="spark-calendar__content"></div></div>';
      }
      this.calendarEl = el;
      this.calendarContentEl = el.querySelector('.spark-calendar__content');
      this.calendarOverflowEl = el.querySelector('.spark-calendar_overflow');
    }

    /**
     * Create the inlineCalendar.
     */
  }, {
    key: "_createInlineCalendar",
    value: function _createInlineCalendar() {
      this.inlineCalendar = document.createElement('div');
      (0, _addClass.default)(this.inlineCalendar, 'spark-calendar-inline');
      if (this.els[0].parentNode && (0, _hasClass.default)(this.els[0].parentNode, 'spark-input-group')) {
        this.els[0].parentNode.appendChild(this.inlineCalendar);
      } else {
        this.els[0].appendChild(this.inlineCalendar);
      }
      var bp = (0, _breakpoint.get)((0, _outerWidth.default)(this.inlineCalendar));
      this._currentBreakpoint = bp;
    }

    /**
     * Cache elements.
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements() {
      this.inputEls = [];
      var i = 0;
      var len = this.els.length;
      var input;
      for (; i < len; i++) {
        input = this.els[i].nodeName.toLowerCase() === 'input' ? this.els[i] : this.els[i].querySelector('input[type="date"]');
        this.inputEls[i] = input;
      }
    }

    /**
     * Cache elements specific to the calendar.
     */
  }, {
    key: "_cacheCalendarElements",
    value: function _cacheCalendarElements() {
      this.nextButtonEl = this.calendarEl.querySelector('.spark-calendar__next');
      this.previousButtonEl = this.calendarEl.querySelector('.spark-calendar__previous');
    }

    /**
     * Parse parameters from the elements.
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      this._parseInputElsParams();
      this._isRange = this.els.length > 1 ? true : false;
      this.viewRange = this.viewRange !== null ? this.viewRange : (0, _parseAttribute.string)(this.els[0], 'data-view-range', 'month');
      this.animate = this.animate !== null ? this.animate : (0, _parseAttribute.boolean)(this.els[0], 'data-animate', true);
      this.animationDuration = this.animationDuration !== null ? this.animationDuration : (0, _parseAttribute.number)(this.els[0], 'data-animation-duration', 100);
      this.showOnFocus = this.showOnFocus !== null ? this.showOnFocus : (0, _parseAttribute.boolean)(this.els[0], 'data-show-on-focus', false);
      this.showTodayButton = this.showTodayButton !== null ? this.showTodayButton : (0, _parseAttribute.boolean)(this.els[0], 'data-show-today-button', false);
      this.todayButtonLabel = this.todayButtonLabel !== null ? this.todayButtonLabel : (0, _parseAttribute.string)(this.els[0], 'data-today-button-label', 'Select Today');
    }

    /**
     * Parse the min, max, value and visible counts from the elements if we can.
     * @return {Number|Boolean}
     */
  }, {
    key: "_parseInputElsParams",
    value: function _parseInputElsParams() {
      var els = this.inputEls;
      if (!els) {
        return;
      }
      var i = 0;
      var len = els.length;
      var mins = [];
      var maxes = [];
      var values = [];
      var visibleCounts = [];
      var disableds = [];
      for (; i < len; i++) {
        if (!els[i]) {
          continue;
        }
        if (this.mins && this.mins[i]) mins[i] = (0, _typeof2.default)(this.mins[i]) === 'object' ? this.mins[i] : parsedDomFormat.getValues(this.mins[i]);else if (els[i].getAttribute('min')) mins[i] = parsedDomFormat.getValues(els[i].getAttribute('min'));
        if (this.maxes && this.maxes[i]) maxes[i] = (0, _typeof2.default)(this.maxes[i]) === 'object' ? this.maxes[i] : parsedDomFormat.getValues(this.maxes[i]);else if (els[i].getAttribute('max')) maxes[i] = parsedDomFormat.getValues(els[i].getAttribute('max'));
        if ((0, _values.default)(this) && (0, _values.default)(this)[i]) values[i] = (0, _typeof2.default)((0, _values.default)(this)[i]) === 'object' ? (0, _values.default)(this)[i] : parsedDomFormat.getValues((0, _values.default)(this)[i]);else if (els[i].value) values[i] = parsedDomFormat.getValues(els[i].value);
        disableds[i] = (0, _parseAttribute.boolean)(els[i], 'disabled', false);
        if (!this.visibleCounts) visibleCounts[i] = parseInt(els[i].getAttribute('data-visible-count'), 10) || 1;
      }
      this.mins = mins;
      this.minVisible = _date.default.earliest(mins);
      this.maxes = maxes;
      this.maxVisible = _date.default.latest(maxes);
      this.values = values;
      this._isDisabled = disableds;
      if (visibleCounts.length) this.visibleCounts = visibleCounts;
    }

    /**
     * Get the dates we should be showing. Start with the first value or today's date.
     */
  }, {
    key: "_initDatesToShow",
    value: function _initDatesToShow() {
      var arr = [];
      var i = 0;
      var len = (0, _values.default)(this).length;

      // Get the date for the current index
      if ((0, _values.default)(this)[this.activeIndex]) {
        arr.push((0, _values.default)(this)[this.activeIndex].clone());
      }

      // Get the first date
      for (; i < len && !arr.length; i++) {
        if ((0, _values.default)(this)[i]) {
          arr.push((0, _values.default)(this)[i].clone());
        }
      }

      // If we didn't get a date, use the min
      for (i = 0, len = this.mins.length; i < len && !arr.length; i++) {
        if (this.mins[i]) {
          arr.push(this.mins[i].clone());
        }
      }

      // If we still didn't get a date, add today's date.
      if (!arr.length) {
        arr.push(_date.default.now());
      }
      this._datesToShow = arr;
      this._setDatesToShow();
    }

    /**
     * Set the dates to show.
     * @param {Number} change Optional The direction to change
     */
  }, {
    key: "_setDatesToShow",
    value: function _setDatesToShow(change) {
      var _context7;
      var arr = this._datesToShow;
      var visibleCount = this._currentBreakpoint === 'xs' || this._currentBreakpoint === 'sm' ? 1 : this.visibleCounts[this.activeIndex] || this.visibleCounts[0] || 1;
      var i = 0;
      var noun = this.viewRange.charAt(0).toUpperCase() + (0, _slice.default)(_context7 = this.viewRange).call(_context7, 1);

      // If we have more dates to show than we're supposed to show, remove the excess.
      // This happens when visible count changes between renders
      if (arr.length > visibleCount) {
        (0, _splice.default)(arr).call(arr, visibleCount);
      }

      // If we are incrementing or decrementing the starting month
      if (change) {
        // Empty the rest of the dates from the array
        arr = this._datesToShow = (0, _splice.default)(arr).call(arr, 0, 1);

        // Decrement
        if (change < 0) {
          for (; i > change; i--) {
            arr[0] = arr[0]['previous' + noun];
          }
        } else {
          for (; i < change; i++) {
            arr[0] = arr[0]['next' + noun];
          }
        }
      }

      // Check bounds
      this._atMin = this._checkMinDateVisible(noun, arr);
      this._atMax = this._checkMaxDateVisible(noun, arr);
      var addDate;
      var lastSelected;
      var action;
      i = 0;

      // Add additional dates
      while (arr.length < visibleCount) {
        // If at the max, prepend
        // If we're in the last input and it has a value and it's a different month than the first value, prepend
        // If at the min, append
        // If an item we're adding is before the min, discard it and append an item after the last in the arr
        // If an item we're adding is after the max, discard it and prepend an item before the first in the arr
        lastSelected = !change && this.activeIndex === (0, _values.default)(this).length - 1 && (0, _values.default)(this)[(0, _values.default)(this).length - 1] && (0, _values.default)(this)[0] && !(0, _values.default)(this)[(0, _values.default)(this).length - 1]['equal' + noun]((0, _values.default)(this), true);

        // If we're showing the max date or we have the last input selected and it has a value, add dates before.
        if (this._atMax || lastSelected) {
          addDate = arr[i]['previous' + noun];
          action = 'unshift';
          if (addDate['before' + noun](this.minVisible)) {
            addDate = arr[i]['next' + noun];
            action = 'push';
          }
        } else {
          addDate = arr[i]['next' + noun];
          action = 'push';
          if (addDate['after' + noun](this.maxVisible)) {
            addDate = arr[i]['previous' + noun];
            action = 'unshift';
          }
        }
        if (action === 'push') {
          arr.push(addDate);
          i = arr.length - 1;
        } else {
          arr.unshift(addDate);
          i = 0;
        }
      }

      // Check bounds again
      this._atMin = this._checkMinDateVisible(noun, arr);
      this._atMax = this._checkMaxDateVisible(noun, arr);

      // Update the navigation to reflect the _atMin or _atMax state
      this._updateNav();
    }

    /**
     * Check for the min value in an array of values.
     * @param {Object} min
     * @param {String} noun The type of date to check
     * @param {Array} arr
     * @return {Boolean}
     */
  }, {
    key: "_checkMinDateVisible",
    value: function _checkMinDateVisible(noun, arr) {
      if (!this.minVisible) {
        return;
      }
      var min = this.minVisible;
      if (min && (arr[0]['equal' + noun](min) || arr[0]['before' + noun](min))) {
        arr[0] = min;
        return true;
      }
      return false;
    }

    /**
     * Check for the max value in an array of values.
     * @param {Object} max
     * @param {String} noun The type of date to check
     * @param {Array} arr
     * @return {Boolean}
     */
  }, {
    key: "_checkMaxDateVisible",
    value: function _checkMaxDateVisible(noun, arr) {
      if (!this.maxVisible) {
        return;
      }
      var max = this.maxVisible;
      if (max && arr[arr.length - 1] && (arr[arr.length - 1]['equal' + noun](max) || arr[arr.length - 1]['after' + noun](max))) {
        arr[arr.length - 1] = max;
        return true;
      }
      return false;
    }

    /**
     * Check that the values are in bounds and, optinoally, in sequential order.
     * If checking for sequence, remove those which aren't.
     * @param {Number} setIndex The index of the value most recently set. This shouldn't be removed.
     * @return {Boolean} Did any values change?
     */
  }, {
    key: "_checkValues",
    value: function _checkValues(setIndex, skipRangeCheck) {
      // Check boundaries
      var changed = this._checkMinMaxValues();

      // Sequential range items check
      if (this._isRange && !skipRangeCheck) {
        var i = (0, _values.default)(this).length - 1;
        for (; i >= 0; i--) {
          if ((0, _values.default)(this)[i] && (0, _values.default)(this)[i - 1] && (0, _values.default)(this)[i].beforeDay((0, _values.default)(this)[i - 1], true)) {
            if (i === setIndex) {
              this.setValue(null, i - 1, true);
            } else {
              this.setValue(null, i, true);
            }
            changed = true;
          }
        }
      }
      return changed;
    }

    /**
     * Check minimum/maximum values.
     * @return {Boolean}
     */
  }, {
    key: "_checkMinMaxValues",
    value: function _checkMinMaxValues() {
      var i = 0;
      var len = (0, _values.default)(this).length;
      var changed = false;
      for (; i < len; i++) {
        if (this.maxes && this.maxes[i] && (0, _values.default)(this)[i] && (0, _values.default)(this)[i].after(this.maxes[i], true)) {
          (0, _values.default)(this)[i] = this.maxes[i].clone();
          changed = true;
        } else if (this.mins && this.mins[i] && (0, _values.default)(this)[i] && (0, _values.default)(this)[i].before(this.mins[i], true)) {
          (0, _values.default)(this)[i] = this.mins[i].clone();
          changed = true;
        }
      }
      return changed;
    }

    /**
     * Enqueue animations to be run. (Not really animations since those happen w/ CSS. More
     * of a manager of timeouts).
     * @param {Function} cb
     * @param {Number} duration
     */
  }, {
    key: "_animateContent",
    value: function _animateContent(cb, duration) {
      this._animationQueue = this._animationQueue || [];
      this._animationQueue.push({
        cb: cb,
        d: duration
      });
      this._runAnimation();
    }

    /**
     * Run the first queued animation. When complete, run the next animation.
     */
  }, {
    key: "_runAnimation",
    value: function _runAnimation() {
      if (!this._animationTimer) {
        var a = this._animationQueue.shift();
        if (a) {
          this._animationTimer = setTimeout(function () {
            a.cb.call(this);
            this._animationTimer = null;
            this._runAnimation();
          }.bind(this), a.d);
        } else {
          this._addTabbableDate();
        }
      }
    }

    /**
     * Update attributes on the element and its children.
     */
  }, {
    key: "_updateAttributes",
    value: function _updateAttributes() {
      this.calendarEl.setAttribute('data-visible-count', this._currentBreakpoint === 'xs' ? 1 : this.visibleCounts[this.activeIndex] || this.visibleCounts[0] || 1);
      this._updateNav();
    }

    /**
     * Update the navigation to reflect the ability to move forward and backward.
     */
  }, {
    key: "_updateNav",
    value: function _updateNav() {
      if (this.previousButtonEl) {
        if (this._atMin) this.previousButtonEl.setAttribute('disabled', true);else this.previousButtonEl.removeAttribute('disabled');
      }
      if (this.nextButtonEl) {
        if (this._atMax) this.nextButtonEl.setAttribute('disabled', true);else this.nextButtonEl.removeAttribute('disabled');
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onInputChangeBound = this._onInputChange.bind(this);
      this._onSelectChangeBound = this._onSelectChange.bind(this);
      this._onClickBound = this._onClick.bind(this);
      this._onCalendarClickBound = this._onCalendarClick.bind(this);
      this._onKeydownBound = this._onKeydown.bind(this);
      this._onCalendarKeydownBound = this._onCalendarKeydown.bind(this);
      this._onCalendarMouseOverBound = this._onCalendarMouseOver.bind(this);
      this._onCalendarMouseOutBound = this._onCalendarMouseOut.bind(this);
      this._onResizeBound = (0, _debounce.default)(this._onResize.bind(this), 25);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      var i = 0;
      var len = this.els.length;
      for (; i < len; i++) {
        this.els[i].addEventListener('click', this._onClickBound);
        this.els[i].addEventListener('keydown', this._onKeydownBound);
        this.inputEls[i].addEventListener('change', this._onInputChangeBound);
      }
      this.calendarEl.addEventListener('mouseover', this._onCalendarMouseOverBound);
      this.calendarEl.addEventListener('mouseout', this._onCalendarMouseOutBound);
      this.calendarEl.addEventListener('click', this._onCalendarClickBound);
      this.calendarEl.addEventListener('keydown', this._onCalendarKeydownBound);
      this.calendarEl.addEventListener('change', this._onSelectChangeBound);
      window.addEventListener('resize', this._onResizeBound);
      window.addEventListener('orientationchange', this._onResizeBound);
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      var i = 0;
      var len = this.els.length;
      for (; i < len; i++) {
        this.els[i].removeEventListener('click', this._onClickBound);
        this.els[i].removeEventListener('keydown', this._onKeydownBound);
        this.inputEls[i].removeEventListener('change', this._onInputChangeBound);
      }
      this.calendarEl.removeEventListener('mouseover', this._onCalendarMouseOverBound);
      this.calendarEl.removeEventListener('mouseout', this._onCalendarMouseOutBound);
      this.calendarEl.removeEventListener('click', this._onCalendarClickBound);
      this.calendarEl.removeEventListener('keydown', this._onCalendarKeydownBound);
      this.calendarEl.removeEventListener('change', this._onSelectChangeBound);
      window.removeEventListener('resize', this._onResizeBound);
      window.removeEventListener('orientationchange', this._onResizeBound);
    }

    /**
     * Activate the element associated with the calendar.
     * @param {Number} index
     */
  }, {
    key: "_activateElement",
    value: function _activateElement(index) {
      var el = this.els[index];
      if (el) {
        (0, _addClass.default)(el, 'active');
      }
    }

    /**
     * Deactivate the element associated with the calendar.
     * @param {Number} index
     */
  }, {
    key: "_deactivateElement",
    value: function _deactivateElement(index) {
      var el = this.els[index];
      if (el && !(0, _values.default)(this)[index] && !(0, _hasClass.default)(el, 'focus') && !(0, _hasClass.default)(el, 'has-partial-value')) {
        (0, _removeClass.default)(el, 'active');
      }
    }

    /**
     * Check the size of the container and see if we should be showing the XS treatment.
     */
  }, {
    key: "_checkSize",
    value: function _checkSize() {
      var bp = (0, _breakpoint.get)((0, _outerWidth.default)(this.inlineCalendar));

      // Don't do anything if the breakpoint hasn't changed.
      if (this._currentBreakpoint === bp) return;

      // Store the breakpoint
      this._currentBreakpoint = bp;

      // Re-render the date range
      this._setDatesToShow();
      this.render(true);
    }

    /**
     * Scroll the active input element into view.
     */
  }, {
    key: "_scrollToInput",
    value: function _scrollToInput() {
      var el = this.els[this.activeIndex];
      if (el) (0, _scrollTo.default)(el);
    }

    /**
     * Update the hover classes.
     * @param {Element} hoverStarts
     * @param {Element} hoverEnds
     */
  }, {
    key: "_updateHoverClasses",
    value: function _updateHoverClasses(hoverStarts, hoverEnds) {
      this._hoverStarts = this._hoverStarts || [];
      this._hoverEnds = this._hoverEnds || [];
      hoverStarts = hoverStarts instanceof Array ? hoverStarts : hoverStarts ? [hoverStarts] : [];
      hoverEnds = hoverEnds instanceof Array ? hoverEnds : hoverEnds ? [hoverEnds] : [];
      var allStarts = [];
      var curStarts = [];
      var newStarts = [];
      var allEnds = [];
      var curEnds = [];
      var newEnds = [];
      hoverStarts.forEach(function (el) {
        var index = this._hoverStarts.indexOf(el);

        // Already hovered.
        if (index !== -1) {
          curStarts.push(el);

          // Not already hovered. Ready to add the class.
        } else if (el) {
          newStarts.push(el);
          (0, _addClass.default)(el, 'hover-start');
        }
      }, this);
      allStarts = (0, _concat.default)(Array.prototype).call([], curStarts, newStarts);
      this._hoverStarts.forEach(function (el) {
        if (allStarts.indexOf(el) === -1) {
          (0, _removeClass.default)(el, 'hover-start');
        }
      }, this);
      hoverEnds.forEach(function (el) {
        var index = this._hoverEnds.indexOf(el);

        // Already hovered.
        if (index !== -1) {
          curEnds.push(el);

          // Not already hovered. Ready to add the class.
        } else if (el) {
          newEnds.push(el);
          (0, _addClass.default)(el, 'hover-end');
        }
      }, this);
      allEnds = (0, _concat.default)(Array.prototype).call([], curEnds, newEnds);
      this._hoverEnds.forEach(function (el) {
        if (allEnds.indexOf(el) === -1) {
          (0, _removeClass.default)(el, 'hover-end');
        }
      }, this);
      this._hoverStarts = allStarts;
      this._hoverEnds = allEnds;
    }

    /**
     * Check which element is clicked, set indexes
     * @param {Object} e
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      if ((0, _hasClass.default)(e.target, 'spark-input__field')) {
        var el = (0, _getParent.default)(e.target, '.spark-date', this.els);
        var index = this.els.indexOf(el);
        this.activeIndex = index;
        this.userFocusedIndex = index;
      }
    }

    /**
     * When a key is pressed and it is the Enter key
     * @param {Object} e
     */
  }, {
    key: "_onKeydown",
    value: function _onKeydown(e) {
      // Enter key press on Calendar
      if (e.keyCode === 13 && (0, _getParent.default)(e.target, '.spark-date__calendar-toggle', this.els)) {
        this._onClick(e);
      }
    }

    /**
     * When a key is pressed within the Calendar
     * @param {Object} e
     */
  }, {
    key: "_onCalendarKeydown",
    value: function _onCalendarKeydown(e) {
      // Verify that this is a calendar day, otherwise exit
      if (!(0, _hasClass.default)(e.target, 'spark-calendar__day')) {
        return;
      }
      var currentMonth;
      if (e.keyCode === 37 || e.keyCode === 38 || e.keyCode === 39 || e.keyCode === 40) {
        currentMonth = (0, _getParent.default)(e.target, '.spark-calendar__month', this.calendarEl);
      }
      if (e.keyCode === 13) {
        this._onCalendarClick(e);
      }

      // Left Arrow
      if (e.keyCode === 37) {
        var prevAvailableDay = (0, _getSiblingBefore.default)(e.target, '.spark-calendar__day:not(.spark-calendar__day--disabled)');
        if (prevAvailableDay !== null) {
          prevAvailableDay.focus();
        } else {
          // Check if we are picking dates from a calendar range
          var prevMonth = currentMonth !== null ? (0, _getSiblingBefore.default)(currentMonth, '.spark-calendar__month') : null;
          if (prevMonth) {
            var prevAvailableDays = (0, _getChildren.default)(prevMonth.querySelector('.spark-calendar__days'), '.spark-calendar__day');
            for (var i = prevAvailableDays.length - 1; i >= 0; i--) {
              if (!(0, _hasClass.default)(prevAvailableDays[i], 'spark-calendar__day--disabled') && !(0, _hasClass.default)(prevAvailableDays[i], 'spark-calendar__day--inactive')) {
                prevAvailableDays[i].focus();
                break;
              }
            }
          }
        }
      }

      // Right Arrow
      if (e.keyCode === 39) {
        var nextAvailableDay = (0, _getSiblingAfter.default)(e.target, '.spark-calendar__day:not(.spark-calendar__day--disabled)');
        if (nextAvailableDay !== null) {
          nextAvailableDay.focus();
        } else {
          // Check if we are picking dates from a calendar range
          var nextMonth = currentMonth !== null ? (0, _getSiblingAfter.default)(currentMonth, '.spark-calendar__month') : null;
          if (nextMonth) {
            var nextAvailableDays = (0, _getChildren.default)(nextMonth.querySelector('.spark-calendar__days'), '.spark-calendar__day');
            for (var _i = 0; _i < nextAvailableDays.length; _i++) {
              if (!(0, _hasClass.default)(nextAvailableDays[_i], 'spark-calendar__day--disabled') && !(0, _hasClass.default)(nextAvailableDays[_i], 'spark-calendar__day--inactive')) {
                nextAvailableDays[_i].focus();
                break;
              }
            }
          }
        }
      }

      // Up Arrow and Down Arrow
      if (e.keyCode === 38 || e.keyCode === 40) {
        var calendarDays = currentMonth.querySelector('.spark-calendar__days');
        var targetIndex = (0, _getIndex.default)(calendarDays.children, e.target);
        var nextIndex = targetIndex;
        var availableDay = null;
        var focusSet = false;
        do {
          if (e.keyCode === 38) {
            nextIndex = nextIndex - 7;
          } else {
            nextIndex = nextIndex + 7;
          }
          availableDay = calendarDays.children.item(nextIndex);
          if (availableDay !== null && !(0, _hasClass.default)(availableDay, 'spark-calendar__day--disabled')) {
            focusSet = true;
            availableDay.focus();
            break;
          }
        } while (availableDay !== null && nextIndex >= 0 && nextIndex < 42);
        if (!focusSet) {
          if (e.keyCode === 38) {
            var _prevMonth = currentMonth !== null ? (0, _getSiblingBefore.default)(currentMonth, '.spark-calendar__month') : null;
            if (_prevMonth !== null) {
              calendarDays = _prevMonth.querySelector('.spark-calendar__days');
              if (nextIndex <= 0) {
                nextIndex = 42 + nextIndex;
              }
              while (nextIndex >= 0 && nextIndex < 42) {
                availableDay = calendarDays.children.item(nextIndex);
                if (availableDay !== null && !(0, _hasClass.default)(availableDay, 'spark-calendar__day--disabled')) {
                  availableDay.focus();
                  break;
                }
                nextIndex = nextIndex - 7;
              }
            }
          } else {
            var _nextMonth = currentMonth !== null ? (0, _getSiblingAfter.default)(currentMonth, '.spark-calendar__month') : null;
            if (_nextMonth !== null) {
              calendarDays = _nextMonth.querySelector('.spark-calendar__days');
              if (nextIndex >= 42) {
                nextIndex = nextIndex - 42;
              }
              while (nextIndex >= 0 && nextIndex < 42) {
                availableDay = calendarDays.children.item(nextIndex);
                if (availableDay !== null && !(0, _hasClass.default)(availableDay, 'spark-calendar__day--disabled')) {
                  availableDay.focus();
                  break;
                }
                nextIndex = nextIndex + 7;
              }
            }
          }
        }
      }
    }

    /**
     * When the calendar is hovered, do some highlighting if we're showing a range.
     * @param {Object} e
     */
  }, {
    key: "_onCalendarMouseOver",
    value: function _onCalendarMouseOver(e) {
      if (this.viewRange === 'month') this._onCalendarMouseOverMonths(e.target);
    }

    /**
     * Set hover states for days.
     * @param  {Element} target
     */
  }, {
    key: "_onCalendarMouseOverMonths",
    value: function _onCalendarMouseOverMonths(target) {
      if (!this._isRange) {
        return;
      }
      var day = (0, _getParent.default)(target, '.spark-calendar__day');
      if (!day) {
        this._updateHoverClasses();
        return;
      }
      var month = (0, _getParent.default)(target, '.spark-calendar__month');
      var mHasClass = function (c) {
        return (0, _hasClass.default)(month, c);
      }.bind(this);
      var newStart = [];
      var newEnd = [];
      var daySel;

      // Only do highlights if we don't already have a value for this index.
      if (!(0, _values.default)(this)[this.activeIndex]) {
        // A month with a value before it but no value of its own, hover starts
        // from the first day to the hovered day.
        if (mHasClass('value-before') && !mHasClass('after-range-end') && !mHasClass('has-value') && !mHasClass('value-after')) {
          newStart.push(month.querySelector('.spark-calendar__day:not(.spark-calendar__day--inactive):not(.spark-calendar__day--disabled)'));
          newEnd.push(day);

          // Add a hover range to a previous month.
          var prevMonth = month;
          while ((prevMonth = (0, _getSiblingBefore.default)(prevMonth, '.spark-calendar__month')) && !(0, _hasClass.default)(prevMonth, 'value-after') && ((0, _hasClass.default)(prevMonth, 'has-value') || (0, _hasClass.default)(prevMonth, 'value-before'))) {
            daySel = prevMonth.querySelectorAll('.spark-calendar__day--selected');
            daySel = daySel[daySel.length - 1];
            daySel = daySel || prevMonth.querySelector('.spark-calendar__day');
            if (daySel) {
              newStart.push(daySel);
              daySel = prevMonth.querySelectorAll('.spark-calendar__day');
              daySel = daySel[daySel.length - 1];
              newEnd.push(daySel);
            }
          }

          // A month with a value, highlight either from the hovered day to
          // the selection or from the selection to the day.
        } else if (mHasClass('has-value') && !mHasClass('value-before') && !mHasClass('value-after') && ((newStart = (0, _getSiblingBefore.default)(day, '.spark-calendar__day--selected')) || (newEnd = (0, _getSiblingAfter.default)(day, '.spark-calendar__day--selected')))) {
          if (newStart) {
            newStart = [newStart];
            newEnd = [day];
          } else {
            newEnd = [newEnd];
            newStart = [day];
          }
          if ((0, _hasClass.default)(newEnd[0], 'spark-calendar__range-start') || (0, _hasClass.default)(newStart[0], 'spark-calendar__range-end')) {
            newStart = [];
            newEnd = [];
          }

          // A month with a middle range should highlight before
        } else if (mHasClass('has-value') && mHasClass('range-middle') && mHasClass('value-before')) {
          daySel = (0, _getSiblingBefore.default)(day, '.spark-calendar__day--selected');
          if (daySel) {
            newStart = [daySel];
            newEnd = [day];
          }
        }
      }
      this._updateHoverClasses(newStart, newEnd);
    }

    /**
     * When the calendar is hovered, undo some highlighting if we're showing a range.
     * @param {Object} e
     */
  }, {
    key: "_onCalendarMouseOut",
    value: function _onCalendarMouseOut(e) {
      if (this.viewRange === 'month') this._onCalendarMouseOutMonths(e.target);
    }

    /**
     * Clear hover states for days.
     * @param  {Element} target
     */
  }, {
    key: "_onCalendarMouseOutMonths",
    value: function _onCalendarMouseOutMonths(target) {
      var day = (0, _getParent.default)(target, '.spark-calendar__day');
      var days = (0, _getParent.default)(target, '.spark-calendar__days');
      var month = (0, _getParent.default)(target, '.spark-calendar__month');
      (0, _removeClass.default)(day, 'hover');
      (0, _removeClass.default)(days, 'hover');
      (0, _removeClass.default)(month, 'hover');
      (0, _removeClass.default)(this.calendarEl, 'hover');
    }

    /**
     * When the calendar is clicked, handle navigation clicks and date selections.
     * @param {Object} e
     */
  }, {
    key: "_onCalendarClick",
    value: function _onCalendarClick(e) {
      var nav = (0, _getParent.default)(e.target, '.spark-calendar__nav', this.calendarEl);
      var today = (0, _getParent.default)(e.target, '.spark-calendar__today', this.calendarEl);
      var day;
      var dir;

      // Navigation clicks
      if (nav) {
        // Previous
        if ((0, _getParent.default)(e.target, '.spark-calendar__previous', nav)) {
          this.previous();

          // Next
        } else if ((0, _getParent.default)(e.target, '.spark-calendar__next', nav)) {
          this.next();
        }

        // Day click
      } else if (day = (0, _getParent.default)(e.target, '.spark-calendar__day')) {
        e.preventDefault();
        e.stopPropagation();

        // Disabled day moves can move us to the next month
        if ((0, _hasClass.default)(day, 'spark-calendar__day--disabled')) {
          dir = day.getAttribute('data-direction');
          if (dir === 'next') this.next();else if (dir === 'previous') this.previous();

          // Enabled day sets the value
        } else {
          e.target.setAttribute('tabindex', 0);
          var beforeDate = null;
          var afterDate = null;
          if (this.activeIndex !== null && this.userFocusedIndex === null) {
            beforeDate = new Date(this.inputEls[this.activeIndex].value) > new Date(day.getAttribute('data-date'));
            if (this.inputEls[this.activeIndex + 1]) {
              afterDate = new Date(this.inputEls[this.activeIndex + 1].value) < new Date(day.getAttribute('data-date'));
            }
            if (beforeDate && new Date(this.inputEls[0].value) > new Date(day.getAttribute('data-date'))) {
              this.activeIndex = 0;
            } else if (afterDate) {
              this.activeIndex = this.activeIndex + 1;
            }
          }
          this.setValue(day.getAttribute('data-date'), this.activeIndex);
          if (this.activeIndex < this.els.length - 1) {
            this.activeIndex = this.activeIndex + 1;
          } else {
            this.activeIndex = this.activeIndex - 1 > 0 ? this.activeIndex - 1 : 0;
          }
          this.userFocusedIndex = null;
        }

        // Today button
      } else if (today) {
        e.preventDefault();
        e.stopPropagation();
        this.setValue(parsedDomFormat.getString(_date.default.now()), this.activeIndex);
        if (this.activeIndex < this.els.length - 1) {
          this.activeIndex = this.activeIndex + 1;
        } else {
          this.activeIndex = this.activeIndex - 1 > 0 ? this.activeIndex - 1 : 0;
        }
        this.userFocusedIndex = null;
      }
    }

    /**
     * When the input that corresponds to this instance changes. Allows us to listen
     * and respond to changes made by other components (Calendar, for example).
     * @param {Object} e
     */
  }, {
    key: "_onInputChange",
    value: function _onInputChange(e) {
      var index = this.inputEls.indexOf(e.target);
      if (this._inputsChanging && this._inputsChanging.indexOf(index) !== -1) return;
      this.setValue(e.target.value, index);
    }

    /**
     * When one of the calendar quick jump select inputs changes.
     * We have to set the value of the select input back to its original
     * value or else it will be out of sync when the currently active
     * month is shown again.
     * @param {Object} e
     */
  }, {
    key: "_onSelectChange",
    value: function _onSelectChange(e) {
      if (!this._datesToShow[this.activeIndex]) {
        this.activeIndex = 0;
      }
      var name = e.target.name;
      var val = e.target.value;
      var curVal = this._datesToShow[this.activeIndex][name];
      var obj = {};
      obj[name] = val;
      this.showDate(obj);
      e.target.value = curVal;
    }

    /**
     * When the window resizes, determine how many calendars we can show
     * @param {Object} e
     */
  }, {
    key: "_onResize",
    value: function _onResize() {
      this._checkSize();
    }
  }]);
  return CalendarInline;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
CalendarInline.prototype._whitelistedParams = ['els', 'visibleCounts', 'mins', 'maxes', 'values', 'daysDisabled', 'daysInfo', 'calendarEl', 'viewRange', 'animate', 'animationDuration', 'showOnFocus', 'onChange', 'showTodayButton', 'todayButtonLabel', 'ariaSelectedLabel', 'ariaStartDateLabel', 'ariaEndDateLabel'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
CalendarInline.prototype.defaults = {
  els: null,
  inputEls: null,
  calendarEl: null,
  calendarContentEl: null,
  calendarOverflowEl: null,
  visibleCounts: null,
  activeIndex: null,
  mins: null,
  minVisible: null,
  maxes: null,
  maxVisible: null,
  values: null,
  daysDisabled: null,
  daysInfo: null,
  viewRange: null,
  showTodayButton: null,
  todayButtonLabel: null,
  ariaSelectedLabel: 'Selected.',
  ariaStartDateLabel: 'Selected as start date.',
  ariaEndDateLabel: 'Selected as end date.',
  nextButtonEl: null,
  previousButtonEl: null,
  animate: null,
  animationDuration: null,
  showOnFocus: null,
  onChange: null,
  _isDisabled: false,
  _isRange: null,
  _hoverStarts: null,
  _hoverEnds: null,
  _currentBreakpoint: null,
  _animationQueue: null,
  _currentContent: null,
  _datesToShow: null,
  _monthsShowing: null,
  _atMin: false,
  _atMax: false,
  _inputsChanging: false,
  _renderCache: null,
  _onClickBound: null,
  _onKeydownBound: null,
  _onCalendarMouseOverBound: null,
  _onCalendarMouseOutBound: null,
  _onCalendarClickBound: null,
  _onCalendarKeydownBound: null,
  _onSelectChangeBound: null,
  _onInputChangeBound: null,
  _onResizeBound: null
};
var _default = CalendarInline;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/animation/scroll-to":54,"../helpers/date/date":57,"../helpers/date/parse-format":58,"../helpers/dom/add-class":59,"../helpers/dom/breakpoint":60,"../helpers/dom/has-class":61,"../helpers/dom/outer-width":65,"../helpers/dom/parse-attribute":66,"../helpers/dom/remove-class":67,"../helpers/dom/trigger-event":69,"../helpers/manipulation/append-children":73,"../helpers/traversal/get-children":85,"../helpers/traversal/get-index":86,"../helpers/traversal/get-parent":87,"../helpers/traversal/get-sibling-after":89,"../helpers/traversal/get-sibling-before":90,"../helpers/util/debounce":93,"./base":3,"@babel/runtime-corejs3/core-js-stable/instance/concat":108,"@babel/runtime-corejs3/core-js-stable/instance/map":113,"@babel/runtime-corejs3/core-js-stable/instance/slice":115,"@babel/runtime-corejs3/core-js-stable/instance/splice":117,"@babel/runtime-corejs3/core-js-stable/instance/values":119,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/assertThisInitialized":143,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155,"@babel/runtime-corejs3/helpers/typeof":162}],6:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/assertThisInitialized"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/values"));
var _splice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/splice"));
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));
var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));
var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));
var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));
var _base = _interopRequireDefault(require("./base"));
var _popover = _interopRequireDefault(require("./popover"));
var _parseFormat = _interopRequireDefault(require("../helpers/date/parse-format"));
var _date = _interopRequireDefault(require("../helpers/date/date"));
var _buildSelect = _interopRequireDefault(require("../helpers/form/build-select"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _appendChildren = _interopRequireDefault(require("../helpers/manipulation/append-children"));
var _getParent = _interopRequireDefault(require("../helpers/traversal/get-parent"));
var _triggerEvent = _interopRequireDefault(require("../helpers/dom/trigger-event"));
var _breakpoint = require("../helpers/dom/breakpoint");
var _scrollTo = _interopRequireDefault(require("../helpers/animation/scroll-to"));
var _getSiblingBefore = _interopRequireDefault(require("../helpers/traversal/get-sibling-before"));
var _getSiblingAfter = _interopRequireDefault(require("../helpers/traversal/get-sibling-after"));
var _getChildren = _interopRequireDefault(require("../helpers/traversal/get-children"));
var _getIndex = _interopRequireDefault(require("../helpers/traversal/get-index"));
var _range = _interopRequireDefault(require("../helpers/util/range"));
var _debounce = _interopRequireDefault(require("../helpers/util/debounce"));
var _parseAttribute = require("../helpers/dom/parse-attribute");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Calendar Popover
                                                                                                                                                                                                                                                                                                                                              * Create a calendar from which dates can be selected.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new CalendarPopover(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/calendar-popover.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var domDateFormat = 'YYYY-MM-DD';
var parsedDomFormat = (0, _parseFormat.default)(domDateFormat);
function createDefaultElement() {
  var el = document.createElement('span');
  el.className = 'spark-input spark-date';
  el.innerHTML = '<input class="spark-input__field" type="date"><span class="spark-label"></span>';
  return el;
}

/**
 * Parse the proper params for initialization
 * @param  {Element} el
 * @param  {Object} params
 * @return {Objec}
 */
function parseInitParams(el, params) {
  // If the first element is an array or array-like (NodeList),
  // we will be working with a range.
  if (el && el.hasOwnProperty('length')) {
    params.els = el;

    // If the first argument is a plain object, create a default element
    // since the user MUST provide additional params but the element
    // is optional. Doing it this way to keep the arity the same
    // as other components.
  } else if (!(el instanceof HTMLElement)) {
    params = el || {};
    params.els = [createDefaultElement()];

    // A single element is passed.
  } else {
    params.els = [el];
  }
  params.visibleCounts = params.visibleCounts || (params.visibleCount ? [params.visibleCount] : null);
  params.mins = params.mins || (params.min ? [params.min] : []);
  params.maxes = params.maxes || (params.max ? [params.max] : []);
  params.values = (0, _values.default)(params) || (params.value ? [params.value] : []);
  return params;
}
var CalendarPopover = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(CalendarPopover, _BaseComponent);
  var _super = _createSuper(CalendarPopover);
  /**
   * Calendar Popover constructor
   * @param {Element} el Optional
   * @param {Object} params Optional
   */
  function CalendarPopover(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, CalendarPopover);
    params = parseInitParams(el, params);
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }

    // Create a calendar element if we weren't passed one.
    (_this.calendarEl ? noop : _this._createCalendar).call((0, _assertThisInitialized2.default)(_this));
    _this.calendarEl.setAttribute('aria-modal', 'true');
    _this.calendarEl.setAttribute('role', 'dialog');
    _this._cacheCalendarElements();
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    _this._initDatesToShow();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Update the component to use a new element or reparse from
   * the existing element.
   * @param {Element} el Optional
   */
  (0, _createClass2.default)(CalendarPopover, [{
    key: "update",
    value: function update(el) {
      if (el) {
        this._removeEventListeners();
        this.els = el instanceof Array ? el : [el];
        this._cacheElements();
        this._addEventListeners();
      }
      this._parseInputElsParams();
      this._initDatesToShow();
      if (this.activeIndex !== null) {
        this.render();
        this._checkSize();
      }
      return this;
    }

    /**
     * Open the calendar widget.
     * @param {Number} index Optional The index of the element to tie actions to
     * @param {Object} params Optional
     */
  }, {
    key: "open",
    value: function open() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (this._isDisabled[index]) {
        return this;
      }
      this._unfillToggle();

      // Allow for only params to be passed
      if ((0, _typeof2.default)(index) === 'object') {
        params = index;
        index = 0;
      }

      // Already open
      if (this.activeIndex === index) {
        return this;
      }

      // We have an already active item, close it
      if (this.activeIndex !== null) {
        this._deactivateElement(this.activeIndex);
      }

      // Clear any timers which may be running to close or open this
      clearTimeout(this._openCloseTimer);

      // Set the new index
      this.activeIndex = index;

      // If we don't have a popover yet, create it.
      if (!this.popover) {
        this._createPopover();
      }

      // Get the list of dates to show for this view.
      this._initDatesToShow();

      // Ensure the cached values are in line with the input values.
      this.updateValues();

      // Create a calendar or calendars inside the popover
      this.render({
        clearCache: true
      });

      // Finally, show the popover after a delay or on the next tick.
      this._openCloseTimer = setTimeout(function () {
        this.popover.open({
          affixTo: this.els[index].querySelector('.spark-date__calendar-toggle')
        });
      }.bind(this), params.delay || 0);

      // Activate the corresponding element
      this._activateElement(index);
      return this;
    }

    /**
     * Close the calendar widget.
     * @param {Object} params
     */
  }, {
    key: "close",
    value: function close(params) {
      this._unfillToggle();
      params = params || {};

      // Can't close if we aren't or haven't yet opened.
      if (this.activeIndex === null || !this.popover) {
        return this;
      }

      // Deactive the corresponding element
      this._deactivateElement(this.activeIndex);

      // Clear any existing close or open events which are queued
      clearTimeout(this._openCloseTimer);

      // Close after a delay, or on the next tick
      this.activeIndex = null;
      this._openCloseTimer = setTimeout(function () {
        this.popover.close();
      }.bind(this), params.delay || 0);
    }

    /**
     * Get the value.
     * @param {Number|Element} index Optional
     * @return {Mixed}
     */
  }, {
    key: "getValue",
    value: function getValue(index) {
      return (0, _values.default)(this)[index || 0];
    }

    /**
     * Set the date for a given element.
     * @param {String|Object} value
     * @param {Number|Element} index
     * @param {Boolean} skipRangeCheck Optional Don't check for sequential range values.
     */
  }, {
    key: "setValue",
    value: function setValue(value, index, skipRangeCheck) {
      var obj = (0, _typeof2.default)(value) === 'object' ? value : parsedDomFormat.getValues(value);
      var el;

      // If we are passed an element instead of an index, use that.
      if (index instanceof HTMLElement) {
        el = index;
        index = this.inputEls.indexOf(el);

        // Otherwise, find the element in our list.
      } else {
        index = index || 0;
        el = this.inputEls[index];
      }

      // Update the stored value
      (0, _values.default)(this)[index] = obj;

      // If we are working with a range, make sure that the values are in order.
      if (value) {
        this._checkValues(index, skipRangeCheck);
      }

      // Set the value on the input element. Make sure we don't get into an infinite
      // loop since we listen to the change event on the input. We have to trigger it
      // so that other components listening to it get the update.
      el.value = value && obj === value ? parsedDomFormat.getString(value) : value || '';
      this._inputsChanging = this._inputsChanging || [];
      if (this._inputsChanging.indexOf(index) === -1) {
        var _context;
        this._inputsChanging.push(index);
        (0, _triggerEvent.default)(el, 'change');
        (this.onChange || noop)(el, el.value, this);
        var pos = this._inputsChanging.indexOf(index);
        (0, _splice.default)(_context = this._inputsChanging).call(_context, pos, 1);
      }
      this.render({
        clearCache: true
      });
      return this;
    }

    /**
     * Clear the selected values.
     */
  }, {
    key: "clearValues",
    value: function clearValues() {
      var els = this.inputEls;
      var i = 0;
      var len = els.length;
      for (; i < len; i++) {
        this.clearValue(i);
      }
      return this;
    }

    /**
     * Clear the selected value.
     * @param {Number} index
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.values = (0, _values.default)(this) || [];
      if (!this.inputEls[index]) throw new Error("Cannot clear value at index ".concat(index, ". No input element exists with that index!"));
      (0, _values.default)(this)[index] = this.inputEls[index].value = null;
      return this;
    }

    /**
     * Take the date values from the inputs and set them as dates on the calendar.
     */
  }, {
    key: "updateValues",
    value: function updateValues() {
      var els = this.inputEls;
      var i = 0;
      var len = els.length;
      for (; i < len; i++) {
        this.updateValue(i);
      }
      return this;
    }

    /**
     * Take the date values from the inputs and set them as dates on the calendar.
     * @param {Number} index
     */
  }, {
    key: "updateValue",
    value: function updateValue() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.values = (0, _values.default)(this) || [];
      if (!this.inputEls[index]) throw new Error("Cannot update value at index ".concat(index, ". No input element exists with that index!"));
      (0, _values.default)(this)[index] = this.inputEls[index].value ? parsedDomFormat.getValues(this.inputEls[index].value) : null;
      return this;
    }

    /**
     * Disable the calendar functionality.
     * @param {Number} index
     */
  }, {
    key: "disable",
    value: function disable(index) {
      var i = index || 0;
      var len = index !== undefined ? index + 1 : this.els.length;
      var toggle;
      for (; i < len; i++) {
        this._isDisabled[i] = true;
        this.els[i].setAttribute('disabled', '');
        toggle = this.els[i].querySelector('.spark-date__calendar-toggle');
        if (toggle) toggle.setAttribute('disabled', '');
      }
      this.close();
      return this;
    }

    /**
     * Enable the calendar functionality.
     * @param {Number} index
     */
  }, {
    key: "enable",
    value: function enable(index) {
      var i = index || 0;
      var len = index !== undefined ? index + 1 : this.els.length;
      var toggle;
      for (; i < len; i++) {
        this._isDisabled[i] = false;
        this.els[i].removeAttribute('disabled', '');
        toggle = this.els[i].querySelector('.spark-date__calendar-toggle');
        if (toggle) toggle.removeAttribute('disabled');
      }
      return this;
    }

    /**
     * Render the calendar or calendars into the popover.
     * @param {Object} params
     */
  }, {
    key: "render",
    value: function render(params) {
      params = params || {};

      // If we don't have a popover yet, create it.
      if (!this.popover) {
        this._createPopover();
      }
      var content;

      // Clear the cache so that we don't show out-of-date values.
      if (params.clearCache) {
        this._renderCache = {};
      }

      // Create the visible days, weeks, months or years
      if (this.viewRange === 'year') content = this._renderYears();else if (this.viewRange === 'week') content = this._renderWeeks();else if (this.viewRange === 'day') content = this._renderDays();else content = this._renderMonths();
      this._insertContent(content, params);

      // Update attributes
      this._updateAttributes();
      return this;
    }

    /**
     * Cleans up event listeners and removes helpers.
     * @param {Boolean} leaveElement Leave the element intact.
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      this.popover && this.popover.remove();
      return (0, _get2.default)((0, _getPrototypeOf2.default)(CalendarPopover.prototype), "remove", this).call(this, leaveElement);
    }

    /**
     * Move to the next set of dates.
     */
  }, {
    key: "next",
    value: function next() {
      if (this._atMax) return this;
      this._setDatesToShow(1);
      this.render({
        append: 1
      });
      return this;
    }

    /**
     * Move to the previous set of dates.
     */
  }, {
    key: "previous",
    value: function previous() {
      if (this._atMin) return this;
      this._setDatesToShow(-1);
      this.render({
        prepend: 1
      });
      return this;
    }

    /**
     * Show a specific date on the calendar.
     * @param {Object} params
     */
  }, {
    key: "showDate",
    value: function showDate(params) {
      var _context2;
      // Open if we're closed.
      if (this.activeIndex === null) {
        this.open();
      }
      var month = params.month || null;
      var year = params.year || null;
      var day = params.day || null;

      // Nothing to do.
      if (!month && !year && !day) {
        return this;
      }
      var showing = this._datesToShow[this.activeIndex].clone();
      var noun = this.viewRange.charAt(0).toUpperCase() + (0, _slice.default)(_context2 = this.viewRange).call(_context2, 1);

      // Only change the values we were given
      if (year) {
        showing.year = year;
      }
      if (month) {
        showing.month = month;
      }
      if (day) {
        showing.day = day;
      }

      // Check min
      var min = this.mins[this.activeIndex];
      if (min && showing['before' + noun](min)) {
        showing = min.clone();
      }

      // Check max
      var max = this.maxes[this.activeIndex];
      if (max && showing['after' + noun](max)) {
        showing = max.clone();
      }
      this._datesToShow[this.activeIndex] = showing;

      // Populate the rest of the dates
      this._setDatesToShow();
      return this.render();
    }

    /**
     * Render the appropriate number of years.
     * @return {Array}
     */
  }, {
    key: "_renderYears",
    value: function _renderYears() {
      throw new Error('Displaying years in the calendar is not yet supported!');
    }

    /**
     * Render the appropriate number of weeks.
     * @return {Array}
     */
  }, {
    key: "_renderWeeks",
    value: function _renderWeeks() {
      throw new Error('Displaying weeks in the calendar is not yet supported!');
    }

    /**
     * Render the appropriate number of days.
     * @return {Array}
     */
  }, {
    key: "_renderDays",
    value: function _renderDays() {
      throw new Error('Displaying days in the calendar is not yet supported!');
    }

    /**
     * Render the appropriate number of months.
     * @return {Array}
     */
  }, {
    key: "_renderMonths",
    value: function _renderMonths() {
      var months = [];
      var i = 0;
      var len = this._datesToShow.length;
      var current = _date.default.now();
      for (; i < len; i++) {
        months.push(this._renderMonth(this._datesToShow[i], current));
      }
      return months;
    }

    /**
     * Render a month.
     * @param {Object} date
     * @param {Object} current
     * @return {Element}
     */
  }, {
    key: "_renderMonth",
    value: function _renderMonth(date, current) {
      // A unique key for this month used for caching
      var key = date.year + '-' + date.month;

      // Ensure we have a cache
      this._renderCache = this._renderCache || {};

      // Return a cached instance
      if (this._renderCache[key]) {
        return this._renderCache[key];
      }

      // Create the element
      var el = document.createElement('div');
      var html = '';
      el.className = 'spark-calendar__month ' + this._getMonthClassNames(date);

      // Add the title or dropdowns.
      html += '<div class="spark-calendar__month-title">';
      if (this.quickJump && this.visibleCounts[this.activeIndex] === 1) {
        html += this._renderMonthQuickJump(date);
      } else {
        html += '<span>' + date.monthName + ' ' + date.year + '</span>';
      }
      html += '</div>';

      // Add the days of the week headings
      html += this._renderMonthDaysOfWeek();

      // Add the days
      html += this._renderMonthDays(date, current);
      el.innerHTML = html;

      // Store in the cache and return
      return this._renderCache[key] = el;
    }

    /**
     * Render the select inputs used for jumping ahead/backward several months.
     * @param {Object} date
     */
  }, {
    key: "_renderMonthQuickJump",
    value: function _renderMonthQuickJump(date) {
      var _context3, _context4;
      var el = document.createElement('div');
      var years;
      var months;

      // Min and max year to show
      var min = this.mins[this.activeIndex] ? this.mins[this.activeIndex].clone() : null;
      var max = this.maxes[this.activeIndex] ? this.maxes[this.activeIndex].clone() : null;
      var quickJumpRange = typeof this.quickJumpRange === 'number' && this.quickJumpRange % 1 === 0 ? this.quickJumpRange : 50;

      // No min, go 50 years back
      if (!min) {
        min = date.clone();
        min.year = min.year - quickJumpRange;
      }

      // No max, go 50 years forward
      if (!max) {
        max = date.clone();
        max.year = max.year + quickJumpRange;
      }

      // Get the months to show.
      var monthOpts = (0, _filter.default)(_context3 = (0, _map.default)(_context4 = _date.default.getMonthNames()).call(_context4, function (val, i) {
        // Don't show a month that is out of the valid range.
        if (min.year === max.year && (i + 1 < min.month || i + 1 > max.month)) {
          return null;
        }
        return {
          value: i + 1,
          text: val
        };
      })).call(_context3, function (i) {
        return i;
      });

      // Min and max are the same month, so just show text.
      if (!monthOpts.length || monthOpts.length === 1) {
        months = document.createElement('span');
        months.innerHTML = date.monthName + ' ';
      } else {
        // Build a select list of months
        months = document.createElement('label');
        (0, _addClass.default)(months, 'spark-select spark-calendar__select');
        months.appendChild((0, _buildSelect.default)({
          selected: date.month,
          attributes: {
            class: 'spark-select__input',
            name: 'month'
          },
          options: monthOpts
        }));
      }

      // Min and max year are the same, so just show text.
      if (min.year === max.year) {
        years = document.createElement('span');
        years.innerHTML = date.year;
      } else {
        // Build a select list of years
        years = document.createElement('label');
        (0, _addClass.default)(years, 'spark-select spark-calendar__select');
        years.appendChild((0, _buildSelect.default)({
          selected: date.year,
          attributes: {
            class: 'spark-select__input',
            name: 'year'
          },
          options: (0, _range.default)(max.year, min.year - 1)
        }));
      }
      (0, _appendChildren.default)(el, [months, years]);
      return el.innerHTML;
    }

    /**
     * Render the days of week row for a month calendar.
     * @return {String}
     */
  }, {
    key: "_renderMonthDaysOfWeek",
    value: function _renderMonthDaysOfWeek() {
      var daysOfWeek = _date.default.getDayNames();
      var i = 0;
      var len = daysOfWeek.length;
      var str = '<div class="spark-calendar__days-of-week">';
      for (; i < len; i++) {
        str += '<span class="spark-calendar__day-of-week">' + daysOfWeek[i][0] + '</span>';
      }
      return str += '</div>';
    }

    /**
     * Render the days of week row for a month calendar.
     * @param {Object} date
     * @param {Object} current
     * @return {String}
     */
  }, {
    key: "_renderMonthDays",
    value: function _renderMonthDays(date, current) {
      var dayOfWeek = date.monthStart.dayOfWeek;
      var startOfWeek = dayOfWeek > 1 ? date.monthStart.weekStart : null;
      var monthEnd = date.monthEnd;
      var weeks = 6;
      var i = 0;
      var j = 0;
      var str = '<div class="spark-calendar__days">';
      var day = 0;
      var month = startOfWeek ? startOfWeek.month : date.month;
      var year = startOfWeek ? startOfWeek.year : date.year;
      var isCurrentMonth = current.year === date.year && current.month === date.month;

      // If we have days that come before the first of the month, the days will start as
      // inactive. We use a 1 here to indicate the date is inactive and _before_
      // the start of the month.
      var inactive = startOfWeek ? 1 : null;
      for (; i < weeks; i++) {
        for (; j < 7; j++) {
          day = startOfWeek ? startOfWeek.day + j : day + 1;
          str += this._renderMonthDay(day, month, year, isCurrentMonth, current, inactive);
          if (startOfWeek && j + 1 >= dayOfWeek - 1) {
            startOfWeek = null;
            inactive = null;
            day = 0;
            month = date.month;
            year = date.year;
            isCurrentMonth = current.year === date.year && current.month === date.month;
          } else if (day >= monthEnd.day && i > 0) {
            // Inactive days that come _after_ the last of the month are denoted with a 2.
            // _renderMonthDay handles 1s and 2s differently, but both add the inactive class.
            inactive = 2;
            isCurrentMonth = false;
            day = 0;
            month++;
            if (month > 12) {
              year++;
              month = 1;
            }
          }
        }
        j = 0;
      }
      return str += '</div>';
    }

    /**
     * Render a day of the month.
     * @param {Number} day
     * @param {Number} month
     * @param {Number} year
     * @param {Boolean} isCurrentMonth
     * @param {Object} current
     * @param {Boolean} inactive
     */
  }, {
    key: "_renderMonthDay",
    value: function _renderMonthDay(day, month, year, isCurrentMonth, current, inactive) {
      var date = _date.default.create({
        year: year,
        month: month,
        day: day
      });
      var str = '<a';
      var disabled = inactive || this._isDayDisabled(date);
      str += ' aria-label="' + date.dayName + ' ' + day + ' ' + date.monthName + ' ' + year + '"';
      str += !disabled ? ' data-date="' + parsedDomFormat.getString(date) + '"' : '';
      str += inactive ? ' data-direction="' + (inactive === 2 ? 'next' : 'previous') + '"' : '';
      str += disabled ? ' tabindex="-1" aria-hidden="true"' : '';
      str += ' class="spark-calendar__day';
      str += isCurrentMonth && current.day === day && current.month === month && current.year === year ? ' spark-calendar__day--today' : '';
      str += inactive ? ' spark-calendar__day--inactive' : '';
      str += disabled ? ' spark-calendar__day--disabled' : '';
      str += this._isDaySelected(date) ? ' spark-calendar__day--selected' : '';
      str += this._isDayRangeStart(date) ? ' spark-calendar__range-start' : '';
      str += this._isDayRangeMiddle(date) ? ' spark-calendar__range-middle' : '';
      str += this._isDayRangeEnd(date) ? ' spark-calendar__range-end' : '';
      str += this._isDayRangeLast(date) ? ' spark-calendar__range-last' : '';
      str += '"';
      str += ' href="#"><span class="spark-calendar__day--number">';
      str += day;
      str += this._getDayInfo(date);
      str += '</span></a>';
      return str;
    }

    /**
     * Render the children into the content.
     * @param {Array} content
     */
  }, {
    key: "_insertContent",
    value: function _insertContent(content, params) {
      this._currentContent = this._currentContent || [];
      params = params || {};
      var keep;
      var i = 0;
      var len;

      // If we've been asked to prepend or append, add the new elements in front,
      // save the number of old elements we're sliding out, animate,
      // then clean up.
      if (this.animate) {
        if (params.prepend) {
          var _context5;
          // Get the last elements to keep
          keep = (0, _slice.default)(_context5 = this._currentContent).call(_context5, -params.prepend);
          len = keep.length;
          for (; i < len; i++) {
            content.push(keep[i]);
          }
          this.calendarEl.setAttribute('data-prepend-count', len);
          this._animateContent(function () {
            this.calendarEl.removeAttribute('data-prepend-count');
            this._animateContent(function () {
              content = (0, _slice.default)(content).call(content, 0, -params.prepend);
              this._insertContent(content);
            }, this.animationDuration);
          }, 10);

          // Same but appending
        } else if (params.append) {
          var _context6;
          // Get the first elements to keep
          keep = (0, _slice.default)(_context6 = this._currentContent).call(_context6, 0, params.append);
          len = keep.length;
          for (; i < len; i++) {
            content.unshift(keep[i]);
          }
          this.calendarEl.setAttribute('data-append-count', len);
          this._animateContent(function () {
            (0, _addClass.default)(this.calendarEl, 'no-animate');
            content = (0, _slice.default)(content).call(content, params.append);
            this._insertContent(content);
            this.calendarEl.removeAttribute('data-append-count');
            this._animateContent(function () {
              (0, _removeClass.default)(this.calendarEl, 'no-animate');
            }, 10);
          }, this.animationDuration);
        }
      }
      (0, _appendChildren.default)(this.calendarContentEl, this._currentContent = content, true);
    }

    /**
     * Is a given day selected?
     * @param {Object} date
     * @return {Boolean}
     */
  }, {
    key: "_isDaySelected",
    value: function _isDaySelected(date) {
      return (0, _values.default)(this) && date.equal((0, _values.default)(this));
    }

    /**
     * Is a given day the start of a range?
     * @param {Object} date
     * @return {Boolean}
     */
  }, {
    key: "_isDayRangeStart",
    value: function _isDayRangeStart(date) {
      return this.inputEls.length > 1 && (0, _values.default)(this) && date.equal((0, _values.default)(this)[0]);
    }

    /**
     * Is a given day the middle of a range?
     * @param {Object} date
     * @return {Boolean}
     */
  }, {
    key: "_isDayRangeMiddle",
    value: function _isDayRangeMiddle(date) {
      var _context7;
      return this.inputEls.length > 1 && (0, _values.default)(this) && (0, _values.default)(this).length > 1 && date.equal((0, _slice.default)(_context7 = (0, _values.default)(this)).call(_context7, 1, -1));
    }

    /**
     * Is a given day the end of a range?
     * @param {Object} date
     * @return {Boolean}
     */
  }, {
    key: "_isDayRangeEnd",
    value: function _isDayRangeEnd(date) {
      return this.inputEls.length > 1 && (0, _values.default)(this) && (0, _values.default)(this).length > 1 && date.equal((0, _values.default)(this)[(0, _values.default)(this).length - 1]);
    }

    /**
     * Is a given day currently the last
     * @param {Object} date
     * @return {Boolean}
     */
  }, {
    key: "_isDayRangeLast",
    value: function _isDayRangeLast(date) {
      var i = (0, _values.default)(this).length - 1;
      for (; i > 0; i--) {
        // We have a value and it's not the same as the date.
        if ((0, _values.default)(this)[i]) {
          if (!date.equal((0, _values.default)(this)[i])) {
            return false;
          }
          break;
        }
      }
      return true;
    }

    /**
     * Is a given day disabled?
     * @param {Object} date
     * @return {Boolean}
     */
  }, {
    key: "_isDayDisabled",
    value: function _isDayDisabled(date) {
      return this.daysDisabled && this.daysDisabled[date.year] && this.daysDisabled[date.year][date.month] && this.daysDisabled[date.year][date.month].indexOf(date.day) !== -1 || this.mins[this.activeIndex] && date.before(this.mins[this.activeIndex], true) || this.maxes[this.activeIndex] && date.after(this.maxes[this.activeIndex], true);
    }

    /**
     * Get any "info" for a given day.
     * @param {Object} date
     * @return {String}
     */
  }, {
    key: "_getDayInfo",
    value: function _getDayInfo(date) {
      return this.daysInfo && this.daysInfo[date.year] && this.daysInfo[date.year][date.month] && this.daysInfo[date.year][date.month][date.day] ? '<span class="spark-calendar__day-note">' + this.daysInfo[date.year][date.month][date.day] + '</span>' : '';
    }

    /**
     * Get the class names for a month.
     * @param {Object} date
     * @return {String}
     */
  }, {
    key: "_getMonthClassNames",
    value: function _getMonthClassNames(date) {
      var cls = [];

      // Do we have a value in this month?
      if (date.equalMonth((0, _values.default)(this))) {
        cls.push('has-value');
      }

      // Does this month have the start, middle or end of a range?
      if (this._isRange && this.els.length > 1) {
        var _context8;
        var start = date.equalMonth((0, _values.default)(this)[0]);
        var end = date.equalMonth((0, _values.default)(this)[(0, _values.default)(this).length - 1]);
        var middle = date.equalMonth((0, _slice.default)(_context8 = (0, _values.default)(this)).call(_context8, 1, -1));
        var valBefore = date.afterMonth((0, _values.default)(this));
        var valAfter = date.beforeMonth((0, _values.default)(this));
        var afterEnd = (0, _values.default)(this)[(0, _values.default)(this).length - 1] && date.after((0, _values.default)(this)[(0, _values.default)(this).length - 1]);
        if (start) {
          cls.push('range-start');
        }
        if (end) {
          cls.push('range-end');
        }
        if (middle) {
          cls.push('range-middle');
        }
        if (valBefore) {
          cls.push('value-before');
        }
        if (valAfter) {
          cls.push('value-after');
        }
        if (afterEnd) {
          cls.push('after-range-end');
        }
      }
      return cls.join(' ');
    }

    /**
     * Create the calendar.
     */
  }, {
    key: "_createCalendar",
    value: function _createCalendar() {
      var el = document.createElement('div');
      (0, _addClass.default)(el, 'spark-calendar');
      if (this.showTodayButton) {
        var todayButtonStr = '<button type="button" class="spark-calendar__today spark-btn spark-btn--text">' + this.todayButtonLabel + '</button>';
        el.innerHTML = '<nav class="spark-calendar__nav"><button class="spark-calendar__previous spark-icon-chevron-left" aria-label="Previous month"></button><button class="spark-calendar__next spark-icon-chevron-right" aria-label="Next month"></button></nav><div class="spark-calendar__overflow spark-calendar__overflow--has-footer"><div class="spark-calendar__content"></div><div class="spark-calendar__footer">' + todayButtonStr + '</div></div>';
      } else {
        el.innerHTML = '<nav class="spark-calendar__nav"><button class="spark-calendar__previous spark-icon-chevron-left" aria-label="Previous month"></button><button class="spark-calendar__next spark-icon-chevron-right" aria-label="Next month"></button></nav><div class="spark-calendar__overflow"><div class="spark-calendar__content"></div></div>';
      }
      this.calendarEl = el;
      this.calendarContentEl = el.querySelector('.spark-calendar__content');
      this.calendarOverflowEl = el.querySelector('.spark-calendar_overflow');
    }

    /**
     * Create the popover.
     */
  }, {
    key: "_createPopover",
    value: function _createPopover() {
      this.popover = new _popover.default(document.createElement('div'), {
        anchorX: this.anchorX,
        anchorY: this.anchorY,
        contentEl: this.calendarEl,
        onClose: this._onPopoverClose.bind(this),
        onOpen: this._onPopoverOpen.bind(this)
      });
    }

    /**
     * Cache elements.
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements() {
      this.inputEls = [];
      var i = 0;
      var len = this.els.length;
      var input;
      for (; i < len; i++) {
        input = this.els[i].nodeName.toLowerCase() === 'input' ? this.els[i] : this.els[i].querySelector('input[type="date"]');
        this.inputEls[i] = input;
      }
    }

    /**
     * Cache elements specific to the calendar.
     */
  }, {
    key: "_cacheCalendarElements",
    value: function _cacheCalendarElements() {
      this.nextButtonEl = this.calendarEl.querySelector('.spark-calendar__next');
      this.previousButtonEl = this.calendarEl.querySelector('.spark-calendar__previous');
    }

    /**
     * Parse parameters from the elements.
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      this._parseInputElsParams();
      this._isRange = this.els.length > 1 ? true : false;
      this.autoAdvance = this.autoAdvance !== null ? this.autoAdvance : (0, _parseAttribute.boolean)(this.els[0], 'data-auto-advance', true);
      this.autoClose = this.autoClose !== null ? this.autoClose : (0, _parseAttribute.boolean)(this.els[0], 'data-auto-close', true);
      this.closeDelay = this.closeDelay !== null ? this.closeDelay : (0, _parseAttribute.number)(this.els[0], 'data-close-delay', 500);
      this.quickJump = this.quickJump !== null ? this.quickJump : (0, _parseAttribute.boolean)(this.els[0], 'data-quick-jump', false);
      this.viewRange = this.viewRange !== null ? this.viewRange : (0, _parseAttribute.string)(this.els[0], 'data-view-range', 'month');
      this.animate = this.animate !== null ? this.animate : (0, _parseAttribute.boolean)(this.els[0], 'data-animate', true);
      this.animationDuration = this.animationDuration !== null ? this.animationDuration : (0, _parseAttribute.number)(this.els[0], 'data-animation-duration', 100);
      this.showOnFocus = this.showOnFocus !== null ? this.showOnFocus : (0, _parseAttribute.boolean)(this.els[0], 'data-show-on-focus', false);
      this.showTodayButton = this.showTodayButton !== null ? this.showTodayButton : (0, _parseAttribute.boolean)(this.els[0], 'data-show-today-button', false);
      this.todayButtonLabel = this.todayButtonLabel !== null ? this.todayButtonLabel : (0, _parseAttribute.string)(this.els[0], 'data-today-button-label', 'Select Today');

      // Calendar Popover anchors
      this.anchorY = this.anchorY !== null ? this.anchorY : 'bottom';
      this.anchorX = this.anchorX !== null ? this.anchorX : 'center';
    }

    /**
     * Parse the min, max, value and visible counts from the elements if we can.
     * @return {Number|Boolean}
     */
  }, {
    key: "_parseInputElsParams",
    value: function _parseInputElsParams() {
      var els = this.inputEls;
      if (!els) {
        return;
      }
      var i = 0;
      var len = els.length;
      var mins = [];
      var maxes = [];
      var values = [];
      var visibleCounts = [];
      var disableds = [];
      for (; i < len; i++) {
        if (!els[i]) {
          continue;
        }
        if (this.mins && this.mins[i]) mins[i] = (0, _typeof2.default)(this.mins[i]) === 'object' ? this.mins[i] : parsedDomFormat.getValues(this.mins[i]);else if (els[i].getAttribute('min')) mins[i] = parsedDomFormat.getValues(els[i].getAttribute('min'));
        if (this.maxes && this.maxes[i]) maxes[i] = (0, _typeof2.default)(this.maxes[i]) === 'object' ? this.maxes[i] : parsedDomFormat.getValues(this.maxes[i]);else if (els[i].getAttribute('max')) maxes[i] = parsedDomFormat.getValues(els[i].getAttribute('max'));
        if ((0, _values.default)(this) && (0, _values.default)(this)[i]) values[i] = (0, _typeof2.default)((0, _values.default)(this)[i]) === 'object' ? (0, _values.default)(this)[i] : parsedDomFormat.getValues((0, _values.default)(this)[i]);else if (els[i].value) values[i] = parsedDomFormat.getValues(els[i].value);
        disableds[i] = (0, _parseAttribute.boolean)(els[i], 'disabled', false);
        if (!this.visibleCounts) visibleCounts[i] = parseInt(els[i].getAttribute('data-visible-count'), 10) || 1;
      }
      this.mins = mins;
      this.minVisible = _date.default.earliest(mins);
      this.maxes = maxes;
      this.maxVisible = _date.default.latest(maxes);
      this.values = values;
      this._isDisabled = disableds;
      if (visibleCounts.length) this.visibleCounts = visibleCounts;
    }

    /**
     * Get the dates we should be showing. Start with the first value or today's date.
     */
  }, {
    key: "_initDatesToShow",
    value: function _initDatesToShow() {
      var arr = [];
      var i = 0;
      var len = (0, _values.default)(this).length;

      // Get the date for the current index
      if ((0, _values.default)(this)[this.activeIndex]) {
        arr.push((0, _values.default)(this)[this.activeIndex].clone());
      }

      // Get the first date
      for (; i < len && !arr.length; i++) {
        if ((0, _values.default)(this)[i]) {
          arr.push((0, _values.default)(this)[i].clone());
        }
      }

      // If we didn't get a date, use the min
      for (i = 0, len = this.mins.length; i < len && !arr.length; i++) {
        if (this.mins[i]) {
          arr.push(this.mins[i].clone());
        }
      }

      // If we still didn't get a date, add today's date.
      if (!arr.length) {
        arr.push(_date.default.now());
      }
      this._datesToShow = arr;
      this._setDatesToShow();
    }

    /**
     * Set the dates to show.
     * @param {Number} change Optional The direction to change
     */
  }, {
    key: "_setDatesToShow",
    value: function _setDatesToShow(change) {
      var _context9;
      var arr = this._datesToShow;
      var visibleCount = this._currentBreakpoint === 'xs' || this._currentBreakpoint === 'sm' ? 1 : this.visibleCounts[this.activeIndex] || this.visibleCounts[0] || 1;
      var i = 0;
      var noun = this.viewRange.charAt(0).toUpperCase() + (0, _slice.default)(_context9 = this.viewRange).call(_context9, 1);

      // If we have more dates to show than we're supposed to show, remove the excess.
      // This happens when visible count changes between renders
      if (arr.length > visibleCount) {
        (0, _splice.default)(arr).call(arr, visibleCount);
      }

      // If we are incrementing or decrementing the starting month
      if (change) {
        // Empty the rest of the dates from the array
        arr = this._datesToShow = (0, _splice.default)(arr).call(arr, 0, 1);

        // Decrement
        if (change < 0) {
          for (; i > change; i--) {
            arr[0] = arr[0]['previous' + noun];
          }
        } else {
          for (; i < change; i++) {
            arr[0] = arr[0]['next' + noun];
          }
        }
      }

      // Check bounds
      this._atMin = this._checkMinDateVisible(noun, arr);
      this._atMax = this._checkMaxDateVisible(noun, arr);
      var addDate;
      var lastSelected;
      var action;
      i = 0;

      // Add additional dates
      while (arr.length < visibleCount) {
        // If at the max, prepend
        // If we're in the last input and it has a value and it's a different month than the first value, prepend
        // If at the min, append
        // If an item we're adding is before the min, discard it and append an item after the last in the arr
        // If an item we're adding is after the max, discard it and prepend an item before the first in the arr

        lastSelected = !change && this.activeIndex === (0, _values.default)(this).length - 1 && (0, _values.default)(this)[(0, _values.default)(this).length - 1] && (0, _values.default)(this)[0] && !(0, _values.default)(this)[(0, _values.default)(this).length - 1]['equal' + noun]((0, _values.default)(this), true);

        // If we're showing the max date or we have the last input selected and it has a value, add dates before.
        if (this._atMax || lastSelected) {
          addDate = arr[i]['previous' + noun];
          action = 'unshift';
          if (addDate['before' + noun](this.minVisible)) {
            addDate = arr[i]['next' + noun];
            action = 'push';
          }
        } else {
          addDate = arr[i]['next' + noun];
          action = 'push';
          if (addDate['after' + noun](this.maxVisible)) {
            addDate = arr[i]['previous' + noun];
            action = 'unshift';
          }
        }
        if (action === 'push') {
          arr.push(addDate);
          i = arr.length - 1;
        } else {
          arr.unshift(addDate);
          i = 0;
        }
      }

      // Check bounds again
      this._atMin = this._checkMinDateVisible(noun, arr);
      this._atMax = this._checkMaxDateVisible(noun, arr);

      // Update the navigation to reflect the _atMin or _atMax state
      this._updateNav();
    }

    /**
     * Check for the min value in an array of values.
     * @param {Object} min
     * @param {String} noun The type of date to check
     * @param {Array} arr
     * @return {Boolean}
     */
  }, {
    key: "_checkMinDateVisible",
    value: function _checkMinDateVisible(noun, arr) {
      if (!this.minVisible) {
        return;
      }
      var min = this.minVisible;
      if (min && (arr[0]['equal' + noun](min) || arr[0]['before' + noun](min))) {
        arr[0] = min;
        return true;
      }
      return false;
    }

    /**
     * Check for the max value in an array of values.
     * @param {Object} max
     * @param {String} noun The type of date to check
     * @param {Array} arr
     * @return {Boolean}
     */
  }, {
    key: "_checkMaxDateVisible",
    value: function _checkMaxDateVisible(noun, arr) {
      if (!this.maxVisible) {
        return;
      }
      var max = this.maxVisible;
      if (max && arr[arr.length - 1] && (arr[arr.length - 1]['equal' + noun](max) || arr[arr.length - 1]['after' + noun](max))) {
        arr[arr.length - 1] = max;
        return true;
      }
      return false;
    }

    /**
     * Check that the values are in bounds and, optinoally, in sequential order.
     * If checking for sequence, remove those which aren't.
     * @param {Number} setIndex The index of the value most recently set. This shouldn't be removed.
     * @return {Boolean} Did any values change?
     */
  }, {
    key: "_checkValues",
    value: function _checkValues(setIndex, skipRangeCheck) {
      // Check boundaries
      var changed = this._checkMinMaxValues();

      // Sequential range items check
      if (this._isRange && !skipRangeCheck) {
        var i = (0, _values.default)(this).length - 1;
        for (; i >= 0; i--) {
          if ((0, _values.default)(this)[i] && (0, _values.default)(this)[i - 1] && (0, _values.default)(this)[i].beforeDay((0, _values.default)(this)[i - 1], true)) {
            if (i === setIndex) {
              this.setValue(null, i - 1, true);
            } else {
              this.setValue(null, i, true);
            }
            changed = true;
          }
        }
      }
      return changed;
    }

    /**
     * Check minimum/maximum values.
     * @return {Boolean}
     */
  }, {
    key: "_checkMinMaxValues",
    value: function _checkMinMaxValues() {
      var i = 0;
      var len = (0, _values.default)(this).length;
      var changed = false;
      for (; i < len; i++) {
        if (this.maxes && this.maxes[i] && (0, _values.default)(this)[i] && (0, _values.default)(this)[i].after(this.maxes[i], true)) {
          (0, _values.default)(this)[i] = this.maxes[i].clone();
          changed = true;
        } else if (this.mins && this.mins[i] && (0, _values.default)(this)[i] && (0, _values.default)(this)[i].before(this.mins[i], true)) {
          (0, _values.default)(this)[i] = this.mins[i].clone();
          changed = true;
        }
      }
      return changed;
    }

    /**
     * Enqueue animations to be run. (Not really animations since those happen w/ CSS. More
     * of a manager of timeouts).
     * @param {Function} cb
     * @param {Number} duration
     */
  }, {
    key: "_animateContent",
    value: function _animateContent(cb, duration) {
      this._animationQueue = this._animationQueue || [];
      this._animationQueue.push({
        cb: cb,
        d: duration
      });
      this._runAnimation();
    }

    /**
     * Run the first queued animation. When complete, run the next animation.
     */
  }, {
    key: "_runAnimation",
    value: function _runAnimation() {
      if (!this._animationTimer) {
        var a = this._animationQueue.shift();
        if (a) {
          this._animationTimer = setTimeout(function () {
            a.cb.call(this);
            this._animationTimer = null;
            this._runAnimation();
          }.bind(this), a.d);
        }
      }
    }

    /**
     * Update attributes on the element and its children.
     */
  }, {
    key: "_updateAttributes",
    value: function _updateAttributes() {
      this.calendarEl.setAttribute('data-visible-count', this._currentBreakpoint === 'xs' ? 1 : this.visibleCounts[this.activeIndex] || this.visibleCounts[0] || 1);
      this._updateNav();
    }

    /**
     * Update the navigation to reflect the ability to move forward and backward.
     */
  }, {
    key: "_updateNav",
    value: function _updateNav() {
      if (this.previousButtonEl) {
        if (this._atMin) this.previousButtonEl.setAttribute('disabled', true);else this.previousButtonEl.removeAttribute('disabled');
      }
      if (this.nextButtonEl) {
        if (this._atMax) this.nextButtonEl.setAttribute('disabled', true);else this.nextButtonEl.removeAttribute('disabled');
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onInputChangeBound = this._onInputChange.bind(this);
      this._onSelectChangeBound = this._onSelectChange.bind(this);
      this._onInputFocusBound = this._onInputFocus.bind(this);
      this._onClickBound = this._onClick.bind(this);
      this._onCalendarClickBound = this._onCalendarClick.bind(this);
      this._onKeydownBound = this._onKeydown.bind(this);
      this._onCalendarKeydownBound = this._onCalendarKeydown.bind(this);
      this._onCalendarMouseOverBound = this._onCalendarMouseOver.bind(this);
      this._onCalendarMouseOutBound = this._onCalendarMouseOut.bind(this);
      this._onResizeBound = (0, _debounce.default)(this._onResize.bind(this), 25);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      var i = 0;
      var len = this.els.length;
      for (; i < len; i++) {
        this.els[i].addEventListener('click', this._onClickBound);
        this.els[i].addEventListener('keydown', this._onKeydownBound);
        this.inputEls[i].addEventListener('change', this._onInputChangeBound);
        this.inputEls[i].addEventListener('focus', this._onInputFocusBound);
      }
      this.calendarEl.addEventListener('mouseover', this._onCalendarMouseOverBound);
      this.calendarEl.addEventListener('mouseout', this._onCalendarMouseOutBound);
      this.calendarEl.addEventListener('click', this._onCalendarClickBound);
      this.calendarEl.addEventListener('keydown', this._onCalendarKeydownBound);
      this.calendarEl.addEventListener('change', this._onSelectChangeBound);
      window.addEventListener('resize', this._onResizeBound);
      window.addEventListener('orientationchange', this._onResizeBound);
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      var i = 0;
      var len = this.els.length;
      for (; i < len; i++) {
        this.els[i].removeEventListener('click', this._onClickBound);
        this.els[i].removeEventListener('keydown', this._onKeydownBound);
        this.inputEls[i].removeEventListener('change', this._onInputChangeBound);
        this.inputEls[i].removeEventListener('focus', this._onInputFocusBound);
      }
      this.calendarEl.removeEventListener('mouseover', this._onCalendarMouseOverBound);
      this.calendarEl.removeEventListener('mouseout', this._onCalendarMouseOutBound);
      this.calendarEl.removeEventListener('click', this._onCalendarClickBound);
      this.calendarEl.removeEventListener('keydown', this._onCalendarKeydownBound);
      this.calendarEl.removeEventListener('change', this._onSelectChangeBound);
      window.removeEventListener('resize', this._onResizeBound);
      window.removeEventListener('orientationchange', this._onResizeBound);
    }

    /**
     * Focus on the next input if there is one.
     */
  }, {
    key: "_focusNext",
    value: function _focusNext() {
      var index;

      // If we don't have any null values, don't do anything.
      if ((index = (0, _values.default)(this).indexOf(null)) === -1) {
        return;
      }
      if (this.activeIndex < this.els.length - 1) {
        this.open(this.activeIndex + 1);
      } else {
        this.open(index);
      }
    }

    /**
     * Close if we're on the last input and we have values.
     */
  }, {
    key: "_closeOnLast",
    value: function _closeOnLast() {
      if ((0, _values.default)(this).indexOf(null) === -1) {
        this.close({
          delay: this.closeDelay
        });
      }
    }

    /**
     * Make the toggle icon a fill icon.
     */
  }, {
    key: "_fillToggle",
    value: function _fillToggle() {
      var toggle;
      if (this.els[this.activeIndex] && (toggle = this.els[this.activeIndex].querySelector('.spark-date__calendar-toggle [class*="spark-icon"]'))) {
        (0, _addClass.default)(toggle, 'spark-icon--fill');
      }
    }

    /**
     * Make the toggle icon a line icon.
     */
  }, {
    key: "_unfillToggle",
    value: function _unfillToggle() {
      var toggle;
      if (this.els[this.activeIndex] && (toggle = this.els[this.activeIndex].querySelector('.spark-date__calendar-toggle [class*="spark-icon"]'))) {
        (0, _removeClass.default)(toggle, 'spark-icon--fill');
      }
    }

    /**
     * Activate the element associated with the calendar.
     * @param {Number} index
     */
  }, {
    key: "_activateElement",
    value: function _activateElement(index) {
      var el = this.els[index];
      if (el) (0, _addClass.default)(el, 'active');
    }

    /**
     * Deactivate the element associated with the calendar.
     * @param {Number} index
     */
  }, {
    key: "_deactivateElement",
    value: function _deactivateElement(index) {
      var el = this.els[index];
      if (el && !(0, _values.default)(this)[index] && !(0, _hasClass.default)(el, 'focus') && !(0, _hasClass.default)(el, 'has-partial-value')) {
        (0, _removeClass.default)(el, 'active');
      }
    }

    /**
     * Check the size of the popover and see if we should be showing the XS treatment.
     */
  }, {
    key: "_checkSize",
    value: function _checkSize() {
      var bp = (0, _breakpoint.get)(window.innerWidth);

      // Don't do anything if the breakpoint hasn't changed.
      if (this._currentBreakpoint === bp) return;

      // Store the breakpoint
      this._currentBreakpoint = bp;

      // Re-render the date range
      this._setDatesToShow();
      this.render(true);
      this.popover.update();
    }

    /**
     * Scroll the active input element into view.
     */
  }, {
    key: "_scrollToInput",
    value: function _scrollToInput() {
      var el = this.els[this.activeIndex];
      if (el) (0, _scrollTo.default)(el);
    }

    /**
     * Update the hover classes.
     * @param {Element} hoverStarts
     * @param {Element} hoverEnds
     */
  }, {
    key: "_updateHoverClasses",
    value: function _updateHoverClasses(hoverStarts, hoverEnds) {
      this._hoverStarts = this._hoverStarts || [];
      this._hoverEnds = this._hoverEnds || [];
      hoverStarts = hoverStarts instanceof Array ? hoverStarts : hoverStarts ? [hoverStarts] : [];
      hoverEnds = hoverEnds instanceof Array ? hoverEnds : hoverEnds ? [hoverEnds] : [];
      var allStarts = [];
      var curStarts = [];
      var newStarts = [];
      var allEnds = [];
      var curEnds = [];
      var newEnds = [];
      hoverStarts.forEach(function (el) {
        var index = this._hoverStarts.indexOf(el);

        // Already hovered.
        if (index !== -1) {
          curStarts.push(el);

          // Not already hovered. Ready to add the class.
        } else if (el) {
          newStarts.push(el);
          (0, _addClass.default)(el, 'hover-start');
        }
      }, this);
      allStarts = (0, _concat.default)(Array.prototype).call([], curStarts, newStarts);
      this._hoverStarts.forEach(function (el) {
        if (allStarts.indexOf(el) === -1) {
          (0, _removeClass.default)(el, 'hover-start');
        }
      }, this);
      hoverEnds.forEach(function (el) {
        var index = this._hoverEnds.indexOf(el);

        // Already hovered.
        if (index !== -1) {
          curEnds.push(el);

          // Not already hovered. Ready to add the class.
        } else if (el) {
          newEnds.push(el);
          (0, _addClass.default)(el, 'hover-end');
        }
      }, this);
      allEnds = (0, _concat.default)(Array.prototype).call([], curEnds, newEnds);
      this._hoverEnds.forEach(function (el) {
        if (allEnds.indexOf(el) === -1) {
          (0, _removeClass.default)(el, 'hover-end');
        }
      }, this);
      this._hoverStarts = allStarts;
      this._hoverEnds = allEnds;
    }

    /**
     * When an element is clicked, if the toggle was the target, open the popover.
     * @param {Object} e
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      if ((0, _getParent.default)(e.target, '.spark-date__calendar-toggle', this.els)) {
        var el = (0, _getParent.default)(e.target, '.spark-date', this.els);
        var index = this.els.indexOf(el);
        e.preventDefault();

        // Open on the next tick. Otherwise we also receive the window click close event.
        this.open(index, {
          delay: 1
        });
      }
    }

    /**
     * When a key is pressed and it is the Enter key
     * @param {Object} e
     */
  }, {
    key: "_onKeydown",
    value: function _onKeydown(e) {
      // Enter key press on Calendar Popover's Toggle
      if (e.keyCode === 13 && (0, _getParent.default)(e.target, '.spark-date__calendar-toggle', this.els)) {
        this._onClick(e);
      }
    }

    /**
     * When a key is pressed within the Calendar Popover and it is one of the Arrow keys
     * @param {Object} e
     */
  }, {
    key: "_onCalendarKeydown",
    value: function _onCalendarKeydown(e) {
      // Verify that this is a calendar day, otherwise exit
      if (!(0, _hasClass.default)(e.target, 'spark-calendar__day')) {
        return;
      }
      var currentMonth;
      if (e.keyCode === 37 || e.keyCode === 38 || e.keyCode === 39 || e.keyCode === 40) {
        currentMonth = (0, _getParent.default)(e.target, '.spark-calendar__month', this.calendarEl);
      }

      // Left Arrow
      if (e.keyCode === 37) {
        var prevAvailableDay = (0, _getSiblingBefore.default)(e.target, '.spark-calendar__day:not(.spark-calendar__day--disabled)');
        if (prevAvailableDay !== null) {
          prevAvailableDay.focus();
        } else {
          // Check if we are picking dates from a calendar range
          var prevMonth = currentMonth !== null ? (0, _getSiblingBefore.default)(currentMonth, '.spark-calendar__month') : null;
          if (prevMonth) {
            var prevAvailableDays = (0, _getChildren.default)(prevMonth.querySelector('.spark-calendar__days'), '.spark-calendar__day');
            for (var i = prevAvailableDays.length - 1; i >= 0; i--) {
              if (!(0, _hasClass.default)(prevAvailableDays[i], 'spark-calendar__day--disabled') && !(0, _hasClass.default)(prevAvailableDays[i], 'spark-calendar__day--inactive')) {
                prevAvailableDays[i].focus();
                break;
              }
            }
          }
        }
      }

      // Right Arrow
      if (e.keyCode === 39) {
        var nextAvailableDay = (0, _getSiblingAfter.default)(e.target, '.spark-calendar__day:not(.spark-calendar__day--disabled)');
        if (nextAvailableDay !== null) {
          nextAvailableDay.focus();
        } else {
          // Check if we are picking dates from a calendar range
          var nextMonth = currentMonth !== null ? (0, _getSiblingAfter.default)(currentMonth, '.spark-calendar__month') : null;
          if (nextMonth) {
            var nextAvailableDays = (0, _getChildren.default)(nextMonth.querySelector('.spark-calendar__days'), '.spark-calendar__day');
            for (var _i = 0; _i < nextAvailableDays.length; _i++) {
              if (!(0, _hasClass.default)(nextAvailableDays[_i], 'spark-calendar__day--disabled') && !(0, _hasClass.default)(nextAvailableDays[_i], 'spark-calendar__day--inactive')) {
                nextAvailableDays[_i].focus();
                break;
              }
            }
          }
        }
      }

      // Up Arrow and Down Arrow
      if (e.keyCode === 38 || e.keyCode === 40) {
        var calendarDays = currentMonth.querySelector('.spark-calendar__days');
        var targetIndex = (0, _getIndex.default)(calendarDays.children, e.target);
        var nextIndex = targetIndex;
        var availableDay = null;
        var focusSet = false;
        do {
          if (e.keyCode === 38) {
            nextIndex = nextIndex - 7;
          } else {
            nextIndex = nextIndex + 7;
          }
          availableDay = calendarDays.children.item(nextIndex);
          if (availableDay !== null && !(0, _hasClass.default)(availableDay, 'spark-calendar__day--disabled')) {
            focusSet = true;
            availableDay.focus();
            break;
          }
        } while (availableDay !== null && nextIndex >= 0 && nextIndex < 42);
        if (!focusSet) {
          if (e.keyCode === 38) {
            var _prevMonth = currentMonth !== null ? (0, _getSiblingBefore.default)(currentMonth, '.spark-calendar__month') : null;
            if (_prevMonth !== null) {
              calendarDays = _prevMonth.querySelector('.spark-calendar__days');
              if (nextIndex <= 0) {
                nextIndex = 42 + nextIndex;
              }
              while (nextIndex >= 0 && nextIndex < 42) {
                availableDay = calendarDays.children.item(nextIndex);
                if (availableDay !== null && !(0, _hasClass.default)(availableDay, 'spark-calendar__day--disabled')) {
                  availableDay.focus();
                  break;
                }
                nextIndex = nextIndex - 7;
              }
            }
          } else {
            var _nextMonth = currentMonth !== null ? (0, _getSiblingAfter.default)(currentMonth, '.spark-calendar__month') : null;
            if (_nextMonth !== null) {
              calendarDays = _nextMonth.querySelector('.spark-calendar__days');
              if (nextIndex >= 42) {
                nextIndex = nextIndex - 42;
              }
              while (nextIndex >= 0 && nextIndex < 42) {
                availableDay = calendarDays.children.item(nextIndex);
                if (availableDay !== null && !(0, _hasClass.default)(availableDay, 'spark-calendar__day--disabled')) {
                  availableDay.focus();
                  break;
                }
                nextIndex = nextIndex + 7;
              }
            }
          }
        }
      }
    }

    /**
     * When the calendar is hovered, do some highlighting if we're showing a range.
     * @param {Object} e
     */
  }, {
    key: "_onCalendarMouseOver",
    value: function _onCalendarMouseOver(e) {
      if (this.viewRange === 'month') this._onCalendarMouseOverMonths(e.target);
    }

    /**
     * Set hover states for days.
     * @param  {Element} target
     */
  }, {
    key: "_onCalendarMouseOverMonths",
    value: function _onCalendarMouseOverMonths(target) {
      if (!this._isRange) {
        return;
      }
      var day = (0, _getParent.default)(target, '.spark-calendar__day');
      if (!day) {
        this._updateHoverClasses();
        return;
      }
      var month = (0, _getParent.default)(target, '.spark-calendar__month');
      var mHasClass = function (c) {
        return (0, _hasClass.default)(month, c);
      }.bind(this);
      var newStart = [];
      var newEnd = [];
      var daySel;

      // Only do highlights if we don't already have a value for this index.
      if (!(0, _values.default)(this)[this.activeIndex]) {
        // A month with a value before it but no value of its own, hover starts
        // from the first day to the hovered day.
        if (mHasClass('value-before') && !mHasClass('after-range-end') && !mHasClass('has-value') && !mHasClass('value-after')) {
          newStart.push(month.querySelector('.spark-calendar__day:not(.spark-calendar__day--inactive):not(.spark-calendar__day--disabled)'));
          newEnd.push(day);

          // Add a hover range to a previous month.
          var prevMonth = month;
          while ((prevMonth = (0, _getSiblingBefore.default)(prevMonth, '.spark-calendar__month')) && !(0, _hasClass.default)(prevMonth, 'value-after') && ((0, _hasClass.default)(prevMonth, 'has-value') || (0, _hasClass.default)(prevMonth, 'value-before'))) {
            daySel = prevMonth.querySelectorAll('.spark-calendar__day--selected');
            daySel = daySel[daySel.length - 1];
            daySel = daySel || prevMonth.querySelector('.spark-calendar__day');
            if (daySel) {
              newStart.push(daySel);
              daySel = prevMonth.querySelectorAll('.spark-calendar__day');
              daySel = daySel[daySel.length - 1];
              newEnd.push(daySel);
            }
          }

          // A month with a value, highlight either from the hovered day to
          // the selection or from the selection to the day.
        } else if (mHasClass('has-value') && !mHasClass('value-before') && !mHasClass('value-after') && ((newStart = (0, _getSiblingBefore.default)(day, '.spark-calendar__day--selected')) || (newEnd = (0, _getSiblingAfter.default)(day, '.spark-calendar__day--selected')))) {
          if (newStart) {
            newStart = [newStart];
            newEnd = [day];
          } else {
            newEnd = [newEnd];
            newStart = [day];
          }
          if ((0, _hasClass.default)(newEnd[0], 'spark-calendar__range-start') || (0, _hasClass.default)(newStart[0], 'spark-calendar__range-end')) {
            newStart = [];
            newEnd = [];
          }

          // A month with a middle range should highlight before
        } else if (mHasClass('has-value') && mHasClass('range-middle') && mHasClass('value-before')) {
          daySel = (0, _getSiblingBefore.default)(day, '.spark-calendar__day--selected');
          if (daySel) {
            newStart = [daySel];
            newEnd = [day];
          }
        }
      }
      this._updateHoverClasses(newStart, newEnd);
    }

    /**
     * When the calendar is hovered, undo some highlighting if we're showing a range.
     * @param {Object} e
     */
  }, {
    key: "_onCalendarMouseOut",
    value: function _onCalendarMouseOut(e) {
      if (this.viewRange === 'month') this._onCalendarMouseOutMonths(e.target);
    }

    /**
     * Clear hover states for days.
     * @param  {Element} target
     */
  }, {
    key: "_onCalendarMouseOutMonths",
    value: function _onCalendarMouseOutMonths(target) {
      var day = (0, _getParent.default)(target, '.spark-calendar__day');
      var days = (0, _getParent.default)(target, '.spark-calendar__days');
      var month = (0, _getParent.default)(target, '.spark-calendar__month');
      (0, _removeClass.default)(day, 'hover');
      (0, _removeClass.default)(days, 'hover');
      (0, _removeClass.default)(month, 'hover');
      (0, _removeClass.default)(this.calendarEl, 'hover');
    }

    /**
     * When the calendar is clicked, handle navigation clicks and date selections.
     * @param {Object} e
     */
  }, {
    key: "_onCalendarClick",
    value: function _onCalendarClick(e) {
      var nav = (0, _getParent.default)(e.target, '.spark-calendar__nav', this.calendarEl);
      var today = (0, _getParent.default)(e.target, '.spark-calendar__today', this.calendarEl);
      var day;
      var dir;

      // Navigation clicks
      if (nav) {
        // Previous
        if ((0, _getParent.default)(e.target, '.spark-calendar__previous', nav)) {
          this.previous();

          // Next
        } else if ((0, _getParent.default)(e.target, '.spark-calendar__next', nav)) {
          this.next();
        }

        // Day click
      } else if (day = (0, _getParent.default)(e.target, '.spark-calendar__day')) {
        e.preventDefault();
        e.stopPropagation();

        // Disabled day moves can move us to the next month
        if ((0, _hasClass.default)(day, 'spark-calendar__day--disabled')) {
          dir = day.getAttribute('data-direction');
          if (dir === 'next') this.next();else if (dir === 'previous') this.previous();

          // Enabled day sets the value
        } else {
          this.setValue(day.getAttribute('data-date'), this.activeIndex);
          if (this.autoAdvance) this._focusNext();
          if (this.autoClose) this._closeOnLast();
        }

        // Today button
      } else if (today) {
        e.preventDefault();
        e.stopPropagation();
        this.setValue(_date.default.now(), this.activeIndex);
        if (this.autoAdvance) this._focusNext();
        if (this.autoClose) this._closeOnLast();
      }
    }

    /**
     * When the popover opens, set the toggle state.
     */
  }, {
    key: "_onPopoverOpen",
    value: function _onPopoverOpen() {
      this._fillToggle();
      this._checkSize();
      if (this._currentBreakpoint === 'xs') this._scrollToInput();
    }

    /**
     * When the popover closes, reset the active state.
     */
  }, {
    key: "_onPopoverClose",
    value: function _onPopoverClose() {
      this._unfillToggle();
      this._updateHoverClasses();
      this._deactivateElement(this.activeIndex);
      if (document.activeElement.nodeName.toLocaleLowerCase() === 'body') {
        if (this.els[this.activeIndex] !== undefined) {
          this.els[this.activeIndex].querySelector('.spark-date__calendar-toggle').focus();
        } else {
          for (var i = 0; i < this.els.length; i++) {
            // Set focus to the toggle when the Calendar Popover is closed as it is the only trigger
            if (this.els[i].querySelector('.spark-date__calendar-toggle') !== null) {
              this.els[i].querySelector('.spark-date__calendar-toggle').focus();
              break;
            }
          }
        }
      }
      this.activeIndex = null;
    }

    /**
     * When the input that corresponds to this instance changes. Allows us to listen
     * and respond to changes made by other components (Calendar Popover, for example).
     * @param {Object} e
     */
  }, {
    key: "_onInputChange",
    value: function _onInputChange(e) {
      var index = this.inputEls.indexOf(e.target);
      if (this._inputsChanging && this._inputsChanging.indexOf(index) !== -1) return;
      this.setValue(e.target.value, index);
    }

    /**
     * When an input receives focus, if we are supposed to automatically show
     * on focus do so.
     * @param {Object} e
     */
  }, {
    key: "_onInputFocus",
    value: function _onInputFocus(e) {
      if (!this.showOnFocus) return;
      var index = this.inputEls.indexOf(e.target);
      if (index !== -1) this.open(index);
    }

    /**
     * When one of the calendar quick jump select inputs changes.
     * We have to set the value of the select input back to its original
     * value or else it will be out of sync when the currently active
     * month is shown again.
     * @param {Object} e
     */
  }, {
    key: "_onSelectChange",
    value: function _onSelectChange(e) {
      var name = e.target.name;
      var val = e.target.value;
      var curVal = this._datesToShow[this.activeIndex][name];
      var obj = {};
      obj[name] = val;
      this.showDate(obj);

      // showDate re-renders calendar add focus back to select list
      if (this.calendarEl && this.calendarEl.querySelector("[name=" + name + "]")) {
        this.calendarEl.querySelector("[name=" + name + "]").focus();
      }
      e.target.value = curVal;
    }

    /**
     * When the window resizes, determine if we're at the XS breakpoint so we
     * can do some mobile-esque stuff!
     * @param {Object} e
     */
  }, {
    key: "_onResize",
    value: function _onResize() {
      if (this.activeIndex !== null) this._checkSize();
    }
  }]);
  return CalendarPopover;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
CalendarPopover.prototype._whitelistedParams = ['els', 'visibleCounts', 'autoAdvance', 'autoClose', 'closeDelay', 'mins', 'maxes', 'values', 'daysDisabled', 'daysInfo', 'quickJump', 'quickJumpRange', 'calendarEl', 'viewRange', 'animate', 'animationDuration', 'showOnFocus', 'onChange', 'showTodayButton', 'todayButtonLabel', 'anchorX', 'anchorY'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
CalendarPopover.prototype.defaults = {
  els: null,
  inputEls: null,
  calendarEl: null,
  calendarContentEl: null,
  calendarOverflowEl: null,
  visibleCounts: null,
  activeIndex: null,
  mins: null,
  minVisible: null,
  maxes: null,
  maxVisible: null,
  values: null,
  daysDisabled: null,
  daysInfo: null,
  viewRange: null,
  autoAdvance: null,
  autoClose: null,
  quickJump: null,
  closeDelay: null,
  showTodayButton: null,
  todayButtonLabel: null,
  nextButtonEl: null,
  previousButtonEl: null,
  animate: null,
  animationDuration: null,
  showOnFocus: null,
  anchorX: null,
  anchorY: null,
  onChange: null,
  _isDisabled: false,
  _isRange: null,
  _hoverStarts: null,
  _hoverEnds: null,
  _currentBreakpoint: null,
  _animationQueue: null,
  _currentContent: null,
  _datesToShow: null,
  _monthsShowing: null,
  _atMin: false,
  _atMax: false,
  _inputsChanging: false,
  _openCloseTimer: null,
  _renderCache: null,
  _onClickBound: null,
  _onKeydownBound: null,
  _onCalendarMouseOverBound: null,
  _onCalendarMouseOutBound: null,
  _onCalendarClickBound: null,
  _onCalendarKeydownBound: null,
  _onSelectChangeBound: null,
  _onInputChangeBound: null,
  _onInputFocusBound: null,
  _onResizeBound: null
};
var _default = CalendarPopover;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/animation/scroll-to":54,"../helpers/date/date":57,"../helpers/date/parse-format":58,"../helpers/dom/add-class":59,"../helpers/dom/breakpoint":60,"../helpers/dom/has-class":61,"../helpers/dom/parse-attribute":66,"../helpers/dom/remove-class":67,"../helpers/dom/trigger-event":69,"../helpers/form/build-select":70,"../helpers/manipulation/append-children":73,"../helpers/traversal/get-children":85,"../helpers/traversal/get-index":86,"../helpers/traversal/get-parent":87,"../helpers/traversal/get-sibling-after":89,"../helpers/traversal/get-sibling-before":90,"../helpers/util/debounce":93,"../helpers/util/range":100,"./base":3,"./popover":30,"@babel/runtime-corejs3/core-js-stable/instance/concat":108,"@babel/runtime-corejs3/core-js-stable/instance/filter":110,"@babel/runtime-corejs3/core-js-stable/instance/map":113,"@babel/runtime-corejs3/core-js-stable/instance/slice":115,"@babel/runtime-corejs3/core-js-stable/instance/splice":117,"@babel/runtime-corejs3/core-js-stable/instance/values":119,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/assertThisInitialized":143,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155,"@babel/runtime-corejs3/helpers/typeof":162}],7:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _debounce = _interopRequireDefault(require("../helpers/util/debounce"));
var _transform = _interopRequireDefault(require("../helpers/css/transform"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _getParents = _interopRequireDefault(require("../helpers/traversal/get-parents"));
var _passiveEvents = _interopRequireDefault(require("../helpers/util/passive-events"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Carousel
                                                                                                                                                                                                                                                                                                                                              * Create a Carousel
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Carousel(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/carousel.js
                                                                                                                                                                                                                                                                                                                                              */
var Carousel = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(Carousel, _BaseComponent);
  var _super = _createSuper(Carousel);
  /**
   * Carousel constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function Carousel(el, params) {
    var _this;
    (0, _classCallCheck2.default)(this, Carousel);
    _this = _super.call(this, el, params);
    params = params || {};
    if (!el) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._init(el);
    return _this;
  }

  /**
   * Carousel Item Contructor, exposes access to functions setTransform, setSelected, and currentPosition
   * @param {Element} el Node to initalize as carouselItem
   * @param {Object} parent reference to the parent carousel
   * @param {Element} dot Node to use as dot element
   * @param {Number} order original order in the markup
   */
  (0, _createClass2.default)(Carousel, [{
    key: "_carouselItem",
    value: function _carouselItem(el, parent, dot, order) {
      var a = {};
      a.el = el;
      a.parent = parent;
      a.dot = dot;
      a.order = order;
      a.addTransform = function (x) {
        a.setTransform(a.transform.x + x);
      };
      a.setTransform = function (x) {
        x = x ? x : 0;
        a.transform = {
          'x': x
        };
        a.el.setAttribute('style', (0, _transform.default)('translate3d', a.transform.x + 'px, 0px, 0px'));
      };
      a.setSelected = function (b) {
        if (a.setSelected.selected === b && typeof a.setSelected.selected !== 'undefined') {
          return;
        }
        if (b) {
          (0, _addClass.default)(a.el, 'selected');
          (0, _addClass.default)(a.dot, 'selected');
          a.setSelected.selected = true;
        } else {
          (0, _removeClass.default)(a.el, 'selected');
          (0, _removeClass.default)(a.dot, 'selected');
          a.setSelected.selected = false;
        }
      };
      a.currentPosition = function () {
        return parent.transform.x + a.transform.x + a.dims.left + a.width / 2 - parent.dims.left;
      };
      a.setTransform();
      a.dims = el.getBoundingClientRect();
      a.width = a.dims.width;
      a.el.sparkcarouselitem = a;
      a.dot.sparkcarouselitemdot = a;
      return a;
    }

    /**
     * Scans element and sets up or resets the carousel based on configuration
     * @param {Element} el Node to initalize as the carousel
     */
  }, {
    key: "_init",
    value: function _init(el) {
      // cache elements and controls
      this.el = el;
      this.el.sparkcarousel = this;
      this.backe = this.el.querySelector('.spark-carousel__back');
      this.forwarde = this.el.querySelector('.spark-carousel__forward');
      this.outerContainer = this.el.querySelector('.spark-carousel__outer-container');
      this.containerMask = this.el.querySelector('.spark-carousel__container-mask');
      this.container = this.el.querySelector('.spark-carousel__container');
      this.dots = this.el.querySelector('.spark-carousel__dots');
      this.pauseEl = this.el.querySelector('.spark-carousel__pause');

      // get the options from the element
      this.opts = {};
      this.opts.wrapItems = this.el.attributes['data-spark-carousel-wrap-items'] ? true : false;
      this.opts.startingVelocity = this.el.attributes['data-spark-carousel-scroll-velocity'] ? this.el.attributes['data-spark-carousel-scroll-velocity'].value : 10;
      this.opts.smoothScroll = this.el.attributes['data-spark-carousel-smooth-scroll'] ? true : false;
      this.opts.smoothScrollCenterItems = this.el.attributes['data-spark-carousel-smooth-scroll-center'] ? true : false;
      this.opts.panelScroll = this.el.attributes['data-spark-carousel-panel'] ? true : false;
      this.opts.edgeScroll = this.opts.panelScroll || this.el.attributes['data-spark-carousel-edge'] ? true : false;
      this.opts.heroCarousel = this.el.attributes['data-spark-carousel-hero'] ? true : false;
      this.opts.autoAdvance = this.el.attributes['data-spark-carousel-auto-advance'] ? this.el.attributes['data-spark-carousel-auto-advance'].value : false;

      // setup autoAdvance
      if (this.opts.autoAdvance && !this.autoAdvance && !this.pause) {
        this.autoAdvance = window.setTimeout(function () {
          this._autoAdvance();
        }.bind(this), this.opts.autoAdvance * 1000);
      }

      // conditionally bind pause handlers.
      // needs to be done here so that resetting the carousel will work correctly
      if (this.opts.autoAdvance && !this.pauseH) {
        this.pauseH = this._pause.bind(this);
        this.pauseEl.addEventListener('click', this.pauseH);
      }

      // collect items and cache sizing
      var a = this.el.querySelectorAll('.spark-carousel__item');
      this.items = [];
      this.totalItemWidth = 0;
      this.dims = this.containerMask.getBoundingClientRect();
      this.width = this.dims.width;
      this.height = this.dims.height;
      var dots = document.createDocumentFragment();
      var b;

      // create our carouselItems
      for (var i = 0; i < a.length; i++) {
        b = document.createElement('div');
        b.setAttribute('tabindex', '-1');
        dots.appendChild(b);
        this.items.push(new this._carouselItem(a[i], this, b, i));
        this.totalItemWidth += this.items[i].width;
      }

      // if we're resetting we need to empty out the exisiting elements first
      while (this.dots.firstChild) {
        this.dots.removeChild(this.dots.firstChild);
      }
      this.dots.appendChild(dots);

      // this is to test if we're dealing with 2011 flexbox (IE10) and need to do an adjustment
      // this is because ms-flex-pack: center doesn't work like 2012 flexbox center-pack
      if (typeof this.container.style.msFlexAlign !== 'undefined') {
        this._transformItems(-(this.totalItemWidth - this.width) / 2);
      }

      // setup inital transform
      this._setTransform();

      // need to bind this event handler here as we are always going to need to be listening
      // for this event, in order to react to container visibility changing
      this._handleVisibleChildren = this._handleVisibleChildrenH.bind(this);
      document.addEventListener('spark.visible-children', this._handleVisibleChildren, true);
      if (!this._rafHandler) {
        this._rafHandler = this._rafHandlerH.bind(this);
      }

      // need to also listen to resize events, even if we don't have items overflowing
      if (!this.resizeH) {
        this.resizeH = (0, _debounce.default)(this._resize.bind(this), 100);
        window.addEventListener('resize', this.resizeH);
      }

      // if we haven't already init'd event listerers, and we have items overflowing
      if (this.totalItemWidth > this.width) {
        if (!this.touchstartH) {
          (0, _removeClass.default)(this.el, 'noscroll');
          this._setupListeners();

          // center the first item
          this._addTransform(-this.items[0].currentPosition() + this.width / 2);
        }

        // if we don't have overflowing items, then disable scrolling and remove listeners
      } else {
        (0, _addClass.default)(this.el, 'noscroll');
        this._removeListeners();

        // Re-add keyboard navigation listeners to allow tabbing and usage of Esc key
        this._onNavKeyupBound = this._onNavKeyup.bind(this);
        window.addEventListener('keyup', this._onNavKeyupBound);
      }

      // set the new selected item
      this._updateSelected();

      // finally, display the element
      (0, _addClass.default)(this.el, 'ready');
    }

    /**
     * Tears down the component, removes listeners, and conditionally delete the DOM element
     * @param {Boolean} leaveElement Falsey value will remove the DOM element as well as the component instance
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      this._removeListeners();
      window.removeEventListener('resize', this.resizeH);
      delete this.resizeH;
      document.removeEventListener('spark.visible-children', this._handleVisibleChildren, true);
      delete this._handleVisibleChildren;
      (0, _get2.default)((0, _getPrototypeOf2.default)(Carousel.prototype), "remove", this).call(this, leaveElement);
    }

    /**
     * Pause/unpause the autoAdvance feature
     */
  }, {
    key: "_pause",
    value: function _pause() {
      if (this.pause) {
        delete this.moves;
        this.autoAdvance = window.setTimeout(function () {
          this._autoAdvance();
        }.bind(this), this.opts.autoAdvance * 1000);
      } else {
        this._rafCancel();
        if (!this.opts.smoothScroll || this.opts.smoothScrollCenterItems) {
          this._scrollTo(this._selectedItem());
        }
        window.clearTimeout(this.autoAdvance);
        delete this.autoAdvance;
      }
      this._setPause(!this.pause);
    }

    /**
     * toggles the pause class on the element
     * @param {Boolean} b Truthy value will give the element the pause class
     */
  }, {
    key: "_setPause",
    value: function _setPause(b) {
      if (typeof b === 'undefined') {
        this.pause = typeof this.pause === 'undefined' ? false : this.pause;
        return this.pause;
      } else {
        if (b) {
          (0, _addClass.default)(this.el, 'pause');
        } else {
          (0, _removeClass.default)(this.el, 'pause');
        }
        this.pause = b;
        return this.pause;
      }
    }

    /**
     * function called by window.setTimeout, will check first to see if element is in use before triggering a slide advance
     */
  }, {
    key: "_autoAdvance",
    value: function _autoAdvance() {
      if (this.el && !this.moves && !this._laststart && !this.paused) {
        this._rafCancel();
        var a = this.items.indexOf(this._selectedItem());
        this._scrollToItem = true;
        this._scrollTo(this.items[a === this.items.length - 1 ? 0 : a + 1]);
        this.autoAdvance = window.setTimeout(function () {
          this._autoAdvance();
        }.bind(this), this.opts.autoAdvance * 1000);
      }
    }

    /**
     * Initialize and bind even listeners
     */
  }, {
    key: "_setupListeners",
    value: function _setupListeners() {
      var passiveEvents = (0, _passiveEvents.default)();
      this.touchstartH = this._touchstart.bind(this);
      this.container.addEventListener('touchstart', this.touchstartH, passiveEvents ? {
        passive: false
      } : false);
      this.touchmoveH = this._touchmove.bind(this);
      window.addEventListener('touchmove', this.touchmoveH, passiveEvents ? {
        passive: false
      } : false);
      this.touchendH = this._touchend.bind(this);
      window.addEventListener('touchend', this.touchendH);
      this.mousedownH = this._mousedown.bind(this);
      this.container.addEventListener('mousedown', this.mousedownH);
      this.mousemoveH = this._mousemove.bind(this);
      window.addEventListener('mousemove', this.mousemoveH);
      this.mouseupH = this._mouseup.bind(this);
      window.addEventListener('mouseup', this.mouseupH);
      this.forwardH = this._forward.bind(this);
      this.forwarde.addEventListener('click', this.forwardH);
      this.backH = this._back.bind(this);
      this.backe.addEventListener('click', this.backH);
      this.clickH = this._click.bind(this);
      this.el.addEventListener('click', this.clickH);
      this._focusHandler = this._scrollToClicked.bind(this);
      this.container.addEventListener('focus', this._focusHandler, true);
      this._onNavKeyupBound = this._onNavKeyup.bind(this);
      window.addEventListener('keyup', this._onNavKeyupBound);
    }

    /**
     * Removes non-essential event listeners, called when tearing down the component, or our content
     * does not exceed the width of our element
     */
  }, {
    key: "_removeListeners",
    value: function _removeListeners() {
      this.el.removeEventListener('touchstart', this.touchstartH);
      delete this.touchstartH;
      window.removeEventListener('touchmove', this.touchmoveH);
      delete this.touchmoveH;
      window.removeEventListener('touchend', this.touchendH);
      delete this.touchendH;
      this.el.removeEventListener('mousedown', this.mousedownH);
      delete this.mousedownH;
      window.removeEventListener('mousemove', this.mousemoveH);
      delete this.mousemoveH;
      window.removeEventListener('mouseup', this.mouseupH);
      delete this.mouseupH;
      this.forwarde.removeEventListener('click', this.forwardH);
      delete this.forwardH;
      this.backe.removeEventListener('click', this.backH);
      delete this.backH;
      this.el.removeEventListener('click', this.clickH);
      delete this.clickH;
      this.container.removeEventListener('focus', this._focusHandler, true);
      delete this._focusHandler;
      if (this.pauseEl) {
        this.pauseEl.removeEventListener('click', this.pauseH);
        delete this.pauseH;
      }
      window.removeEventListener('keyup', this._onNavKeyupBound);
      delete this._onNavKeyupBound;
    }

    /**
     * Event handler for the spark.visible-children event, just call the change function to handle any
     * visibility or sizing changes
     * @param {Event} e The spark.visible-children event
     */
  }, {
    key: "_handleVisibleChildrenH",
    value: function _handleVisibleChildrenH(e) {
      if (e.target.contains(this.el)) {
        window.setTimeout(function () {
          this.change();
        }.bind(this), 0);
      }
    }

    /**
     * Keyboard keyup handler
     * @param {Event} e
     */
  }, {
    key: "_onNavKeyup",
    value: function _onNavKeyup(e) {
      // Navigate backwards
      if (e.keyCode === 13 && document.activeElement === this.backe) {
        this._back(e);
      }

      // Navigate forwards
      if (e.keyCode === 13 && document.activeElement === this.forwarde) {
        this._forward(e);
      }

      // Pause/Play
      if ((e.keyCode === 13 || e.keyCode === 32) && document.activeElement === this.pauseEl) {
        this._pause();
      }

      // ESC key
      if (e.keyCode === 27 && (0, _hasClass.default)(document.activeElement, 'spark-carousel__item') && !this.opts.heroCarousel) {
        // Set focus to Skip Carousel link if it exists
        // Account for presence of multiple carousels to set focus on the right link
        var parentEl = (0, _getParents.default)(document.activeElement.parentNode, '.spark-carousel');
        var skipCarousel = parentEl[parentEl.length - 1].querySelector('.spark-carousel__skip');
        if (skipCarousel) {
          skipCarousel.focus();
        }
      }
    }

    /**
     * Forward button click handler triggers a scrollTo to the "next" element
     * @param {Event} e The click event
     */
  }, {
    key: "_forward",
    value: function _forward(e) {
      var s = this.items.indexOf(this._selectedItem());
      s++;
      if (s > this.items.length - 1) {
        if (this.opts.wrapItems) {
          s = 0;
        } else {
          s--;
        }
      }
      delete this.moves;
      var a = this._startingVelocity;
      a = a < -this.opts.startingVelocity ? a : -this.opts.startingVelocity;
      this._rafCancel();
      this._scrollToItem = true;
      this._scrollTo(this.items[s], a);
      if (e) {
        e.preventDefault();
      }
    }

    /**
     * Back button click handler triggers a scrollTo to the "previous" element
     * @param {Event} e The click event
     */
  }, {
    key: "_back",
    value: function _back(e) {
      var s = this.items.indexOf(this._selectedItem());
      s--;
      if (s < 0) {
        if (this.opts.wrapItems) {
          s = this.items.length - 1;
        } else {
          s++;
        }
      }
      delete this.moves;
      var a = this._startingVelocity;
      a = a > this.opts.startingVelocity ? a : this.opts.startingVelocity;
      this._rafCancel();
      this._scrollToItem = true;
      this._scrollTo(this.items[s], a);
      if (e) {
        e.preventDefault();
      }
    }

    /**
     * Move start handler, handles both touchstart and mousedown events
     * @param {Object} e The start event
     */
  }, {
    key: "_movestart",
    value: function _movestart(e) {
      this._rafCancel();
      this.moves = [];
      this.moves.push(e);
    }

    /**
     * Move handler, handles internal move event objects
     * @param {Object} e The move event
     */
  }, {
    key: "_move",
    value: function _move(e) {
      if (this.moves && this.moves.length > 1) {
        this._addTransform(e.pageX - this.moves[this.moves.length - 1].pageX);
        this.moves.push(e);
        e.preventDefault = true;
      } else {
        if (this.moves && this.moves[0]) {
          if (Math.abs(this.moves[0].pageX - e.pageX) > Math.abs(this.moves[0].pageY - e.pageY) && Math.abs(this.moves[0].pageX - e.pageX) > 5 && e.cancelable) {
            this._addTransform(e.pageX - this.moves[0].pageX);
            this.moves.push(e);
            e.preventDefault = true;
          } else {
            if (Math.abs(this.moves[0].pageX - e.pageX) > 5) {
              this.moves[0] = e;
            }
          }
        }
        if (e.type === 'touchend' || e.type === 'mouseup') {
          delete this.moves;
        }
      }
    }

    /**
     * Move end handler, handles both touchend and mouseup events
     * @param {Object} e The moveend event
     */
  }, {
    key: "_moveend",
    value: function _moveend(e) {
      this._move(e);
      if (!this.opts.smoothScroll) {
        this._settle(this.moves);
      } else {
        this._interiaScroll(this.moves);
      }
      return e;
    }

    /**
     * Resize event handler, calls change to handle any element dimension changes
     */
  }, {
    key: "_resize",
    value: function _resize() {
      this.change();
    }

    /**
     * Calling the change function will handle updating the element to take into account
     * any styling, sizing, or visibility changes, and the addition or removal of any carouselItems
     */
  }, {
    key: "change",
    value: function change() {
      if (!this.el) {
        return;
      }
      var dims = this.el.getBoundingClientRect();
      if (dims.width !== this.width || dims.height !== this.height) {
        if (this.autoAdvance) {
          window.clearTimeout(this.autoAdvance);
          delete this.autoAdvance;
        }
        this._rafCancel();
        var c = this._selectedItem();
        this._setTransform(0);
        this._setTransformItems(0);
        this._init(this.el);
        if (this.items.indexOf(c.el.sparkcarouselitem) > -1 && this.totalItemWidth > this.width) {
          if (this.opts.wrapItems) {
            this._addTransform(-this.totalItemWidth + (-c.el.sparkcarouselitem.currentPosition() + this.width / 2));
          } else {
            this._addTransform(-c.el.sparkcarouselitem.currentPosition() + this.width / 2);
          }
        }
      }
    }

    /**
     * Update the component to use a new element or reparse from
     * the existing element.
     * @param {Element} el Optional
     */
  }, {
    key: "update",
    value: function update(el) {
      el = el || this.el;
      this._removeListeners();
      window.removeEventListener('resize', this.resizeH);
      delete this.resizeH;
      document.removeEventListener('spark.visible-children', this._handleVisibleChildren, true);
      delete this._handleVisibleChildren;
      this._init(el);
      this.change();
      return this;
    }

    /**
     * Touchstart event handler, passes necessary data points to the movestart function
     * @param {Object} e The touchstart event
     */
  }, {
    key: "_touchstart",
    value: function _touchstart(e) {
      var a = {
        'type': e.type,
        'pageX': e.touches[0].pageX,
        'pageY': e.touches[0].pageY,
        'timeStamp': e.timeStamp
      };
      this._movestart(a);
    }

    /**
     * Touchmove event handler, passes necessary data points to the move function
     * @param {Object} e The touchmove event
     */
  }, {
    key: "_touchmove",
    value: function _touchmove(e) {
      var a = {
        'type': e.type,
        'pageX': e.touches[0].pageX,
        'pageY': e.touches[0].pageY,
        'timeStamp': e.timeStamp,
        'cancelable': e.cancelable
      };
      this._move(a);
      if (a.preventDefault) {
        e.preventDefault();
      }
    }

    /**
     * Touchend event handler, passes necessary data points to the moveend function
     * @param {Object} e The touchend event
     */
  }, {
    key: "_touchend",
    value: function _touchend(e) {
      if (this.moves && this.moves.length > 2 && e.cancelable) {
        var a = {
          'type': e.type,
          'pageX': this.moves[this.moves.length - 1].pageX,
          'pageY': this.moves[this.moves.length - 1].pageY,
          'timeStamp': e.timeStamp
        };
        this._moveend(a);
      } else {
        delete this.moves;
      }
    }

    /**
     * Mousedown event handler, passes necessary data points to the movestart function
     * @param {Object} e The mousedown event
     */
  }, {
    key: "_mousedown",
    value: function _mousedown(e) {
      if (e.button !== 0) {
        return e;
      }
      this.isMouseDown = true;
      var a = {
        'type': e.type,
        'pageX': e.pageX,
        'pageY': e.pageY,
        'timeStamp': e.timeStamp
      };
      this._movestart(a);
      e.preventDefault();
    }

    /**
     * Mousemove event handler, passes necessary data points to the move function
     * @param {Object} e The mousemove event
     */
  }, {
    key: "_mousemove",
    value: function _mousemove(e) {
      if (this.isMouseDown) {
        var a = {
          'type': e.type,
          'pageX': e.clientX,
          'pageY': e.clientY,
          'timeStamp': e.timeStamp,
          // this was changed to correct an issue in safari - it doesn't report cancelable correctly
          'cancelable': true
        };
        this._move(a);
        if (a.preventDefault) {
          e.preventDefault();
        }
      }
    }

    /**
     * Mouseup event handler, passes necessary data points to the moveend function
     * @param {Object} e The mouseup event
     */
  }, {
    key: "_mouseup",
    value: function _mouseup(e) {
      if (this.moves && this.moves.length > 2) {
        var a = {
          'type': e.type,
          'pageX': e.pageX,
          'pageY': e.pageY,
          'timeStamp': e.timeStamp
        };
        this._moveend(a);
        this.mouseUpHandled = true;
      } else {
        delete this.moves;
        this._scrollToClicked(e);
      }
      this.isMouseDown = false;
    }

    /**
     * Click event handler
     * @param {Object} e The click event
     */
  }, {
    key: "_click",
    value: function _click(e) {
      // if we are already tracking moves, then this will be handled by the mouseend event handler and we should prevent the default action
      if (this.moves) {
        e.preventDefault();
      }

      // if it has already been handled by mouseup handler, prevent the action
      if (this.mouseUpHandled) {
        e.preventDefault();
      }

      // reset our handled state
      delete this.mouseUpHandled;

      // checking both this.moves and this.mouseUpHandled ensures we capture events correctly in all browsers, where the order of the mouseup/click events can vary
    }

    /**
     * Calculate the user's recent cursor/finger velocity
     * @param {Array} moves The array of cursor positions
     */
  }, {
    key: "_velocity",
    value: function _velocity(moves) {
      var avg = 0;
      var m = Math.min(6, moves.length - 1);
      for (var i = 1; i < m; i++) {
        if (moves[moves.length - i].timeStamp === moves[moves.length - i - 1].timeStamp) {
          avg += avg / i;
        } else {
          avg += 10 * (moves[moves.length - i].pageX - moves[moves.length - i - 1].pageX) / (moves[moves.length - i].timeStamp - moves[moves.length - i - 1].timeStamp) / m;
        }
      }
      return avg;
    }

    /**
     * Handles click events on items and dots, scrolling to the clicked item
     * @param {Event} e The click event
     */
  }, {
    key: "_scrollToClicked",
    value: function _scrollToClicked(e) {
      var tar = e.target;
      if (this.el.contains(tar)) {
        while (!tar.sparkcarousel) {
          if (tar.sparkcarouselitem) {
            this.containerMask.scrollLeft = 0;
            delete this.moves;
            this._rafCancel();
            this._scrollTo(tar.sparkcarouselitem);
            e.preventDefault();
            break;
          }
          if (tar.sparkcarouselitemdot) {
            this.containerMask.scrollLeft = 0;
            delete this.moves;
            this._rafCancel();
            var v = tar.sparkcarouselitemdot.order < this._selectedItem().order ? this.opts.startingVelocity : -this.opts.startingVelocity;
            this._scrollTo(tar.sparkcarouselitemdot, v);
            e.preventDefault();
            break;
          }
          tar = tar.parentNode;
        }
      }
    }

    /**
     * Scroll to the carouselItem, with specified startingVelocity, auto determines default velocity if not specified
     * @param {Object} item The carouselItem to scroll to
     * @param {Number} startingVelocity The startingVelocity of the scroll animation
     */
  }, {
    key: "_scrollTo",
    value: function _scrollTo(item, startingVelocity) {
      var offset = this.width / 2;
      var currentPosition = item.currentPosition();
      if (!startingVelocity) {
        startingVelocity = offset - item.currentPosition() > 0 ? this.opts.startingVelocity : -this.opts.startingVelocity;
      }
      if (this.opts.wrapItems) {
        if (startingVelocity > 0) {
          // left
          if (currentPosition > offset) {
            this._totalDistance = offset + this.totalItemWidth - currentPosition;
          } else {
            this._totalDistance = offset - currentPosition;
          }
        } else {
          // right
          if (currentPosition < offset) {
            this._totalDistance = -(this.totalItemWidth + currentPosition - offset);
          } else {
            this._totalDistance = offset - currentPosition;
          }
        }
      } else {
        this._totalDistance = offset - currentPosition;
      }
      this._startingVelocity = startingVelocity;
      delete this.moves;
      this._scrollToItem = true;
      this._raf = window.requestAnimationFrame(this._rafHandler);
    }

    /**
     * This is the animator function, it examines the options set on the carousel object
     * and selectively adds transform and requests addtional animation frames if necesary
     * @param {Number} t The timestamp for the current animation frame
     */
  }, {
    key: "_rafHandlerH",
    value: function _rafHandlerH(t) {
      if (this.opts.autoAdvance && this.autoAdvance) {
        window.clearTimeout(this.autoAdvance);
        delete this.autoAdvance;
      }
      var frames;
      if (this.moves || !this._startingVelocity) {
        this._rafCancel();
        return;
      }
      if (!this._laststart) {
        this._laststart = t;
      }
      if (!this._remainingDistance) {
        this._remainingDistance = this._totalDistance;
      }
      if (!this._lastframe) {
        this._lastframe = t;
        frames = 1;
      } else {
        frames = (t - this._lastframe) / (1 / 60 * 1000);
      }
      var d = this._startingVelocity * frames;
      if (this.opts.smoothScroll && !this._scrollToItem) {
        this._addTransform(d);
        this._startingVelocity *= Math.pow(0.97, frames);
        if (this.opts.smoothScrollCenterItems && Math.abs(this._startingVelocity) < 1) {
          this._scrollTo(this._selectedItem());
        }
        if (Math.abs(this._startingVelocity) < 0.5) {
          if (this._startingVelocity > 0 && this.transform.x > this.totalItemWidth / 2 - this.items[0].width / 2 || this._startingVelocity < 0 && this.transform.x < -(this.totalItemWidth / 2 - this.items[this.items.length - 1].width / 2)) {
            this._scrollToItem = true;
            this._scrollTo(this._selectedItem());
          } else {
            this._rafCancel();
          }
        } else {
          this._raf = window.requestAnimationFrame(this._rafHandler);
        }
      } else {
        if (this._startingVelocity > 0) {
          if (d < this._remainingDistance) {
            this._addTransform(d);
            this._remainingDistance -= d;
            if (this._remainingDistance > this._totalDistance / 2) {
              this._startingVelocity *= Math.pow(1.15, frames);
            } else {
              this._startingVelocity *= Math.pow(0.9, frames);
              this._startingVelocity = this._startingVelocity > 2 ? this._startingVelocity : 2;
            }
            this._raf = window.requestAnimationFrame(this._rafHandler);
          } else {
            this._addTransform(this._remainingDistance);
            this._rafCancel();
          }
        } else {
          if (d > this._remainingDistance) {
            this._addTransform(d);
            this._remainingDistance -= d;
            if (this._remainingDistance < this._totalDistance / 2) {
              this._startingVelocity *= Math.pow(1.15, frames);
            } else {
              this._startingVelocity *= Math.pow(0.9, frames);
              this._startingVelocity = this._startingVelocity < -2 ? this._startingVelocity : -2;
            }
            this._raf = window.requestAnimationFrame(this._rafHandler);
          } else {
            this._addTransform(this._remainingDistance);
            this._rafCancel();
          }
        }
      }
      this._lastframe = t;
    }

    /**
     * This is the animator clearing function
     * it clears values used during animation, and selectively enables autoAdvance
     */
  }, {
    key: "_rafCancel",
    value: function _rafCancel() {
      if (this.opts.autoAdvance && !this.autoAdvance && !this.pause) {
        this.autoAdvance = window.setTimeout(function () {
          this._autoAdvance();
        }.bind(this), this.opts.autoAdvance * 1000);
      }
      window.cancelAnimationFrame(this._raf);
      delete this._scrollToItem;
      delete this._laststart;
      delete this._startingVelocity;
      delete this._remainingDistance;
      delete this._totalDistance;
      delete this._lastframe;
    }

    /**
     * This computes values necessary to start an animation frame when the carousel is
     * configured to use smoothScroll
     * @param {Array} moves The captured move events
     */
  }, {
    key: "_interiaScroll",
    value: function _interiaScroll(moves) {
      if (moves[moves.length - 1].timeStamp - moves[moves.length - 2].timeStamp > 100 || moves.length < 3) {
        if (this.opts.smoothScrollCenterItems) {
          return this._scrollTo(this._selectedItem());
        }
        return;
      }
      this._startingVelocity = this._velocity(moves);
      delete this.moves;
      this._raf = window.requestAnimationFrame(this._rafHandler);
    }

    /**
     * This determines which carousel item should be focused based on the previous moves
     * made by the user
     * @param {Array} moves The captured move events
     */
  }, {
    key: "_settle",
    value: function _settle(moves) {
      if (moves && moves.length > 3) {
        if (moves[moves.length - 1].timeStamp - moves[moves.length - 2].timeStamp > 80) {
          return this._scrollTo(this._selectedItem());
        }
        var v1 = 10 * (moves[moves.length - 3].pageX - moves[moves.length - 4].pageX) / (moves[moves.length - 3].timeStamp - moves[moves.length - 4].timeStamp);
        var v2 = 10 * (moves[moves.length - 2].pageX - moves[moves.length - 3].pageX) / (moves[moves.length - 2].timeStamp - moves[moves.length - 3].timeStamp);
        if (Math.abs(v1) < Math.abs(v2) || Math.abs(v2) > 0.5 && Math.abs(v2) > 0.5) {
          // user is probably trying to go to next or prev item
          var s = this.items.indexOf(this._selectedItem());
          if (v2 > 0) {
            // prev
            if (s > 0) {
              this._scrollTo(this.items[s - 1], v2);
            } else {
              if (this.opts.wrapItems) {
                this._scrollTo(this.items[this.items.length - 1], v2);
              } else {
                this._scrollTo(this.items[0]);
              }
            }
          } else {
            // next
            if (s < this.items.length - 1) {
              this._scrollTo(this.items[s + 1], v2);
            } else {
              if (this.opts.wrapItems) {
                this._scrollTo(this.items[0], v2);
              } else {
                this._scrollTo(this.items[this.items.length - 1]);
              }
            }
          }
        } else {
          if (this._selectedItem().currentPosition() > this.width / 2) {
            this._scrollTo(this._selectedItem(), -this.opts.startingVelocity);
          } else {
            this._scrollTo(this._selectedItem(), this.opts.startingVelocity);
          }
        }
      }
    }

    /**
     * Transforms the position of all carouselItems
     * @param {Number} x The pixel value to transform
     */
  }, {
    key: "_transformItems",
    value: function _transformItems(x) {
      for (var i = 0; i < this.items.length; i++) {
        this.items[i].addTransform(x);
      }
    }

    /**
     * Sets the transform position of all carouselItems
     * @param {Number} x The pixel value to transform
     */
  }, {
    key: "_setTransformItems",
    value: function _setTransformItems(x) {
      for (var i = 0; i < this.items.length; i++) {
        this.items[i].setTransform(x);
      }
    }

    /**
     * Adds transform to the container element, does checking for bounds conditions and
     * wraps items if necessary and configured
     * @param {Number} x The pixel value to transform
     */
  }, {
    key: "_addTransform",
    value: function _addTransform(x) {
      var a;
      if ((this.opts.smoothScrollCenterItems || !this.opts.smoothScroll) && !this.opts.wrapItems && !this.opts.edgeScroll) {
        var l = this.items.indexOf(this.selectedItem);
        if (l === this.items.length - 1) {
          this._leftbound(true);
        } else {
          this._leftbound(false);
        }
        if (l === 0) {
          this._rightbound(true);
        } else {
          this._rightbound(false);
        }
      } else {
        this._leftbound(false);
        this._rightbound(false);
      }
      if (this.transform.x + x < 0 && x < 0) {
        if (this.opts.wrapItems) {
          // wrap items until we have covered the visible area
          while (this.transform.x + x < -(this.totalItemWidth - this.width) / 2 && (this.totalItemWidth < this.width ? this.transform.x + x < -this.totalItemWidth / 2 : true)) {
            a = this.items.shift();
            this.items.push(a);
            a.addTransform(this.totalItemWidth);
            this._transformItems(-a.width);
            x += a.width;
          }
        } else {
          // there is a 1 pixel adjustment to account for some math rounding
          if (this.opts.edgeScroll && x < 0 && this.transform.x + x - 1 <= -(this.totalItemWidth - this.width) / 2) {
            this._leftbound(true);
            return this._setTransform(-(this.totalItemWidth - this.width) / 2);
          }

          // progressively reduce scrolling when no more items to the right
          if (x < 0 && this.transform.x + x < -(this.totalItemWidth / 2 - this.items[this.items.length - 1].width / 2)) {
            x = x * ((this.totalItemWidth / 2 + this.items[this.items.length - 1].width / 2 + (this.transform.x + x)) / this.items[this.items.length - 1].width);
            x = x > 0 ? 0 : x;
          }
        }
        return this._setTransform(this.transform.x + x);
      } else {
        if (this.transform.x + x > 0 && x > 0) {
          if (this.opts.wrapItems) {
            // wrap items until we have covered the visible area
            while (this.transform.x + x > -(this.width - this.totalItemWidth) / 2 && (this.totalItemWidth < this.width ? this.transform.x + x > this.totalItemWidth / 2 : true)) {
              a = this.items.pop();
              this.items.unshift(a);
              a.addTransform(-this.totalItemWidth);
              this._transformItems(a.width);
              x -= a.width;
            }
          } else {
            // there is a 1 pixel adjustment to account for some math rounding
            if (this.opts.edgeScroll && x > 0 && this.transform.x + x + 1 >= (this.totalItemWidth - this.width) / 2) {
              this._rightbound(true);
              return this._setTransform((this.totalItemWidth - this.width) / 2);
            }

            // progressively reduce scrolling when no more items to the left
            if (x > 0 && this.transform.x + x > this.totalItemWidth / 2 - this.items[0].width / 2) {
              x = x * ((this.totalItemWidth / 2 + this.items[0].width / 2 - (this.transform.x + x)) / this.items[0].width);
              x = x < 0 ? 0 : x;
            }
          }
        }
        return this._setTransform(this.transform.x + x);
      }
    }

    /**
     * Sets the leftbound class
     * @param {Boolean} b Set or unset the leftbound class
     */
  }, {
    key: "_leftbound",
    value: function _leftbound(b) {
      if (typeof b === 'undefined') {
        this.leftbound = typeof this.leftbound === 'undefined' ? false : this.leftbound;
        return this.leftbound;
      } else {
        if (b) {
          (0, _addClass.default)(this.el, 'leftbound');
        } else {
          (0, _removeClass.default)(this.el, 'leftbound');
        }
        this.leftbound = b;
        return this.leftbound;
      }
    }

    /**
     * Sets the rightbound class
     * @param {Boolean} b Set or unset the rightbound class
     */
  }, {
    key: "_rightbound",
    value: function _rightbound(b) {
      if (typeof b === 'undefined') {
        this.rightbound = typeof this.rightbound === 'undefined' ? false : this.rightbound;
        return this.rightbound;
      } else {
        if (b) {
          (0, _addClass.default)(this.el, 'rightbound');
        } else {
          (0, _removeClass.default)(this.el, 'rightbound');
        }
        this.rightbound = b;
        return this.rightbound;
      }
    }

    /**
     * Updates the selected item, by seeing which item has its center closest
     * to the center of the carousel
     */
  }, {
    key: "_updateSelected",
    value: function _updateSelected() {
      var tar = this.width / 2;
      var i = -1;
      var a = 1;
      var b = 0;
      while (a > b) {
        i++;
        if (i > this.items.length - 2) {
          break;
        }
        a = Math.abs(tar - this.items[i].currentPosition());
        b = Math.abs(tar - this.items[i + 1].currentPosition());
      }
      return this._selectedItem(this.items[i]);
    }

    /**
     * Stores the selected item for the carousel, and updates the previously
     * selected item and newly selected item to have the correct states
     * Conditionally sets the leftbound/rightbound states depending on configuration
     * @param {Object} item Optional: the new item select, if omitted it will
     * return the currently selected item.
     */
  }, {
    key: "_selectedItem",
    value: function _selectedItem(item) {
      if ((0, _typeof2.default)(item) !== 'object') {
        if (this.selectedItem) {
          return this.selectedItem;
        } else {
          return this._updateSelected();
        }
      } else {
        if (this.selectedItem) {
          this.selectedItem.setSelected(false);
        }
        this.selectedItem = item;
        if ((this.opts.smoothScrollCenterItems || !this.opts.smoothScroll) && !this.opts.wrapItems && !this.opts.edgeScroll) {
          var l = this.items.indexOf(this.selectedItem);
          if (l === this.items.length - 1) {
            this._leftbound(true);
          } else {
            this._leftbound(false);
          }
          if (l === 0) {
            this._rightbound(true);
          } else {
            this._rightbound(false);
          }
        }
        this.selectedItem.setSelected(true);
      }
    }

    /**
     * Sets the transform for the carousel container
     * @param {Number} x The pixel value to transform
     */
  }, {
    key: "_setTransform",
    value: function _setTransform(x) {
      x = x ? x : 0;
      this.transform = {
        'x': x
      };
      this.container.setAttribute('style', (0, _transform.default)('translate3d', x + 'px, 0px, 0px'));
      this._updateSelected();
      return x;
    }
  }]);
  return Carousel;
}(_base.default);
/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
Carousel.prototype.defaults = {
  el: null
};

/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
Carousel.prototype._whitelistedParams = [];
var _default = Carousel;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/css/transform":56,"../helpers/dom/add-class":59,"../helpers/dom/has-class":61,"../helpers/dom/remove-class":67,"../helpers/traversal/get-parents":88,"../helpers/util/debounce":93,"../helpers/util/passive-events":99,"./base":3,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155,"@babel/runtime-corejs3/helpers/typeof":162}],8:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _isInteger = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/number/is-integer"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _dateTypeahead = _interopRequireDefault(require("./date-typeahead"));
var _dateSelect = _interopRequireDefault(require("./date-select"));
var _parseFormat = _interopRequireDefault(require("../helpers/date/parse-format"));
var _pad = _interopRequireDefault(require("../helpers/util/pad"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _appendChildren = _interopRequireDefault(require("../helpers/manipulation/append-children"));
var _triggerEvent = _interopRequireDefault(require("../helpers/dom/trigger-event"));
var _copyAttributes = _interopRequireDefault(require("../helpers/manipulation/copy-attributes"));
var _date = _interopRequireDefault(require("../helpers/date/date"));
var _each = _interopRequireDefault(require("../helpers/util/each"));
var _parseAttribute = require("../helpers/dom/parse-attribute");
var _mixin = _interopRequireDefault(require("../helpers/util/mixin"));
var _messaging = _interopRequireDefault(require("../mixins/messaging"));
var _makeElement = _interopRequireDefault(require("../helpers/dom/make-element"));
var _validation = _interopRequireDefault(require("../mixins/validation"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # DateInput
                                                                                                                                                                                                                                                                                                                                              * A date input container.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new DateInput(el, {
                                                                                                                                                                                                                                                                                                                                              *   // Optional. Callback for when the input value changes.
                                                                                                                                                                                                                                                                                                                                              *   onChange(value, inputInstance) {}
                                                                                                                                                                                                                                                                                                                                              * });
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/date-input.js
                                                                                                                                                                                                                                                                                                                                              */
var domDateFormat = 'YYYY-MM-DD';
var parsedDomFormat = (0, _parseFormat.default)(domDateFormat);
var noop = function noop() {};
var DateInput = /*#__PURE__*/function (_Base) {
  (0, _inherits2.default)(DateInput, _Base);
  var _super = _createSuper(DateInput);
  /**
   * DateInput constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function DateInput(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, DateInput);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._convertLabel();
    _this._initializeInputs();
    _this._updateClass();
    _this._addEventListeners();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Show the input by adding the active state and setting character counts (if necessary).
   */
  (0, _createClass2.default)(DateInput, [{
    key: "show",
    value: function show() {
      if (!this.isActive) {
        this._runTypeaheads();
        this.isActive = true;
        this._updateClass();
      }
      return this;
    }

    /**
     * Hide the input by removing the active state.
     */
  }, {
    key: "hide",
    value: function hide() {
      if (!this.isActive) return this;
      this.isActive = false;
      this._updateClass();
      return this;
    }

    /**
     * Augment default remove call w/ helper cleanup.
     * @param {Boolean} leaveElement Leave the element intact.
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      this._removeTypeaheads(leaveElement);
      this._removeSelects(leaveElement);
      this._removeInputPieces();
      (0, _get2.default)((0, _getPrototypeOf2.default)(DateInput.prototype), "remove", this).call(this, leaveElement);
      return this;
    }

    /**
     * Given an object with day, month and year, set the value of the input.
     * @param {Object} values
     */
  }, {
    key: "setValue",
    value: function setValue(values) {
      values = values || {
        day: '',
        month: '',
        year: ''
      };
      var i;
      var hadValue;
      for (i in this.typeaheads) {
        if (values[i] !== undefined) {
          this.typeaheads[i].setValue(values[i]);
          hadValue = hadValue || (values[i] ? true : false);
        }
      }
      for (i in this.selects) {
        if (values[i] !== undefined) {
          this.selects[i].setValue(values[i]);
          hadValue = hadValue || (values[i] ? true : false);
        }
      }
      if (!this.isActive && hadValue) {
        this.isActive = true;
      }
      this._padTypeaheads();
      this._updateClass();
      this.updateInput();
      return this;
    }

    /**
     * Get the value of the input.
     * @return {String}
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return this.inputEl.value;
    }

    /**
     * Clear the values.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      (0, _each.default)(this.isTypeahead ? this.typeaheads : this.selects, function (k, v) {
        v.clearValue();
      });
      this.inputEl.value = '';
      return this;
    }

    /**
     * Set/reset error state
     * @param {Boolean} true: set error state, false: reset
     */
  }, {
    key: "setErrorState",
    value: function setErrorState(opt) {
      if (opt) {
        this.el.setAttribute('data-error', '');
      } else {
        this.el.removeAttribute('data-error');
      }
    }

    /**
     * Enable the inputs
     */
  }, {
    key: "enable",
    value: function enable() {
      (0, _each.default)(this.isTypeahead ? this.typeaheads : this.selects, function (k, v) {
        v.enable();
      });
      this.inputEl.removeAttribute('disabled');
      (0, _toggleClass.default)(this.el, 'disabled', false);
      return this;
    }

    /**
     * Clear the values.
     */
  }, {
    key: "disable",
    value: function disable() {
      (0, _each.default)(this.isTypeahead ? this.typeaheads : this.selects, function (k, v) {
        v.disable();
      });
      this.inputEl.setAttribute('disabled', '');
      (0, _toggleClass.default)(this.el, 'disabled', true);
      return this;
    }

    /**
     * Update the input values to match the typeaheads.
     */
  }, {
    key: "updateInput",
    value: function updateInput() {
      var inputs;
      if (this.isTypeahead && this.typeaheads) {
        inputs = this.typeaheads;
      } else if (this.isSelect) {
        inputs = this.selects;
      }
      if (inputs) {
        var day = inputs.day && inputs.day.getValue(true) || 0;
        var month = inputs.month && inputs.month.getValue(true) || 0;
        var year = inputs.year && inputs.year.getValue(true) || 0;
        var val = this.inputEl.value;
        this.inputEl.value = [day, month, year].indexOf(0) === -1 ? (0, _pad.default)(year, 4) + '-' + (0, _pad.default)(month, 2) + '-' + (0, _pad.default)(day, 2) : '';
        if (val !== this.inputEl.value) {
          this._pauseInputChange = true;
          (0, _triggerEvent.default)(this.inputEl, 'change');
          (this.onChange || noop)(this.inputEl.value, this);
          this._pauseInputChange = false;
        }
      }
      this.currValue = this.inputEl.value;
      return this;
    }

    /**
     * Get current typing value
     *
     */
  }, {
    key: "getTypingValue",
    value: function getTypingValue() {
      var inputs;
      var result = '';
      if (this.isTypeahead && this.typeaheads) {
        inputs = this.typeaheads;
      } else if (this.isSelect) {
        inputs = this.selects;
      }
      if (inputs) {
        var day = inputs.day && inputs.day.getValue(true);
        var month = inputs.month && inputs.month.getValue(true);
        var year = inputs.year && inputs.year.getValue(true);
        result = month.toString() + day.toString() + year.toString();
      }
      return result;
    }

    /**
     * Move the focus to a typeahead element.
     * @param {Number} i
     * @param {String} character Optional A character to add
     */
  }, {
    key: "focus",
    value: function focus(i, character) {
      if (!this.isActive || !this.inFocus) {
        return this;
      }
      var index = this.typeaheadEls.indexOf(this.inFocus.typeahead.el);
      var sib = this.typeaheadEls[index + i];
      var typeahead;

      // If we were passed a character to prepend, find the typeahead for this element
      if (character) {
        typeahead = this._getTypeaheadByElement(sib);
        if (typeahead) {
          typeahead.typeahead.addCharacterAtIndex(character, 0);
        }
      }
      if (!sib) {
        return false;
      }
      var sibInput = sib.querySelector('input');
      if (sibInput) {
        sibInput.focus();

        // If we have a typeahead (because we needed to prepend a character), move the caret.
        if (typeahead) {
          typeahead.typeahead.moveCaret(1);
        }
      }
      return this;
    }

    /**
     * Move the focus to the next element.
     * @param {String} character Optional A character to add
     */
  }, {
    key: "focusNext",
    value: function focusNext(character) {
      if (this.focus(1, character)) {
        if (this.inFocus && !character) this.inFocus.typeahead.moveCaretToStart();
      }
      return this;
    }

    /**
     * Move the focus to the next element.
     * @param {String} character Optional A character to add
     */
  }, {
    key: "focusPrevious",
    value: function focusPrevious(character) {
      if (this.focus(-1, character)) {
        if (this.inFocus) this.inFocus.typeahead.moveCaretToEnd();
      }
      return this;
    }

    /**
     * Do we have any values?
     * @return {Boolean}
     */
  }, {
    key: "hasPartialValue",
    value: function hasPartialValue() {
      var i;
      for (i in this.typeaheads) {
        if (this.typeaheads[i].getValue()) {
          return true;
        }
      }
      for (i in this.selects) {
        if (this.selects[i].getValue()) {
          return true;
        }
      }
      return false;
    }

    /**
     * Resize the elements, to account for any changed display property.
     * @param {Element} el Optional
     */
  }, {
    key: "update",
    value: function update(el) {
      if (el) {
        this._removeTypeaheads();
        this._removeSelects();
        this._removeInputPieces();
        this._removeEventListeners();
        this._cacheElements(el);
        this._convertLabel();
        this._initializeInputs();
        this._updateClass();
        this._addEventListeners();
      } else {
        this._runTypeaheads();
      }
      return this;
    }

    /**
     * Store a reference to the needed elements.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.inputEl = this.el.querySelector('[type="date"]');
      this.inputLabel = this.el.querySelector('.spark-label').innerHTML;
      this.selectLabelPrefix = this.el.querySelector('.spark-label').getAttribute('id');
      if (!this.inputEl) {
        throw new Error('No <input type="date"> element present in date input container!', this.el);
      }
      this.toggleEl = this.el.querySelector('.spark-date__toggle');
      this.messageEl = this.el.querySelector('.spark-input__message') || (0, _makeElement.default)('<span class="spark-input__message"></span>');
    }

    /**
     * Parse parameters from the elements.
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      this.isActive = this.isActive !== null ? this.isActive : this.inputEl.value ? true : false;
      this.isSelect = this.isSelect !== null ? this.isSelect : (0, _hasClass.default)(this.el, 'spark-date--select') ? true : false;
      this.isTypeahead = this.isTypeahead !== null ? this.isTypeahead : !this.isSelect ? true : false;
      this.format = this.format !== null ? this.format : (0, _parseAttribute.string)(this.inputEl, 'data-format', 'MM-DD-YYYY');
      this.textFormat = this.textFormat !== null ? this.textFormat : (0, _parseAttribute.string)(this.inputEl, 'data-text-format', 'MM DD YYYY');
      this.showDateAsText = this.showDateAsText !== null ? this.showDateAsText : (0, _parseAttribute.boolean)(this.inputEl, 'data-show-date-as-text', false);
      this.parsedFormat = (0, _parseFormat.default)(this.format);
      this.parsedTextFormat = (0, _parseFormat.default)(this.textFormat);
      this.min = this.min !== null ? this.min : this.inputEl.getAttribute('min');
      this.max = this.max !== null ? this.max : this.inputEl.getAttribute('max');
      this.min = this.min && parsedDomFormat.getValues(this.min);
      this.max = this.max && parsedDomFormat.getValues(this.max);
      this.currValue = this.inputEl.value !== null ? this.inputEl.value : null;
    }

    /**
     * Setup the proper inputs. This could mean creating a typeahead, or creating selects.
     */
  }, {
    key: "_initializeInputs",
    value: function _initializeInputs() {
      if (this.isTypeahead) {
        this._initializeInputPieces();
        this._runTypeaheads();
      } else if (this.isSelect) {
        (0, _removeClass.default)(this.el, 'spark-input');
        this._initializeInputPieces();
      }
    }

    /**
     * Replace the date input with a group of typeaheads or select inputs.
     * Keep the date input around and store the typeahead data in there in an ISO date format.
     */
  }, {
    key: "_initializeInputPieces",
    value: function _initializeInputPieces() {
      // Hide the original element. This will be updated as the typeahead values change
      this.inputEl.style.display = 'none';
      var els = [];
      var label;

      // Create a new typeahead for each part of the parsed format. Also add placeholder elements.
      this.parsedFormat.parts.forEach(function (part) {
        // Something weird with Node that makes us have to specify what `this` is here.
        (this.isTypeahead ? this._initializeTypeaheadPiece : this._initializeSelectPiece).call(this, els, part);
      }.bind(this));

      // Create a holder for all the pieces
      this.piecesEl = document.createElement('span');
      this.piecesEl.className = this.isTypeahead ? 'spark-input__fields' : 'spark-select-group';

      // Add all the necessary elements
      (0, _appendChildren.default)(this.piecesEl, els);

      // Add handlers to maintain focus if a specific input field is clicked. If a delimiter is clicked select the next closest input.
      if (this.isTypeahead) {
        els.forEach(function (part) {
          if ((0, _hasClass.default)(part, 'spark-input')) {
            part.addEventListener('click', function (e) {
              part.querySelector('input').focus();
              e.preventDefault();
            });
          }
          if ((0, _hasClass.default)(part, 'spark-input__divider')) {
            part.addEventListener('click', function (e) {
              if (part.nextSibling && part.nextSibling.querySelector('input')) {
                part.nextSibling.querySelector('input').focus();
                e.preventDefault();
              }
            });
          }
        });
      }

      // If this is a select group, move the label element.
      if (this.isSelect && (label = this.el.querySelector('.spark-label'))) {
        this.piecesEl.appendChild(label);
      }

      // Add the pieces holder
      this.el.insertBefore(this.piecesEl, this.inputEl);

      // Set the value
      if (this.inputEl.value) {
        this.setValue(parsedDomFormat.getValues(this.inputEl.value));
        this.isActive = true;
      }
    }

    /**
     * Remove the input pieces.
     */
  }, {
    key: "_removeInputPieces",
    value: function _removeInputPieces() {
      this.inputEl.style.display = '';

      // Remove elements we inserted into the DOM
      if (this.piecesEl) {
        this.piecesEl.parentNode.removeChild(this.piecesEl);
      }
    }

    /**
     * Remove typeaheads.
     * @param {Boolean} leaveElement Leave the element intact.
     */
  }, {
    key: "_removeTypeaheads",
    value: function _removeTypeaheads(leaveElement) {
      // Remove typeaheads
      if (this.typeaheads) {
        for (var i in this.typeaheads) {
          this.typeaheads[i].remove(leaveElement);
        }
      }
    }

    /**
     * Remove selects.
     * @param {Boolean} leaveElement Leave the element intact.
     */
  }, {
    key: "_removeSelects",
    value: function _removeSelects(leaveElement) {
      var label;

      // Remove selects
      if (this.selects) {
        for (var i in this.selects) {
          this.selects[i].remove(leaveElement);
        }

        // If this is a select group, move the label element.
        if (label = this.piecesEl.querySelector('.spark-label')) {
          this.el.appendChild(label);
        }
        (0, _addClass.default)(this.el, 'spark-input');
      }
    }

    /**
     * Create a typeahead or placeholder piece.
     * @param {Array} els
     * @param {Object} part
     */
  }, {
    key: "_initializeTypeaheadPiece",
    value: function _initializeTypeaheadPiece(els, part) {
      this.typeaheads = this.typeaheads || {};
      this.typeaheadEls = this.typeaheadEls || [];
      var el;
      switch (part.name) {
        case 'day':
        case 'month':
        case 'year':
          this.typeaheads[part.name] = new _dateTypeahead.default({
            type: part.name,
            ariaLabelPrefix: this.inputLabel,
            len: part.length,
            placeholder: part.value,
            onFocus: this._onTypeaheadFocusBound,
            onBlur: this._onTypeaheadBlurBound,
            onChange: this._onPieceChangeBound,
            onInput: this._onTypeaheadInputBound,
            onBackspace: this._onTypeaheadBackspaceBound,
            onEnd: this._onTypeaheadEndBound
          });
          el = this.typeaheads[part.name].typeahead.el;
          this.typeaheadEls.push(el);
          break;
        default:
          el = document.createElement('span');
          el.innerHTML = part.value;
          el.className = 'spark-input__divider';
          break;
      }
      els.push(el);
    }

    /**
     * Replace the date input with three date dropdowns. Keep the date input around and store the
     * select data in there.
     */
  }, {
    key: "_initializeSelectPiece",
    value: function _initializeSelectPiece(els, part) {
      this.selects = this.selects || {};
      this.selectEls = this.selectEls || [];
      if (['day', 'month', 'year'].indexOf(part.name) === -1) {
        return;
      }
      var el;
      switch (part.name) {
        case 'day':
        case 'month':
          this.selects[part.name] = new _dateSelect.default({
            type: part.name,
            ariaLabelPrefix: this.selectLabelPrefix,
            onChange: this._onPieceChangeBound
          });
          el = this.selects[part.name].select.el;
          break;
        case 'year':
          {
            var minYear = this.inputEl.min ? parsedDomFormat.getValues(this.inputEl.min).year : null;
            var maxYear = this.inputEl.max ? parsedDomFormat.getValues(this.inputEl.max).year : null;
            this.selects[part.name] = new _dateSelect.default({
              min: minYear,
              max: maxYear,
              type: part.name,
              ariaLabelPrefix: this.selectLabelPrefix,
              onChange: this._onPieceChangeBound
            });
            el = this.selects[part.name].select.el;
            break;
          }
      }
      els.push(el);
      this.selectEls.push(el);
    }

    /**
     * If our element is a label, convert it to a div so that
     * we are semantically correct. Can't have more than one
     * input inside of a label!
     */
  }, {
    key: "_convertLabel",
    value: function _convertLabel() {
      if (this.isTypeahead || this.el.nodeName.toLowerCase() !== 'label') {
        return;
      }
      var newEl = document.createElement('fieldset');
      (0, _copyAttributes.default)(this.el, newEl);
      (0, _appendChildren.default)(newEl, this.el.children);
      if (this.el.parentNode) {
        this.el.parentNode.replaceChild(newEl, this.el);
      }
      this.el = newEl;
    }

    /**
     * Validate the date values.
     */
  }, {
    key: "_validate",
    value: function _validate() {
      if (this.isTypeahead) {
        this._validateTypeaheads();
      } else if (this.isSelect) {
        this._validateSelects();
      }
    }

    /**
     * Validate the typeahead values.
     */
  }, {
    key: "_validateTypeaheads",
    value: function _validateTypeaheads() {
      if (!this.typeaheads) {
        return;
      }
      var month = this.typeaheads.month ? this.typeaheads.month.getValue(true) : null;
      var year = this.typeaheads.year ? this.typeaheads.year.getValue(true) : null;
      var yearPrecision = this.typeaheads.year ? this.typeaheads.year.typeahead.format.length : null;
      var day = this.typeaheads.day ? this.typeaheads.day.getValue(true) : null;
      var maxDay;
      if (this.format === 'DD-MM-YYYY') {
        // this is in format YYYY-MM-DD
        var selectedDate = new Date(this.inputEl.value);
        var selectedMonth = selectedDate.getMonth() + 1;

        // If selectedDate and selectedMonth are not valid values, return. Otherwise
        // we end up with incorrect maxDay as it is based on a non-existent month.
        // This happens when values change in Date Range Inputs and a field needs
        // to be cleared. Otherwise maxDay will provide a value when there is no month
        // to go with it resulting in cleared month and year but not day.
        if (isNaN(selectedMonth)) {
          return;
        }
        if (month === null || month === '') {
          maxDay = this._getMaxDaysInMonth(selectedMonth);
        } else {
          var oldVal = new Date(this.currValue);
          var oldMonth = oldVal.getMonth() + 1;
          if (selectedMonth !== oldMonth) {
            maxDay = this._getMaxDaysInMonth(selectedMonth);
          } else {
            maxDay = month && new Date(year !== null ? year : new Date().getFullYear(), month, 0).getDate() || this._getMaxDaysInMonth(month);
          }
        }
      } else {
        if (month && (0, _isInteger.default)(year) && year.toString().length === yearPrecision) {
          maxDay = new Date(year, month, 0).getDate();
        } else {
          // If the month is blank we cannot validate the day. This happens when
          // values change in Date Range Inputs and a field needs to be cleared.
          // Otherwise maxDay will provide a value when there is no month to go
          // with it resulting in cleared month and year but not day
          if (month === '' || month === null) {
            return;
          }
          maxDay = this._getMaxDaysInMonth(month);
        }
      }

      // only update _userEnteredDay entered value if the currently active input is also day element
      if (day !== null && document.activeElement === this.typeaheads.day.el.querySelector('input')) {
        this._userEnteredDay = day;
      }

      // which day value should maxDay be tested against.
      var _testDay = this._userEnteredDay || day;

      // if maxDay is less than test day OR if the _userEnteredDay is equal to the maxDay and it's a proper year then set it back to the proper date
      // this second part resets the value to what the user originally entered in case that a user types in 02-29-2019, this would change the value to 02-28-2019
      // then if the user corrects the year only, to 02-28-2020, this will reset it to the 02-29-2020 as the user originally type in the 29 as a value.
      if (maxDay < _testDay || maxDay === this._userEnteredDay && year && year.toString().length === yearPrecision) {
        this.typeaheads.day.setValue(maxDay);
        this.updateInput();
      }
    }

    /**
     * Validate the boundaries of the typeahead values relative to the min and max values.
     */
  }, {
    key: "_validateTypeaheadBounds",
    value: function _validateTypeaheadBounds() {
      var year = this.typeaheads.year ? this.typeaheads.year.getValue(true) : null;
      var month = this.typeaheads.month ? this.typeaheads.month.getValue(true) : null;
      var day = this.typeaheads.day ? this.typeaheads.day.getValue(true) : null;
      if (!year || !month || !day) {
        return;
      }
      var date = new Date(year, month - 1, day);
      var set = '';
      if (this.min && date < new Date(this.min.year, this.min.month - 1, this.min.day)) {
        set = 'min';
      } else if (this.max && date > new Date(this.max.year, this.max.month - 1, this.max.day)) {
        set = 'max';
      }
      if (set) {
        this.typeaheads.year.setValue((0, _pad.default)(this[set].year, this.typeaheads.year.typeahead.format.length));
        this.typeaheads.month.setValue((0, _pad.default)(this[set].month, this.typeaheads.month.typeahead.format.length));
        this.typeaheads.day.setValue((0, _pad.default)(this[set].day, this.typeaheads.day.typeahead.format.length));
        this.updateInput();
      }
    }

    /**
     * Pad the typeahead input values.
     */
  }, {
    key: "_padTypeaheads",
    value: function _padTypeaheads() {
      if (this._pauseInputChange) return;
      this._pauseInputChange = true;
      for (var i in this.typeaheads) {
        this._padTypeahead(this.typeaheads[i]);
      }
      this._pauseInputChange = false;
    }

    /**
     * Pad the typeahead input values.
     * @param {Typeahead} typeahead
     */
  }, {
    key: "_padTypeahead",
    value: function _padTypeahead(typeahead) {
      var value = typeahead.getValue();
      if (value) {
        var padded = (0, _pad.default)(value, typeahead.typeahead.format.length);
        if (value !== padded) typeahead.setValue((0, _pad.default)(value, typeahead.typeahead.format.length));
      }
    }

    /**
     * Do any of the typeaheads have a value?
     * @return {Boolean}
     */
  }, {
    key: "_hasTypeaheadValue",
    value: function _hasTypeaheadValue() {
      for (var i in this.typeaheads) {
        if (this.typeaheads[i].getValue(true)) {
          this.isActive = true;
          return true;
        }
      }
      return false;
    }

    /**
     * Validate select input values.
     */
  }, {
    key: "_validateSelects",
    value: function _validateSelects() {
      if (!this.selects) {
        return;
      }
      var month = this.selects.month ? this.selects.month.getValue(true) : null;
      var year = this.selects.year ? this.selects.year.getValue(true) : null;
      var maxDay = month && new Date(year !== null ? year : new Date().getFullYear(), month, 0).getDate() || this._getMaxDaysInMonth(month);
      var day = this.selects.day ? this.selects.day.getValue(true) : null;
      this.selects.day.setOptions({
        max: maxDay
      });
      if (maxDay < day) {
        this.selects.day.setValue(maxDay);
      }
      this.updateInput();
    }

    /**
     * Get the maximum number of days for a given month.
     * @param {Number} month The month's number. 1-12.
     * @return {Number} The maximum number of days. 28-31.
     */
  }, {
    key: "_getMaxDaysInMonth",
    value: function _getMaxDaysInMonth(month) {
      if (month === 2) return 29;else if ([4, 6, 9, 11].indexOf(month) !== -1) return 30;
      return 31;
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because them.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onTypeaheadBlurBound = this._onTypeaheadBlur.bind(this);
      this._onTypeaheadInputBound = this._onTypeaheadInput.bind(this);
      this._onTypeaheadFocusBound = this._onTypeaheadFocus.bind(this);
      this._onPieceChangeBound = this._onPieceChange.bind(this);
      this._onTypeaheadBackspaceBound = this._onTypeaheadBackspace.bind(this);
      this._onTypeaheadEndBound = this._onTypeaheadEnd.bind(this);
      this._onInputChangeBound = this._onInputChange.bind(this);
      this._onVisibleChildrenBound = this._onVisibleChildren.bind(this);
    }

    /**
     * Add event listeners.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.el.addEventListener('click', this._onClickBound);
      this.inputEl.addEventListener('change', this._onInputChangeBound);
      document.addEventListener('spark.visible-children', this._onVisibleChildrenBound, true);
    }

    /**
     * Remove event listeners.
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.el.removeEventListener('click', this._onClickBound);
      this.inputEl.removeEventListener('change', this._onInputChangeBound);
      document.removeEventListener('spark.visible-children', this._onVisibleChildrenBound, true);
    }

    /**
     * Handle the spark.visible-children event
     * @param {Object} e
     */
  }, {
    key: "_onVisibleChildren",
    value: function _onVisibleChildren(e) {
      if (e.target.contains(this.el)) {
        window.setTimeout(function () {
          this.update();
        }.bind(this), 0);
      }
    }

    /**
     * Run all typeaheads so they have placeholder values.
     */
  }, {
    key: "_runTypeaheads",
    value: function _runTypeaheads() {
      // Make sure we don't get into an infinite loop. Even though the logic
      // in the typeaheads should be stopping this from happening, there is
      // something in Safari where the focus and blur events fire in different
      // order than other browsers so those failsafes do not work.
      if (this.runningTypeaheads) {
        return;
      }
      this.runningTypeaheads = true;
      if (this.inFocus) {
        this.inFocus.pause();
      }
      for (var i in this.typeaheads) {
        if (this.typeaheads[i] !== this.inFocus) {
          this.typeaheads[i].run();
        }
      }
      if (this.inFocus) {
        this.inFocus.resume();
        this.inFocus.run();
      }
      this.runningTypeaheads = false;
    }

    /**
     * Update the active and focus classes.
     */
  }, {
    key: "_updateClass",
    value: function _updateClass() {
      (0, _toggleClass.default)(this.el, 'active', this.isActive);
      (0, _toggleClass.default)(this.el, 'has-partial-value', this.hasPartialValue());
      (0, _toggleClass.default)(this.el, 'focus', this.inFocus ? true : false);
    }

    /**
     * Get the typeahead that corresponds to the given element.
     * @param {Element} el
     * @return {Object}
     */
  }, {
    key: "_getTypeaheadByElement",
    value: function _getTypeaheadByElement(el) {
      for (var i in this.typeaheads) {
        if (this.typeaheads[i].typeahead.el === el) {
          return this.typeaheads[i];
        }
      }
    }

    /**
     * Show the date as text.
     */
  }, {
    key: "_showDateText",
    value: function _showDateText() {
      var text = this._getDateText();
      if (!text || !this.showDateAsText) {
        return;
      }
      if (!this.dateTextEl) {
        this._createDateTextEl();
      }
      this.dateTextEl.innerHTML = text;
      this.dateTextEl.style.display = '';
    }

    /**
     * Hide the date as text.
     */
  }, {
    key: "_hideDateText",
    value: function _hideDateText() {
      if (!this.showDateAsText || !this.dateTextEl) {
        return;
      }
      this.dateTextEl.style.display = 'none';
    }

    /**
     * Create the date text element.
     */
  }, {
    key: "_createDateTextEl",
    value: function _createDateTextEl() {
      var el = document.createElement('div');
      el.className = 'spark-input__overlay';
      el.style.display = 'none';
      this.el.appendChild(el);
      this.dateTextEl = el;
    }

    /**
     * Get the date as text.
     */
  }, {
    key: "_getDateText",
    value: function _getDateText() {
      var parts = this.parsedTextFormat.parts;
      var i = 0;
      var len = parts.length;
      var str = '';
      var isValid = true;
      var val;
      for (; i < len; i++) {
        val = this.typeaheads[parts[i].name] && this.typeaheads[parts[i].name].getValue();
        switch (parts[i].name) {
          case 'month':
            str += _date.default.getMonthNameShort(val);
            if (!val) {
              isValid = false;
              break;
            }
            break;
          case 'day':
          case 'year':
            str += val;
            if (!val) {
              isValid = false;
              break;
            }
            break;
          default:
            str += parts[i].value;
            break;
        }
      }
      return isValid ? str : false;
    }

    /**
     * When the value of a typeahead or select changes, validate.
     * @param {Number} val
     * @param {Object} typeahead
     */
  }, {
    key: "_onPieceChange",
    value: function _onPieceChange() {
      this._validate();
      if (this.isTypeahead && this.showDateAsText && !this._hasFocus) {
        if (this._showTextTimer) {
          clearTimeout(this._showTextTimer);
        }
        this._showTextTimer = setTimeout(function () {
          this._showDateText();
        }.bind(this), 0);
      }
    }

    /**
     * When the typeahead gains focus.
     * @param {Number} val
     * @param {Object} typeahead
     */
  }, {
    key: "_onTypeaheadFocus",
    value: function _onTypeaheadFocus(val, typeahead) {
      if (this.runningTypeaheads) return;
      this._hideDateText();
      if (!this._hasFocus) {
        this._hasFocus = true;
        (this.onFocus || noop)(this.inputEl.value, this);
      }
      (0, _triggerEvent.default)(this.inputEl, 'focus');
      this.inFocus = typeahead;
      this.show();
      this._updateClass();
      if (this._blurTimer) {
        clearTimeout(this._blurTimer);
        this._blurTimer = null;
      }
    }

    /**
     * When the typeahead loses focus, make sure numbers are padded properly.
     * @param {Number} val
     * @param {Object} typeahead
     */
  }, {
    key: "_onTypeaheadBlur",
    value: function _onTypeaheadBlur(val, typeahead) {
      if (this.runningTypeaheads) return;
      this.inFocus = null;
      this._padTypeahead(typeahead);
      this.updateInput();
      if (!this.inputEl.value && !this._hasTypeaheadValue()) {
        this.hide();
      } else {
        this._validateTypeaheadBounds();
      }
      this._updateClass();
      this._blurTimer = setTimeout(function () {
        this._hasFocus = false;
        (this.onBlur || noop)(this.inputEl.value, this);
        this._showDateText();
      }.bind(this), 1);
    }

    /**
     * `input` event callback for typeahead
     */
  }, {
    key: "_onTypeaheadInput",
    value: function _onTypeaheadInput() {
      (this.onInput || noop)(this.getTypingValue(), this);
    }

    /**
     * When the typeahead fires a backspace event, move back to the previous input.
     * @param {Number} val
     * @param {Object} typeahead
     */
  }, {
    key: "_onTypeaheadBackspace",
    value: function _onTypeaheadBackspace() {
      this.focusPrevious();
    }

    /**
     * When the typeahead is at its maximum length and the caret is at the end,
     * focus on the next input field.
     * @param {Object} typeahead
     * @param {String} character Optional
     */
  }, {
    key: "_onTypeaheadEnd",
    value: function _onTypeaheadEnd(typeahead, character) {
      this.focusNext(character);
    }

    /**
     * When the input that corresponds to this instance changes. Allows us to listen
     * and respond to changes made by other components (Calendar Popover, for example).
     * @param {Object} e
     */
  }, {
    key: "_onInputChange",
    value: function _onInputChange(e) {
      if (this.isTypeahead) {
        this.isActive = e.target.value ? true : false;
        this._updateClass();
      }
      if (this._pauseInputChange) return;
      this.setValue(parsedDomFormat.getValues(e.target.value));
      (this.onChange || noop)(this.inputEl.value, this);
    }

    /**
     * When the input group is clicked, focus on the first typeahead
     * if we don't already have focus.
     * @todo : we should still replace the label on typeaheads and use this,
     * but we need a way to focus on the closest element to a click.
     * @param {Object} e
     */
  }, {
    key: "_onClick",
    value: function _onClick() {
      /* if (this.isTypeahead || this.inFocus || this.isActive || getParent(e.target, '.spark-input__addon')) {
        return;
      }
       let input = this.typeaheadEls[0].querySelector('input');
       if (input) {
        input.focus();
      }*/
    }
  }]);
  return DateInput;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
DateInput.prototype._whitelistedParams = ['validate', 'onValidate', 'onChange', 'onInput', 'onFocus', 'onBlur', 'isTypeahead', 'isSelect', 'format', 'textFormat', 'showDateAsText', 'min', 'max'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
DateInput.prototype.defaults = {
  el: null,
  inputEl: null,
  messageEl: null,
  piecesEl: null,
  toggleEl: null,
  inFocus: null,
  isActive: null,
  isSelect: null,
  isTypeahead: null,
  typeaheads: null,
  typeaheadEls: null,
  selects: null,
  selectEls: null,
  format: null,
  parsedFormat: null,
  showDateAsText: null,
  textFormat: null,
  runningTypeaheads: false,
  onValidate: null,
  onChange: null,
  onInput: null,
  onFocus: null,
  onBlur: null,
  _hasFocus: false,
  _pauseInputChange: false,
  _onClickBound: null,
  _onPieceChangeBound: null,
  _onTypeaheadFocusBound: null,
  _onTypeaheadBlurBound: null,
  _onTypeaheadInputBound: null,
  _onTypeaheadBackspaceBound: null,
  _onTypeaheadEndBound: null,
  _onInputChangeBound: null
};
(0, _mixin.default)(DateInput.prototype, _messaging.default, _validation.default);
var _default = DateInput;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/date/date":57,"../helpers/date/parse-format":58,"../helpers/dom/add-class":59,"../helpers/dom/has-class":61,"../helpers/dom/make-element":62,"../helpers/dom/parse-attribute":66,"../helpers/dom/remove-class":67,"../helpers/dom/toggle-class":68,"../helpers/dom/trigger-event":69,"../helpers/manipulation/append-children":73,"../helpers/manipulation/copy-attributes":74,"../helpers/util/each":94,"../helpers/util/mixin":96,"../helpers/util/pad":98,"../mixins/messaging":104,"../mixins/validation":105,"./base":3,"./date-select":9,"./date-typeahead":10,"@babel/runtime-corejs3/core-js-stable/number/is-integer":120,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],9:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _selectInput = _interopRequireDefault(require("./select-input"));
var _date = _interopRequireDefault(require("../helpers/date/date"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _parseAttribute = require("../helpers/dom/parse-attribute");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # DateSelect
                                                                                                                                                                                                                                                                                                                                              * Create a select list of days, months or years.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new DateSelect(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/date-select.js
                                                                                                                                                                                                                                                                                                                                              */
function createDefaultElement() {
  var el = document.createElement('span');
  el.className = 'spark-select';
  el.innerHTML = '<select class="spark-select__input"></select><span class="spark-label"></span>';
  return el;
}
var DateSelect = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(DateSelect, _BaseComponent);
  var _super = _createSuper(DateSelect);
  /**
   * DateSelect constructor
   * @param {Element} el Optional
   * @param {Object} params Optional
   */
  function DateSelect(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, DateSelect);
    // If the first argument is a plain object, create a default element
    // since the user MUST provide additional params but the element
    // is optional. Doing it this way to keep the arity the same
    // as other components.
    if (!(el instanceof HTMLElement)) {
      params = el || {};
      el = createDefaultElement();
    }
    _this = _super.call(this, el, params);
    _this._bindEventListenerCallbacks();
    _this._createSelect(el);
    return _this;
  }

  /**
   * Get the value.
   * @param {Boolean} asInt Get the value as a parsed integer.
   * @return {Mixed}
   */
  (0, _createClass2.default)(DateSelect, [{
    key: "getValue",
    value: function getValue(asInt) {
      return asInt ? parseInt(this.select.getValue(), 10) : this.select.getValue();
    }

    /**
     * Set the value.
     * @param {Mixed} val
     */
  }, {
    key: "setValue",
    value: function setValue(val) {
      return this.select.setValue(val);
    }

    /**
     * Clear the value.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      return this.select.clearValue();
    }

    /**
     * Enable the input.
     */
  }, {
    key: "enable",
    value: function enable() {
      return this.select.enable();
    }

    /**
     * Disable the input.
     */
  }, {
    key: "disable",
    value: function disable() {
      return this.select.disable();
    }

    /**
     * Update the date select's options.
     * @param {Object|Array} params
     */
  }, {
    key: "setOptions",
    value: function setOptions(params) {
      params = params || {};
      this.min = params.min || this.min;
      this.max = params.max || this.max;
      this.monthNames = params.monthNames || this.monthNames;
      this.numericMonth = params.numericMonth || this.numericMonth;
      if (this.type === 'year') {
        if (params.min && !params.max) {
          this.max = this.min + 100;
        } else if (params.max && !params.min) {
          this.min = this.max - 100;
        }
      }
      var i = this.min ? this.min - 1 : 0;
      var len = this.max || this.monthNames.length;
      var opts = [{}];
      for (; i < len; i++) {
        opts.push({
          value: i + 1,
          text: this.monthNames ? this.monthNames[i] : i + 1
        });
      }
      this.select.setOptions(opts);
      return this;
    }

    /**
     * Set the label text for the select input.
     * @param {String} text Optional
     */
  }, {
    key: "setLabel",
    value: function setLabel(text) {
      this.select.setLabel(text !== undefined ? text : this._getTypeText());
      return this;
    }

    /**
     * Create a select input helper.
     * @param {Object} el
     */
  }, {
    key: "_createSelect",
    value: function _createSelect(el) {
      this.select = new _selectInput.default(el, {
        onChange: this._onSelectChangeBound,
        onFocus: this._onSelectFocusBound,
        onBlur: this._onSelectBlurBound,
        onKeydown: this._onSelectKeydownBound,
        onClick: this._onSelectClick
      });
      this.setOptions();
      this.setLabel();

      // Ensure we have an ARIA labelledby attribute
      var select = el.querySelector('select');
      if (select && !select.getAttribute('aria-labelledby')) {
        var selectLabel = el.querySelector('.spark-label');
        var labelID = 'spark-aria__' + this.ariaLabelPrefix + '--suffix-' + this.type;
        if (selectLabel !== null && labelID !== null) {
          selectLabel.setAttribute('id', labelID);
          select.setAttribute('aria-labelledby', this.ariaLabelPrefix + ' ' + labelID);
        }
      }
    }

    /**
     * Cache elements.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.selectEl = this.el.querySelector('select');
    }

    /**
     * Parse parameters from the elements.
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      this.type = this.type !== null ? this.type : (0, _parseAttribute.string)(this.selectEl, 'data-type', 'day');
      this.ariaLabelPrefix = this.ariaLabelPrefix !== null ? this.ariaLabelPrefix : null;
      if (this.type === 'year') {
        var date = new Date();
        this.min = this.min !== null ? this.min : (0, _parseAttribute.number)(this.selectEl, 'min', date.getFullYear() - 100);
        this.max = this.max !== null ? this.max : (0, _parseAttribute.number)(this.selectEl, 'max', (this.min || date.getFullYear()) + 100);
      } else if (this.type === 'month') {
        this.monthNames = this.monthNames !== null ? this.monthNames : (0, _parseAttribute.string)(this.selectEl, 'data-month-names', null);
        this.numericMonth = this.numericMonth !== null ? this.numericMonth : (0, _parseAttribute.boolean)(this.selectEl, 'data-numeric-month', false);
        this.min = this.min !== null ? this.min : (0, _parseAttribute.number)(this.selectEl, 'min', null);
        this.max = this.max !== null ? this.max : (0, _parseAttribute.number)(this.selectEl, 'max', null);

        // No monthNames yet and no min or max
        if (!this.monthNames && !this.numericMonth && !this.min && !this.max) {
          this.monthNames = this._getDefaultMonthNames();
        } else if (!this.min && !this.max) {
          this.min = 1;
          this.max = 12;
        }
        if (typeof this.monthNames === 'string') {
          this.monthNames = this.monthNames.split(',');
        }
      } else {
        this.min = this.min !== null ? this.min : (0, _parseAttribute.number)(this.selectEl, 'min', 1);
        this.max = this.max !== null ? this.max : (0, _parseAttribute.number)(this.selectEl, 'max', 31);
      }
    }

    /**
     * Make a list of month options.
     * @return {Array}
     */
  }, {
    key: "_getDefaultMonthNames",
    value: function _getDefaultMonthNames() {
      return _date.default.getMonthNamesShort();
    }

    /**
     * Get the text for this type of date select.
     * @return {String}
     */
  }, {
    key: "_getTypeText",
    value: function _getTypeText() {
      var _context;
      return this.type.charAt(0).toUpperCase() + (0, _slice.default)(_context = this.type).call(_context, 1);
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onSelectChangeBound = this._onSelectChange.bind(this);
      this._onSelectFocusBound = this._onSelectFocus.bind(this);
      this._onSelectBlurBound = this._onSelectBlur.bind(this);
      this._onSelectKeydownBound = this._onSelectKeydown.bind(this);
    }

    /**
     * When the select changes, run the callback.
     * @param {String} val The value of the input
     */
  }, {
    key: "_onSelectChange",
    value: function _onSelectChange(val) {
      // Remove placeholder-hiding class
      (0, _removeClass.default)(this.el, 'hide-date-select-placeholder');
      this.onChange.call(this, val, this);
    }

    /**
     * When the select changes, run the callback.
     * @param {String} val The value of the input
     */
  }, {
    key: "_onSelectFocus",
    value: function _onSelectFocus(val) {
      this.onFocus.call(this, val, this);
    }

    /**
     * When the select changes, run the callback.
     * @param {String} val The value of the input
     */
  }, {
    key: "_onSelectBlur",
    value: function _onSelectBlur(val) {
      // Remove placeholder-hiding class
      (0, _removeClass.default)(this.el, 'hide-date-select-placeholder');
      this.onBlur.call(this, val, this);
    }

    /**
     * When a key is pressed and it is an arrow key, check whether the placeholder should be hidden
     * @param {Event} e
     * @param {String} val The current value of the Select input
     * @param {Object} select The instance of the Select component
     */
  }, {
    key: "_onSelectKeydown",
    value: function _onSelectKeydown(e, val, select) {
      // In Windows Chrome, using arrow keys (or Enter followed by arrow keys) to select
      // an option causes overlap of text between the selected option and placeholder if
      // an initial value was not set.
      if (navigator.userAgent.indexOf('Windows') > -1) {
        var ENTER_KEY_CODE = 13;
        var ARROW_LEFT_KEY_CODE = 37;
        var ARROW_UP_KEY_CODE = 38;
        var ARROW_RIGHT_KEY_CODE = 39;
        var ARROW_DOWN_KEY_CODE = 40;

        // If the arrow keys are used to navigate the dropdown list and no value has been selected yet, hide the placeholder text to prevent text overlap in IE
        if (!select.hasValue && (e.keyCode === ENTER_KEY_CODE || e.keyCode === ARROW_LEFT_KEY_CODE || e.keyCode === ARROW_UP_KEY_CODE || e.keyCode === ARROW_RIGHT_KEY_CODE || e.keyCode === ARROW_DOWN_KEY_CODE)) {
          (0, _toggleClass.default)(this.el, 'hide-date-select-placeholder', !select.hasValue);
        }
      }
    }

    /**
     * When the mouse is clicked determine whether the placeholder should be hidden
     * @param {Event} e
     * @param {String} val The current value of the Select input
     * @param {Object} select The instance of the Select component
     */
  }, {
    key: "_onSelectClick",
    value: function _onSelectClick(e, val, select) {
      // If Windows Edge using the mouse to click the dropdown list causes overlap of
      // selection and placeholder text. This happens only if an initial value has not
      // already been set i.e. placeholder text is showing
      if (navigator.userAgent.indexOf('Windows') > -1) {
        if (!select.hasValue) {
          (0, _toggleClass.default)(this.el, 'hide-date-select-placeholder', !select.hasValue);
        }
      }
    }
  }]);
  return DateSelect;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
DateSelect.prototype._whitelistedParams = ['type', 'ariaLabelPrefix', 'monthNames', 'numericMonth', 'min', 'max', 'onChange', 'onFocus', 'onBlur'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
DateSelect.prototype.defaults = {
  el: null,
  selectEl: null,
  type: null,
  monthNames: null,
  min: null,
  max: null,
  select: null,
  numericMonth: null,
  onChange: function onChange() {},
  onFocus: function onFocus() {},
  onBlur: function onBlur() {},
  _onSelectChangeBound: null,
  _onSelectFocusBound: null,
  _onSelectBlurBound: null,
  _onSelectKeydownBound: null
};
var _default = DateSelect;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/date/date":57,"../helpers/dom/parse-attribute":66,"../helpers/dom/remove-class":67,"../helpers/dom/toggle-class":68,"./base":3,"./select-input":34,"@babel/runtime-corejs3/core-js-stable/instance/slice":115,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],10:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _typeahead = _interopRequireDefault(require("./typeahead"));
var _parseAttribute = require("../helpers/dom/parse-attribute");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # DateTypeahead
                                                                                                                                                                                                                                                                                                                                              * Listen to an input element and format it as the user types.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new DateTypeahead(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/date-typeahead.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
function createDefaultElement() {
  var el = document.createElement('span');
  el.className = 'spark-input';
  return el;
}
var DateTypeahead = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(DateTypeahead, _BaseComponent);
  var _super = _createSuper(DateTypeahead);
  /**
   * DateTypeahead constructor
   * @param {Element} el Optional
   * @param {Object} params Optional
   */
  function DateTypeahead(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, DateTypeahead);
    // If only one arg passed, assume it was a parameters
    // object since the user MUST provide those but the element
    // is optional. Doing it this way to keep the arity the same
    // as other components.
    if (arguments.length < 2) {
      params = el || {};
      el = createDefaultElement();
    }
    _this = _super.call(this, el, params);
    _this._bindEventListenerCallbacks();
    _this._createTypeahead(el, params);
    return _this;
  }

  /**
   * Get the value.
   * @param {Boolean} asInt Get the value as a parsed integer.
   * @return {Mixed}
   */
  (0, _createClass2.default)(DateTypeahead, [{
    key: "getValue",
    value: function getValue(asInt) {
      return this.typeahead.getValue(asInt);
    }

    /**
     * Set the value.
     * @param {Mixed} val
     */
  }, {
    key: "setValue",
    value: function setValue(val) {
      return this.typeahead.setValue(val);
    }

    /**
     * Clear the value.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      return this.typeahead.clearValue();
    }

    /**
     * Enable the input.
     */
  }, {
    key: "enable",
    value: function enable() {
      return this.typeahead.enable();
    }

    /**
     * Disable the input.
     */
  }, {
    key: "disable",
    value: function disable() {
      return this.typeahead.disable();
    }

    /**
     * Run the typeahead calculations.
     */
  }, {
    key: "run",
    value: function run() {
      return this.typeahead.run();
    }

    /**
     * Pause the typeahead events.
     */
  }, {
    key: "pause",
    value: function pause() {
      return this.typeahead.pause();
    }

    /**
     * Reseume typeahead events.
     */
  }, {
    key: "resume",
    value: function resume() {
      return this.typeahead.resume();
    }

    /**
     * Augment default remove call w/ helper cleanup.
     * @param {Boolean} leaveElement Leave the element intact.
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      this.typeahead.remove(leaveElement);
      (0, _get2.default)((0, _getPrototypeOf2.default)(DateTypeahead.prototype), "remove", this).call(this, leaveElement);
      return this;
    }

    /**
     * Cache elements.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
    }

    /**
     * Parse parameters from the elements.
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      this.type = this.type !== null ? this.type : (0, _parseAttribute.string)(this.el, 'data-type', 'day');
      this.format = this.format !== null ? this.format : (0, _parseAttribute.string)(this.el, 'data-format', null);
      this.placeholder = this.placeholder !== null ? this.placeholder : (0, _parseAttribute.string)(this.el, 'data-placeholder', null);
      this.len = this.len !== null ? this.len : (0, _parseAttribute.number)(this.el, 'length', null);
      this.ariaLabelPrefix = this.ariaLabelPrefix !== null ? this.ariaLabelPrefix : null;
      if (!this.placeholder) {
        throw new Error('You must provide a placeholder value for a DateTypeahead.');
      }
      if (this.len !== null) {
        this.format = this._lengthToFormat(this.len);
      }
      if (!this.format) {
        throw new Error('You must provide a format value for a DateTypeahead.');
      }
    }

    /**
     * Create a typeahead with the given format.
     * @param {Object} el
     */
  }, {
    key: "_createTypeahead",
    value: function _createTypeahead(el) {
      this.typeahead = new _typeahead.default(el, {
        placeholder: this.placeholder,
        format: this.format,
        matchPlaceholderSize: true,
        onChange: this._onTypeaheadChangeBound,
        onInput: this._onTypeaheadInputBound,
        onFocus: this._onTypeaheadFocusBound,
        onBlur: this._onTypeaheadBlurBound,
        onBackspace: this._onTypeaheadBackspaceBound,
        onEnd: this._onTypeaheadEndBound
      });

      // Ensure we have an ARIA label
      var input = el.querySelector('input');
      if (input && !input.getAttribute('aria-label')) {
        input.setAttribute('aria-label', this.ariaLabelPrefix + ' ' + this.type);
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onTypeaheadChangeBound = this._onTypeaheadChange.bind(this);
      this._onTypeaheadInputBound = this._onTypeaheadInput.bind(this);
      this._onTypeaheadFocusBound = this._onTypeaheadFocus.bind(this);
      this._onTypeaheadBlurBound = this._onTypeaheadBlur.bind(this);
      this._onTypeaheadBackspaceBound = this._onTypeaheadBackspace.bind(this);
      this._onTypeaheadEndBound = this._onTypeaheadEnd.bind(this);
    }

    /**
     * Take a length and return a format string with that many digits.
     * @param {Number} length
     * @return {String}
     */
  }, {
    key: "_lengthToFormat",
    value: function _lengthToFormat(length) {
      var i = 0;
      var ret = '';
      for (; i < length; i++) {
        ret += '\\d';
      }
      return ret;
    }

    /**
     * Check to see if an input value is valid.
     * @param {Mixed} val
     * @param {Boolean} allowEmpty All the value to be empty instead of 0.
     */
  }, {
    key: "_checkValidity",
    value: function _checkValidity(val, allowEmpty) {
      val = parseInt(val, 10);
      var origVal = val;
      var isNumber = !isNaN(val);

      // If we were passed an empty string or something, don't try to validate.
      // Treat zeros as a non-entry for days and months.
      if (isNumber) {
        if (this.type === 'year') {
          val = val === 0 ? allowEmpty ? '' : 0 : Math.max(val, 0);
        } else if (this.type === 'month') {
          val = val ? Math.min(Math.max(val, 1), 12) : allowEmpty ? '' : 0;
        } else {
          val = val ? Math.min(Math.max(val, 1), 31) : allowEmpty ? '' : 0;
        }
      }

      // Need to make sure we aren't looping forever on these updates.
      if (isNumber && val !== origVal) {
        this.typeahead.setValue(val + '');
        return false;
      }
      return true;
    }

    /**
     * When the typeahead changes, make sure the value is valid. This
     * is very basic validation. More complex validation like the number
     * of days in a specific month should be handled by the callback.
     * And run our callback.
     * @param {String} val The value of the input
     * @param {String} oldVal The previous value
     */
  }, {
    key: "_onTypeaheadChange",
    value: function _onTypeaheadChange(val) {
      if (this._checkValidity(val)) {
        (this.onChange || noop)(val, this);
      }
    }

    /**
     * Callback for `input` event
     * @param {String} val The value of the input
     * @param {String} oldVal The previous value
     *
     */
  }, {
    key: "_onTypeaheadInput",
    value: function _onTypeaheadInput(val) {
      (this.onInput || noop)(val, this);
    }

    /**
     * When the typeahead gains focus, let anyone who is interested know.
     * @param {String} val
     */
  }, {
    key: "_onTypeaheadFocus",
    value: function _onTypeaheadFocus(val) {
      (this.onFocus || noop)(val, this);
    }

    /**
     * When the typeahead loses focus, let anyone who is interested know.
     * @param {String} val
     */
  }, {
    key: "_onTypeaheadBlur",
    value: function _onTypeaheadBlur(val) {
      this._checkValidity(val, true);
      (this.onBlur || noop)(val, this);
    }

    /**
     * When the typeahead fires a backspace event because it's empty and
     * the user is hitting backspace, let anyone who is interested know.
     * @param {String} val
     */
  }, {
    key: "_onTypeaheadBackspace",
    value: function _onTypeaheadBackspace(val) {
      (this.onBackspace || noop)(val, this);
    }

    /**
     * When the typeahead is full and at its end, let anyone who is interested know.
     * @param {Object} typeahead
     * @param {String} character Optional The character to pass to the next input.
     */
  }, {
    key: "_onTypeaheadEnd",
    value: function _onTypeaheadEnd(typeahead, character) {
      (this.onEnd || noop)(this, character);
    }
  }]);
  return DateTypeahead;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
DateTypeahead.prototype._whitelistedParams = ['type', 'format', 'ariaLabelPrefix', 'placeholder', 'len', 'onChange', 'onInput', 'onFocus', 'onBlur', 'onBackspace', 'onEnd'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
DateTypeahead.prototype.defaults = {
  el: null,
  type: null,
  ariaLabelPrefix: null,
  typeahead: null,
  format: null,
  placeholder: null,
  len: null,
  onChange: null,
  onInput: null,
  onFocus: null,
  onBlur: null,
  onBackspace: null,
  onEnd: null,
  _onTypeaheadChangeBound: null,
  _onTypeaheadInputBound: null,
  _onTypeaheadFocusBound: null,
  _onTypeaheadBlurBound: null,
  _onTypeaheadBackspaceBound: null,
  _onTypeaheadEndBound: null
};
var _default = DateTypeahead;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/parse-attribute":66,"./base":3,"./typeahead":50,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],11:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _height = _interopRequireDefault(require("../helpers/animation/height"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _getParent = _interopRequireDefault(require("../helpers/traversal/get-parent"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Expand
                                                                                                                                                                                                                                                                                                                                              * Expand and collapse an element.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Expand(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/expand.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var Expand = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(Expand, _BaseComponent);
  var _super = _createSuper(Expand);
  /**
   * Expand constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function Expand(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Expand);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Expand
   */
  (0, _createClass2.default)(Expand, [{
    key: "expand",
    value: function expand() {
      (this.onBeforeExpand || noop)();
      (0, _height.default)({
        el: this.el,
        toggleClass: 'expanded',
        toggleEl: '.spark-expand__content, .spark-panel__content'
      });
      this.isExpanded = true;
      this._updateClasses();
      var e = document.createEvent('Event');
      e.initEvent('spark.visible-children', true, true);
      this.el.dispatchEvent(e);

      // If the expand element have input, focus on the first one.
      if (this.el.querySelector('input')) {
        this.el.querySelector('input').focus();
      }
      (this.onAfterExpand || noop)();
      return this;
    }

    /**
     * Collapse
     */
  }, {
    key: "collapse",
    value: function collapse() {
      (this.onBeforeCollapse || noop)();
      (0, _height.default)({
        el: this.el,
        toggleEl: '.spark-expand__content, .spark-panel__content',
        toggleValue: 'none',
        action: 'collapse'
      });
      this.isExpanded = false;
      this._updateClasses();
      (this.onAfterCollapse || noop)();
      return this;
    }

    /**
     * Toggle the expand state.
     */
  }, {
    key: "toggle",
    value: function toggle() {
      return this[this.isExpanded ? 'collapse' : 'expand']();
    }

    /**
     * Store a reference to the element.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.isExpanded = (0, _hasClass.default)(this.el, 'expanded');
      this.accordionHeading = this.el.querySelector('[role="heading"]');
      this.accordionContent = this.el.querySelector('.spark-panel__content');
      this.panelContent = this.el.querySelector('.spark-expand__content');
      this.panelCollapsedButton = this.el.querySelector('.spark-expand__hide--expanded');
      this.panelExpandedButton = this.el.querySelector('.spark-expand__show--expanded');
    }

    /**
     * Update classes for the expand or collapse state.
     */
  }, {
    key: "_updateClasses",
    value: function _updateClasses() {
      (0, _toggleClass.default)(this.el, 'expanded', this.isExpanded);
      this._updateAriaAttributes();
    }

    /**
     * Update aria attributes for the expand or collapse state.
     */
  }, {
    key: "_updateAriaAttributes",
    value: function _updateAriaAttributes() {
      if (this.isExpanded) {
        this.accordionHeading ? this.accordionHeading.setAttribute('aria-expanded', 'true') : null;
        this.accordionContent ? this.accordionContent.setAttribute('aria-hidden', 'false') : null;
        this.panelContent ? this.panelContent.setAttribute('aria-hidden', 'false') : null;
        this.panelCollapsedButton ? this.panelCollapsedButton.setAttribute('aria-hidden', 'true') : null;
        this.panelExpandedButton ? this.panelExpandedButton.setAttribute('aria-hidden', 'false') : null;
      } else {
        this.accordionHeading ? this.accordionHeading.setAttribute('aria-expanded', 'false') : null;
        this.accordionContent ? this.accordionContent.setAttribute('aria-hidden', 'true') : null;
        this.panelContent ? this.panelContent.setAttribute('aria-hidden', 'true') : null;
        this.panelCollapsedButton ? this.panelCollapsedButton.setAttribute('aria-hidden', 'false') : null;
        this.panelExpandedButton ? this.panelExpandedButton.setAttribute('aria-hidden', 'true') : null;
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onClickBound = this._onClick.bind(this);
      this._onKeydownBound = this._onKeydown.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.el.addEventListener('click', this._onClickBound);
      this.el.addEventListener('keydown', this._onKeydownBound);
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.el.removeEventListener('click', this._onClickBound);
      this.el.removeEventListener('keydown', this._onKeydownBound);
    }

    /**
     * When we are clicked, toggle the expanded state.
     * @param {Object} e
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      if (!(0, _getParent.default)(e.target, '.spark-expand__toggle, [data-role="toggle"], [role="heading"]', this.el)) {
        return;
      }
      e.stopImmediatePropagation();
      e.preventDefault();
      this.toggle();
    }

    /**
     * When the space or enter key is pressed on the toggle, toggle!
     * @param {Object} e
     */
  }, {
    key: "_onKeydown",
    value: function _onKeydown(e) {
      if (!(0, _getParent.default)(e.target, '.spark-expand__toggle, [data-role="toggle"], [role="heading"]', this.el)) {
        return;
      }
      var code = e.keyCode || e.which;

      // Space or enter
      if (code === 32 || code === 13) {
        e.stopImmediatePropagation();
        e.preventDefault();
        this.toggle();
      }
    }
  }]);
  return Expand;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
Expand.prototype._whitelistedParams = ['onBeforeExpand', 'onAfterExpand', 'onBeforeCollapse', 'onAfterCollapse'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
Expand.prototype.defaults = {
  el: null,
  isExpanded: false,
  onBeforeExpand: null,
  onAfterExpand: null,
  onBeforeCollapse: null,
  onAfterCollapse: null,
  _onClickBound: null,
  _onKeydownBound: null
};
var _default = Expand;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/animation/height":52,"../helpers/dom/has-class":61,"../helpers/dom/toggle-class":68,"../helpers/traversal/get-parent":87,"./base":3,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],12:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _expand = _interopRequireDefault(require("./expand"));
var _modal = _interopRequireDefault(require("./modal"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Filter Module
                                                                                                                                                                                                                                                                                                                                              * Module that contains an individual (or related) filters such as checkboxes
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new FilterModule(el, params);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/filter-module.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var FilterModule = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(FilterModule, _BaseComponent);
  var _super = _createSuper(FilterModule);
  /**
   * Filter Module constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function FilterModule(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, FilterModule);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Store a reference to the need elements
   * @param {Element} el
   */
  (0, _createClass2.default)(FilterModule, [{
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this._showAllEl = this.el.querySelector('.spark-filter-module__show-all');
      if (this._showAllEl) {
        this._showAllToggleable = this._showAllEl.querySelector('span');
      }
      this._clearEls = this.el.querySelectorAll('.spark-filter-module__clear');
      this._hiddenEls = (0, _slice.default)(Array.prototype).call(this.el.querySelectorAll('.spark-filter-module--hide'));
      this._headerEl = this.el.querySelector('.spark-filter-module__header');
      this._bodyEl = this.el.querySelector('.spark-filter-module__body');
      this._modalEl = this.el.querySelector('.spark-modal');
      this._modalSaveBtn = this.el.querySelector('.spark-filter-module__show-all__modal-button');
      this._modalClasses = [];
      if (this.onShowAll === 'modal') {
        this.modalInst = new _modal.default(this._modalEl);
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onShowAllBound = this._onShowAll.bind(this);
      this._onClearBound = this._onClear.bind(this);
      this._onCloseModalBound = this._onCloseModal.bind(this);
    }

    /**
     * Add event listeners for touchstart and mouse click.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      !this._showAllEl || this._showAllEl.addEventListener('click', this._onShowAllBound);
      !this._modalSaveBtn || this._modalSaveBtn.addEventListener('click', this._onCloseModalBound);
      for (var i = 0; i < this._clearEls.length; i++) {
        !this._clearEls[i] || this._clearEls[i].addEventListener('click', this._onClearBound);
      }
    }

    /**
     * Remove event listeners for touchstart and mouse click.
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      if (this._showAllEl) {
        this._showAllEl.removeEventListener('click', this._onShowAllBound);
        this._modalSaveBtn.removeEventListener('click', this._onCloseModalBound);
        for (var i = 0; i < this._clearEls.length; i++) {
          !this._clearEls[i] || this._clearEls[i].removeEventListener('click', this._onClearBound);
        }
      }
    }

    /**
     * Show any hidden filters within a module or run provided function if available
     */
  }, {
    key: "_onShowAll",
    value: function _onShowAll() {
      if (typeof this.onShowAll === 'function') {
        (this.onShowAll || noop)(this);
      } else {
        if (this.onShowAll === 'toggle' || this.onShowAll === 'modal' && this._isExpand) {
          this._toggleShowAllLabel();
          this.toggleHiddenContent();
        } else if (this.onShowAll === 'modal' && !this._isExpand) {
          this.modalInst.open();
        }
        (this.onShowAllComplete || noop)();
      }
    }

    /**
     * Toggle Show More label text
     */
  }, {
    key: "_toggleShowAllLabel",
    value: function _toggleShowAllLabel() {
      this._showAllToggleable.innerHTML = this._showAllToggleable.innerHTML === 'more' ? 'fewer' : 'more';
    }

    /**
     * Callback after clicking `Clear` button
     */
  }, {
    key: "_onClear",
    value: function _onClear() {
      (this.onClear || noop)(this);
    }

    /**
     * Callback after clicking `Save` button
     */
  }, {
    key: "_onCloseModal",
    value: function _onCloseModal() {
      (this.onModalClose || noop)();
      this.modalInst.close();
    }

    /**
     * Enable clear button
     */
  }, {
    key: "enableClearBtn",
    value: function enableClearBtn() {
      for (var i = 0; i < this._clearEls.length; i++) {
        (0, _removeClass.default)(this._clearEls[i], 'spark-filter-module__clear--disabled');
        (0, _removeClass.default)(this._clearEls[i], 'spark-filter-module__clear--hidden');
      }
    }

    /**
     * Disable clear button
     */
  }, {
    key: "disableClearBtn",
    value: function disableClearBtn() {
      for (var i = 0; i < this._clearEls.length; i++) {
        (0, _addClass.default)(this._clearEls[i], 'spark-filter-module__clear--disabled');
      }
    }

    /**
     * Hide clear button
     */
  }, {
    key: "hideClearBtn",
    value: function hideClearBtn() {
      for (var i = 0; i < this._clearEls.length; i++) {
        (0, _addClass.default)(this._clearEls[i], 'spark-filter-module__clear--hidden');
      }
    }

    /**
     * Determine if Clear button is hidden or disabled
     */
  }, {
    key: "getClearButtonStatus",
    value: function getClearButtonStatus() {
      var buttonEnabled = false;
      for (var i = 0; i < this._clearEls.length; i++) {
        if ((0, _hasClass.default)(this._clearEls[i], 'spark-filter-module__clear--hidden') || (0, _hasClass.default)(this._clearEls[i], 'spark-filter-module__clear--disabled')) {
          buttonEnabled = false;
        } else {
          buttonEnabled = true;
        }
      }
      return buttonEnabled;
    }

    /**
     * Hide or show extra filters elements as triggered by Show more/fewer
     */
  }, {
    key: "toggleHiddenContent",
    value: function toggleHiddenContent() {
      for (var i = 0; i < this._hiddenEls.length; i++) {
        (0, _toggleClass.default)(this._hiddenEls[i], 'show');
      }
    }

    /**
     * Change filter-module to expand/collapse variation
     * This occurs when the filter is at the xs breakpoint
     */
  }, {
    key: "_applyExpand",
    value: function _applyExpand() {
      if (this._modalEl) {
        var modalClsNames = ['spark-filter-module--hide', '', '', ''];
        this._hiddenEls.push(this._modalEl);
        var curEl = this._modalEl;
        for (var i = 0; i < modalClsNames.length; i++) {
          this._modalClasses[i] = curEl.className;
          curEl.className = modalClsNames[i];
          curEl = curEl.firstElementChild;
        }
        if ((0, _hasClass.default)(document.body, 'spark-modal-open')) {
          (0, _removeClass.default)(document.body, 'spark-modal-open');
        }
        this.modalInst.remove(true);
      }
      (0, _addClass.default)(this.el, 'spark-panel', 'spark-panel--expand');
      (0, _addClass.default)(this._headerEl, 'spark-panel__header');
      this._headerEl.setAttribute('role', 'heading');
      this._headerEl.setAttribute('tabindex', '0');
      (0, _addClass.default)(this._bodyEl, 'spark-panel__content');
      this._expandInst = new _expand.default(this.el, {
        onAfterExpand: this.onAfterExpand,
        onAfterCollapse: this.onAfterCollapse
      });
      this._isExpand = true;
    }

    /**
     * Change filter-module from expand/collapse to horizontal variation
     */
  }, {
    key: "_disapplyExpand",
    value: function _disapplyExpand() {
      if (this._modalEl) {
        if ((0, _hasClass.default)(this._modalEl, 'show')) {
          this._toggleShowAllLabel();
        }
        this._hiddenEls.pop();
        var curEl = this._modalEl;
        for (var i = 0; i < this._modalClasses.length; i++) {
          curEl.className = this._modalClasses[i];
          curEl = curEl.firstElementChild;
        }
        this.modalInst = new _modal.default(this._modalEl);
      }
      (0, _removeClass.default)(this.el, 'spark-panel', 'spark-panel--expand');
      (0, _removeClass.default)(this._headerEl, 'spark-panel__header');
      this._headerEl.removeAttribute('role');
      this._headerEl.removeAttribute('tabindex');
      (0, _removeClass.default)(this._bodyEl, 'spark-panel__content');
      this._expandInst.remove(true);
      this._isExpand = false;
    }
  }]);
  return FilterModule;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
FilterModule.prototype._whitelistedParams = ['onShowAll', 'onShowAllComplete', 'onModalClose', 'onClear', 'onAfterExpand', 'onAfterCollapse'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
FilterModule.prototype.defaults = {
  el: null,
  onShowAll: noop,
  onShowAllComplete: noop,
  onModalClose: noop,
  onClear: noop,
  onAfterExpand: noop,
  onAfterCollapse: noop,
  modalInst: null,
  _onShowAllBound: null,
  _onClearBound: null,
  _showAllEl: null,
  _clearEl: null,
  _hiddenEls: [],
  _headerEl: null,
  _bodyEl: null,
  _modalEl: null,
  _expandInst: null,
  _isExpand: false,
  dataSet: {}
};
var _default = FilterModule;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/add-class":59,"../helpers/dom/has-class":61,"../helpers/dom/remove-class":67,"../helpers/dom/toggle-class":68,"./base":3,"./expand":11,"./modal":19,"@babel/runtime-corejs3/core-js-stable/instance/slice":115,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],13:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _filterModule = _interopRequireDefault(require("./filter-module"));
var _height = _interopRequireDefault(require("../helpers/animation/height"));
var _breakpoint = require("../helpers/dom/breakpoint");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Filter
                                                                                                                                                                                                                                                                                                                                              * A container for a set of form fields used to filter a data set or search results
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Filter(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/filter.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var Filter = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(Filter, _BaseComponent);
  var _super = _createSuper(Filter);
  /**
   * Filter constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function Filter(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Filter);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    _this._initFilterDisplay();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Store a reference to the needed elements
   * @param {Element} el
   */
  (0, _createClass2.default)(Filter, [{
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.moduleEls = this.el.querySelectorAll('.spark-filter-module');

      // These options are here so that the modules can communicate with the filter to do certain tasks
      var defaultOption = {
        onAfterExpand: this._onAfterExpand.bind(this),
        onAfterCollapse: this._onAfterCollapse.bind(this)

        // onShowAllComplete: this._onShowAllComplete.bind(this),
      };

      if (this.moduleEls.length > 0) {
        for (var i = 0; i < this.moduleEls.length; i++) {
          if (typeof this.moduleOptions[i] !== 'undefined') {
            for (var key in defaultOption) {
              this.moduleOptions[i][key] = defaultOption[key];
            }
            this.moduleInsts[i] = new _filterModule.default(this.moduleEls[i], this.moduleOptions[i]);
          } else {
            this.moduleInsts[i] = new _filterModule.default(this.moduleEls[i], defaultOption);
          }
        }
      }
      this._filterToggleContainer = this.el.querySelector('.spark-filter__toggle-container');
      this._toggleFilterButton = this.el.querySelector('.spark-filter__toggle-button');
      this._toggleFilterLabel = this.el.querySelector('.spark-filter__toggle-button span');
      this._tagsContainer = this.el.querySelector('.spark-filter__tags-container');
      this._tagsCounter = this.el.querySelector('.spark-filter__applied-filters-counter');
      this._clearAllButton = this.el.querySelector('.spark-filter__clear-all');
      this._filterContent = this.el.querySelector('.spark-filter__content');
      this._modulesContainer = this.el.querySelector('.spark-filter__modules-container');
      this._viewMoreButton = this.el.querySelector('.spark-filter__view-more-filters');
      this._viewLessButton = this.el.querySelector('.spark-filter__view-less-filters');
      this._filterFooter = this.el.querySelector('.spark-filter__footer');
      this._buttonGroupEl = this.el.querySelector('.spark-filter__apply-btn-container');
      this._applyFiltersButton = this.el.querySelector('.spark-filter__btn-apply');
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onResizeBound = this._onResize.bind(this);
      this._toggleViewBound = this._toggleView.bind(this);
      this._toggleFilterClickBound = this.toggleFilterClick.bind(this);
      this._onClearAllBound = this._onClearAll.bind(this);
      this._onScrollBound = this._onScroll.bind(this);
    }

    /**
     * Add event listeners
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      window.addEventListener('resize', this._onResizeBound);
      window.addEventListener('scroll', this._onScrollBound);
      !this._viewMoreButton || this._viewMoreButton.addEventListener('click', this._toggleViewBound);
      !this._viewLessButton || this._viewLessButton.addEventListener('click', this._toggleViewBound);
      !this._toggleFilterButton || this._toggleFilterButton.addEventListener('click', this._toggleFilterClickBound);
      !this._clearAllButton || this._clearAllButton.addEventListener('click', this._onClearAllBound);
    }

    /**
     * Remove event listeners
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      window.removeEventListener('resize', this._onResizeBound);
      window.removeEventListener('scroll', this._onScrollBound);
      !this._viewMoreButton || this._viewMoreButton.removeEventListener('click', this._toggleViewBound);
      !this._viewLessButton || this._viewLessButton.removeEventListener('click', this._toggleViewBound);
      !this._toggleFilterButton || this._toggleFilterButton.removeEventListener('click', this._toggleFilterClickBound);
      !this._clearAllButton || this._clearAllButton.removeEventListener('click', this._onClearAllBound);
    }

    /**
     * Initialize filter
     */
  }, {
    key: "_initFilterDisplay",
    value: function _initFilterDisplay() {
      this.initializingFilter = true;
      if (this.moduleEls.length > 0) {
        this.extraModulesExpanded = false;
      }
      (0, _addClass.default)(this.el, 'spark-filter--initializing');
      this._determineFilterLayout();
    }

    /**
     * Determine which filter layout should be displayed i.e. Expand/Collapse view or Wide view
     */
  }, {
    key: "_determineFilterLayout",
    value: function _determineFilterLayout() {
      this.currentBreakpoint = (0, _breakpoint.get)(window.innerWidth);
      switch (this.currentBreakpoint) {
        case 'xs':
          this._curCol = 1;
          break;
        case 'sm':
          this._curCol = 2;
          break;
        case 'md':
          this._curCol = 3;
          break;
        default:
          this._curCol = 4;
          break;
      }
      if (this._curCol <= 1) {
        // Display expand-collapse filter
        if (!this._isDropdownState) {
          this._applyExpandCollapseLayout();
          this._showModule();
        }
      } else {
        // Display wide-screen filter
        if (this._expandCollapseState) {
          this._removeExpandCollapseLayout();
        }
        if ((0, _hasClass.default)(this._buttonGroupEl, 'is-fixed')) {
          clearTimeout(this._timeout);
          this._filterFooter.removeAttribute('style');
          this._buttonGroupEl.removeAttribute('style');
          (0, _removeClass.default)(this._buttonGroupEl, 'is-fixed');
        }
        this._showModule();
        if (!this.extraModulesExpanded) {
          this._hideModule(this._curCol, this._maxCol - 1);
        }
      }

      // Determine whether to show or hide View More/Less buttons
      if (!this._isDropdownState) {
        var hiddenModules = document.querySelectorAll('.spark-filter-module.hide');
        if (!this.extraModulesExpanded && hiddenModules.length === 0) {
          (0, _addClass.default)(this._viewMoreButton, 'hide');
        } else if (!this.extraModulesExpanded && hiddenModules.length > 0) {
          (0, _removeClass.default)(this._viewMoreButton, 'hide');
        }
      }
    }

    /**
     * Update the filter layout as necessary
     */
  }, {
    key: "_updateFilterLayout",
    value: function _updateFilterLayout() {
      this._determineFilterLayout();
    }

    /**
     * Expand or collapse extra filters
     */
  }, {
    key: "_toggleView",
    value: function _toggleView() {
      if (this._isFilterExpanded && !this.extraModulesExpanded) {
        this._showModule();
        this._dispatchVisibilityEvent();
      } else if (this._isFilterExpanded && this.extraModulesExpanded) {
        this._hideModule(this._curCol, this._maxCol - 1);
      }
      this.extraModulesExpanded = !this.extraModulesExpanded;
      (0, _toggleClass.default)(this._viewMoreButton, 'hide');
      (0, _toggleClass.default)(this._viewLessButton, 'hide');
    }

    /**
     * Handle click event when filter toggles are clicked
     */
  }, {
    key: "toggleFilterClick",
    value: function toggleFilterClick() {
      if (this.initializingFilter) {
        this.initializingFilter = false;
      }
      this.toggleFilter();
    }

    /**
     * To hide or show filter module
     * @params {String} toggle; collapse; expand;
     * @params {Boolean} Change the value of `this._isFilterExpanded` based on the boolean value
     */
  }, {
    key: "toggleFilter",
    value: function toggleFilter(option, noStateChange) {
      if ((0, _hasClass.default)(this.el, 'spark-filter--initializing') && !this.initializingFilter) {
        (0, _removeClass.default)(this.el, 'spark-filter--initializing');
        (0, _addClass.default)(this.el, 'spark-filter--initialized');
      }
      if (option === 'expand') {
        if (!this.initializingFilter) {
          (0, _removeClass.default)(this._filterContent, 'hide');
          (0, _height.default)({
            el: this.el,
            toggleEl: '.spark-filter__content',
            toggleClass: 'filter-expanded',
            action: 'expand'
          });
          this._toggleFilterLabel.innerHTML = 'Hide';
        } else {
          (0, _removeClass.default)(this._filterContent, 'hide');
        }
        if (!noStateChange) {
          this._isFilterExpanded = true;
        }
      } else if (option === 'collapse') {
        if (!this.initializingFilter) {
          (0, _addClass.default)(this._filterContent, 'hide');
          (0, _height.default)({
            el: this.el,
            toggleEl: '.spark-filter__content',
            toggleClass: 'filter-expanded',
            action: 'collapse'
          });
          this._toggleFilterLabel.innerHTML = 'Show';
        } else {
          (0, _addClass.default)(this._filterContent, 'hide');
        }
        if (!noStateChange) {
          this._isFilterExpanded = false;
        }
      } else {
        (0, _toggleClass.default)(this._filterContent, 'hide');
        if ((0, _hasClass.default)(this.el, 'filter-expanded')) {
          (0, _height.default)({
            el: this.el,
            toggleEl: '.spark-filter__content',
            toggleClass: 'filter-expanded',
            action: 'collapse'
          });
          this._toggleFilterLabel.innerHTML = 'Show';
        } else {
          (0, _height.default)({
            el: this.el,
            toggleEl: '.spark-filter__content',
            toggleClass: 'filter-expanded',
            action: 'expand'
          });
          this._toggleFilterLabel.innerHTML = 'Hide';
        }
        if (!noStateChange) {
          this._isFilterExpanded = !this._isFilterExpanded;
          if ((0, _hasClass.default)(this.el, 'spark-filter--dropdown') && !(0, _hasClass.default)(this._filterContent, 'hide')) {
            this._calculateApplyBtnPosition();
          }
        }
      }
      if (!(0, _hasClass.default)(this.el, 'spark-filter--dropdown') && (0, _hasClass.default)(this._buttonGroupEl, 'is-fixed')) {
        clearTimeout(this._timeout);
        this._filterFooter.removeAttribute('style');
        this._buttonGroupEl.removeAttribute('style');
        (0, _removeClass.default)(this._buttonGroupEl, 'is-fixed');
      }
      this._dispatchVisibilityEvent();
    }

    /**
     * On-resize handler that updates layout as needed based on screen dimensions
     */
  }, {
    key: "_onResize",
    value: function _onResize() {
      this._updateFilterLayout();
    }

    /**
     * On-scroll handler that determines Apply button positioning at the xs breakpoint
     */
  }, {
    key: "_onScroll",
    value: function _onScroll() {
      if (this._isDropdownState) {
        this._timeout = setTimeout(this._calculateApplyBtnPosition.bind(this), 300);
      }
    }

    /**
     * Callback triggered after the expansion of a module at the xs breakpoint
     */
  }, {
    key: "_onAfterExpand",
    value: function _onAfterExpand() {
      if (!(0, _hasClass.default)(this._buttonGroupEl, 'is-fixed')) {
        this._timeout = setTimeout(this._calculateApplyBtnPosition.bind(this), 300);
      }
    }

    /**
     * Callback triggered after the collapse of a module at the xs breakpoint
     */
  }, {
    key: "_onAfterCollapse",
    value: function _onAfterCollapse() {
      this._timeout = setTimeout(this._calculateApplyBtnPosition.bind(this), 300);
    }

    /**
     * Callback triggered after Show all is complete at the xs breakpoint
     */

    /* TODO: This is not required anymore as show all is not available at the xs breakpoint anymore
    _onShowAllComplete() {
      if(this._isDropdownState) {
        this._timeout = setTimeout(this._calculateApplyBtnPosition.bind(this), 300);
      }
    }
    */

    /**
     * Dispatch a custom event so content inside the Filter can respond
     */
  }, {
    key: "_dispatchVisibilityEvent",
    value: function _dispatchVisibilityEvent() {
      var e = document.createEvent('Event');
      e.initEvent('spark.visible-children', true, true);
      this.el.dispatchEvent(e);
    }

    /**
     * Calculate the position of the Apply button at the xs breakpoint
     */
  }, {
    key: "_calculateApplyBtnPosition",
    value: function _calculateApplyBtnPosition() {
      var filterOffsets = this.el.getBoundingClientRect();

      // 3 collapsed module heights + filter header height = 255
      if (filterOffsets.height > 255) {
        var windowHeight = window.innerHeight;
        var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        var filterHiddenBefore = scrollTop - (filterOffsets.top + document.body.scrollTop);
        var filterHiddenAfter = filterOffsets.top + document.body.scrollTop + filterOffsets.height - (scrollTop + windowHeight);
        if (!(scrollTop > filterOffsets.top + document.body.scrollTop + filterOffsets.height || filterOffsets.top + document.body.scrollTop > scrollTop + window.innerHeight)) {
          var percentInView = 100;
          var inViewport;
          var hiddenBefore = 0;
          var hiddenAfter = 0;
          if (filterHiddenBefore > 0) {
            percentInView -= filterHiddenBefore * 100 / filterOffsets.height;
            hiddenBefore = filterHiddenBefore;
          }
          if (filterHiddenAfter > 0) {
            percentInView -= filterHiddenAfter * 100 / filterOffsets.height;
            hiddenAfter = filterHiddenAfter;
          }
          inViewport = (filterOffsets.height - (hiddenAfter + hiddenBefore)) / windowHeight * 100;
        }
        if (filterOffsets.bottom > (window.innerHeight || document.documentElement.clientHeight) && (percentInView > 45 || inViewport > 50)) {
          var buttonGroupHeight = this._buttonGroupEl.offsetHeight;
          var filterWidth = filterOffsets.width;
          this._filterFooter.style.height = buttonGroupHeight + 'px';
          (0, _addClass.default)(this._buttonGroupEl, 'is-fixed');

          // accounting for border width
          this._buttonGroupEl.style.width = filterWidth - 2 + 'px';

          // accounting for left border
          this._buttonGroupEl.style.left = filterOffsets.left + 1 + 'px';
          this._applyBtnPositionFixed();
        } else {
          this._applyBtnPositionRelative();
        }
      }
    }

    /**
     * Set position:relative for the Apply button
     */
  }, {
    key: "_applyBtnPositionRelative",
    value: function _applyBtnPositionRelative() {
      // function attachApplyBtn(){
      var currentButtonPosition = parseInt(getComputedStyle(this._buttonGroupEl).bottom);
      var listBottom = this._modulesContainer.getBoundingClientRect().bottom;
      var viewportHeight = window.innerHeight || document.documentElement.clientHeight;
      var buttonGroupHeight = this._buttonGroupEl.getBoundingClientRect().height;
      var distanceToMove = viewportHeight - (listBottom + buttonGroupHeight);
      if (!isNaN(currentButtonPosition)) {
        var animationListener = function animationListener() {
          this._filterFooter.removeAttribute('style');
          this._buttonGroupEl.removeAttribute('style');
          (0, _removeClass.default)(this._buttonGroupEl, 'is-fixed');
          (0, _removeClass.default)(this._buttonGroupEl, 'spark-filter__apply-btn-container--animate');
          this._buttonGroupEl.removeEventListener('animationend', animationListener);
        };
        this._buttonGroupEl.addEventListener('animationend', animationListener.bind(this), false);
        var keyframe = '-webkit-transform: translateY(-' + distanceToMove + 'px); transform: translateY(-' + distanceToMove + 'px);';
        this._buttonGroupEl.setAttribute('style', this._buttonGroupEl.getAttribute('style') + ' ' + keyframe);
        (0, _addClass.default)(this._buttonGroupEl, 'spark-filter__apply-btn-container--animate');
      }
    }

    /**
     * Set position:fixed for the Apply button
     */
  }, {
    key: "_applyBtnPositionFixed",
    value: function _applyBtnPositionFixed() {
      var requestID = requestAnimationFrame(moveApplyBtn.bind(this));
      var incrementer = .1;
      function moveApplyBtn() {
        incrementer += .01;
        var currentButtonPosition = parseInt(getComputedStyle(this._buttonGroupEl).bottom);
        var buttonHeight = parseInt(getComputedStyle(this._buttonGroupEl).height);
        if (currentButtonPosition < buttonHeight * -1) {
          currentButtonPosition = buttonHeight * -1;
        }
        if (currentButtonPosition > -1) {
          this._buttonGroupEl.style.bottom = '0px';
          cancelAnimationFrame(requestID);
        } else if (currentButtonPosition < 0) {
          currentButtonPosition += 1 / incrementer;
          this._buttonGroupEl.style.bottom = currentButtonPosition + 'px';
          requestAnimationFrame(moveApplyBtn.bind(this));
        }
      }
    }

    /**
     * Callback for Clear all
     */
  }, {
    key: "_onClearAll",
    value: function _onClearAll() {
      (this.onClearAll || noop)();
    }

    /**
     * Show all modules
     */
  }, {
    key: "_showModule",
    value: function _showModule() {
      for (var i = 0; i < this.moduleEls.length; i++) {
        (0, _removeClass.default)(this.moduleEls[i], 'hide');
      }
    }

    /**
     * Hide certain modules
     * @param {Number} start index
     * @param {Number} end index
     */
  }, {
    key: "_hideModule",
    value: function _hideModule(start, end) {
      end = end || this.moduleEls.length - 1;
      for (var i = start; i <= end; i++) {
        (0, _addClass.default)(this.moduleEls[i], 'hide');
      }
    }

    /**
     * Apply Expand/Collapse layout for the filter
     * Used when the filter gets to the xs breakpoint
     */
  }, {
    key: "_applyExpandCollapseLayout",
    value: function _applyExpandCollapseLayout() {
      (0, _addClass.default)(this.el, 'spark-filter--dropdown');
      this._expandCollapseState = true;
      var tags = this._tagsContainer.querySelectorAll('.spark-filter__tag');
      if (tags.length > 0) {
        for (var i = 0; i < tags.length; i++) {
          (0, _addClass.default)(tags[i], 'hide');
        }
        (0, _removeClass.default)(this._tagsCounter, 'hide');
      }
      (0, _addClass.default)(this._viewMoreButton, 'hide');
      (0, _addClass.default)(this._viewLessButton, 'hide');
      if (this._applyFiltersButton) {
        (0, _removeClass.default)(this._applyFiltersButton, 'spark-btn--sm');
        (0, _addClass.default)(this._applyFiltersButton, 'spark-btn--block');
      }
      for (var j = 0; j < this.moduleInsts.length; j++) {
        this.moduleInsts[j]._applyExpand();
      }
      this._isDropdownState = true;
      this._timeout = setTimeout(this._calculateApplyBtnPosition.bind(this), 300);
    }

    /**
     * Remove Expand/Collapse layout and apply the horizontal layout for the filter
     * Used when the screen size is larger than the xs breakpoint
     */
  }, {
    key: "_removeExpandCollapseLayout",
    value: function _removeExpandCollapseLayout() {
      (0, _removeClass.default)(this.el, 'spark-filter--dropdown');
      this._expandCollapseState = false;
      this._filterFooter.removeAttribute('style');
      this._buttonGroupEl.removeAttribute('style');
      (0, _removeClass.default)(this._buttonGroupEl, 'is-fixed');
      var tags = this._tagsContainer.querySelectorAll('.spark-filter__tag');
      if (tags.length > 0) {
        for (var i = 0; i < tags.length; i++) {
          (0, _removeClass.default)(tags[i], 'hide');
        }
        (0, _addClass.default)(this._tagsCounter, 'hide');
      }
      if (this.extraModulesExpanded) {
        (0, _removeClass.default)(this._viewLessButton, 'hide');
      } else {
        (0, _removeClass.default)(this._viewMoreButton, 'hide');
      }
      if (this._applyFiltersButton) {
        (0, _addClass.default)(this._applyFiltersButton, 'spark-btn--sm');
        (0, _removeClass.default)(this._applyFiltersButton, 'spark-btn--block');
      }
      for (var j = 0; j < this.moduleInsts.length; j++) {
        this.moduleInsts[j]._disapplyExpand();
      }
      this._isDropdownState = false;
    }

    /**
     * Generate a tag element in filter, which will be directly posted inside `.spark-filter__tags-container`
     * @param {string} input name - Name of the input to allow any callbacks to target input specifically
     * @param {string} tag label - The label to be displayed in the tag. This could be the input's label or another user defined label
     * @param {function} callback function for `X` button
     */
  }, {
    key: "createTagEl",
    value: function createTagEl(input, label, clearCallback) {
      var tagEl = document.createElement('div');
      tagEl.className = (0, _hasClass.default)(this.el, 'spark-filter--dropdown') ? 'spark-filter__tag hide' : 'spark-filter__tag';
      tagEl.setAttribute('data-filter-name', input);
      tagEl.innerHTML = '<span class="spark-filter__tag__label">' + label + '</span><i role="button" tabindex="0" aria-label="Clear ' + label + ' filter" class="spark-icon spark-icon-close spark-filter__tag__close"></i>';
      this._tagsContainer.insertBefore(tagEl, this._clearAllButton);

      // create event listeners after adding element to DOM
      tagEl.querySelector('.spark-filter__tag__close').addEventListener('click', clearCallback || noop);
      tagEl.querySelector('.spark-filter__tag__close').addEventListener('keydown', clearCallback || noop);
      (0, _removeClass.default)(this._clearAllButton, 'hide');

      // Show tag count if on small screen and this is initial application of filters
      if ((0, _hasClass.default)(this.el, 'spark-filter--dropdown')) (0, _removeClass.default)(this._tagsCounter, 'hide');
    }

    /**
     * Remove all tags
     */
  }, {
    key: "clearAllTagEls",
    value: function clearAllTagEls() {
      var tags = this._tagsContainer.querySelectorAll('.spark-filter__tag');
      for (var i = 0; i < tags.length; i++) {
        this._tagsContainer.removeChild(tags[i]);
      }

      // Reset counter
      var counter = this._tagsContainer.querySelector('span');
      counter.innerHTML = '0';
      (0, _addClass.default)(this._clearAllButton, 'hide');
      (0, _addClass.default)(this._tagsCounter, 'hide');
    }

    /**
     * Show Module Clear Button
     * @param {Element} moduleName An identifier for the module being targeted
     */
  }, {
    key: "showModuleClearButton",
    value: function showModuleClearButton(moduleName) {
      for (var i = 0; i < this.moduleInsts.length; i++) {
        if (this.moduleInsts[i].el.getAttribute('data-filter-module') === moduleName) {
          this.moduleInsts[i].enableClearBtn();
        }
      }
    }

    /**
     * Disable Module Clear Button
     * @param {Element} moduleName An identifier for the module being targeted
     */
  }, {
    key: "disableModuleClearButton",
    value: function disableModuleClearButton(moduleName) {
      for (var i = 0; i < this.moduleInsts.length; i++) {
        if (this.moduleInsts[i].el.getAttribute('data-filter-module') === moduleName) {
          this.moduleInsts[i].disableClearBtn();
        }
      }
    }

    /**
     * Hide Module Clear Button
     * @param {Element} moduleName An identifier for the module being targeted
     */
  }, {
    key: "hideModuleClearButton",
    value: function hideModuleClearButton(moduleName) {
      for (var i = 0; i < this.moduleInsts.length; i++) {
        if (this.moduleInsts[i].el.getAttribute('data-filter-module') === moduleName) {
          this.moduleInsts[i].hideClearBtn();
        }
      }
    }

    /**
     * Get Module Clear button status
     *  @param {Element} moduleName An identifier for the module being targeted
     */
  }, {
    key: "moduleClearButtonStatus",
    value: function moduleClearButtonStatus(moduleName) {
      for (var i = 0; i < this.moduleInsts.length; i++) {
        if (this.moduleInsts[i].el.getAttribute('data-filter-module') === moduleName) {
          return this.moduleInsts[i].getClearButtonStatus();
        }
      }
    }
  }]);
  return Filter;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
Filter.prototype._whitelistedParams = ['onClearAll', 'moduleOptions'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
Filter.prototype.defaults = {
  el: null,
  moduleEls: [],
  _filterToggleContainer: null,
  _toggleFilterButton: null,
  _toggleFilterLabel: null,
  _tagsContainer: null,
  _tagsCounter: null,
  _clearAllButton: null,
  _filterContent: null,
  _modulesContainer: null,
  _viewMoreButton: null,
  _viewLessButton: null,
  _filterFooter: null,
  _buttonGroupEl: null,
  _applyFiltersButton: null,
  moduleInsts: [],
  moduleOptions: [],
  maxCol: 4,
  onClearAll: noop,
  extraModulesExpanded: false,
  _isFilterExpanded: false,
  _isDropdownState: false,
  _isModuleExpand: true,
  _curCol: 4,
  _onResizeBound: null,
  _toggleViewBound: null,
  _toggleFilterClickBound: null,
  _onClearAllBound: null,
  _onScrollBound: null
};
var _default = Filter;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/animation/height":52,"../helpers/dom/add-class":59,"../helpers/dom/breakpoint":60,"../helpers/dom/has-class":61,"../helpers/dom/remove-class":67,"../helpers/dom/toggle-class":68,"./base":3,"./filter-module":12,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],14:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _outerHeight = _interopRequireDefault(require("../helpers/dom/outer-height"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _debounce = _interopRequireDefault(require("../helpers/util/debounce"));
var _breakpoint = require("../helpers/dom/breakpoint");
var _parseAttribute = require("../helpers/dom/parse-attribute");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Fixed Panel
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new FixedPanel(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/fixed-panel.js
                                                                                                                                                                                                                                                                                                                                              */
var FixedPanel = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(FixedPanel, _BaseComponent);
  var _super = _createSuper(FixedPanel);
  /**
   * Fixed Panel constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function FixedPanel(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, FixedPanel);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addListeners();
    _this._setPanelLocation();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Parse parameters from the elements.
   */
  (0, _createClass2.default)(FixedPanel, [{
    key: "_parseParams",
    value: function _parseParams() {
      this.hideOnScroll = this.hideOnScroll || (0, _parseAttribute.boolean)(this.el, 'data-hide-on-scroll', false);
      this.fixToBottom = this.fixToBottom || (0, _parseAttribute.boolean)(this.el, 'data-fixed-to-bottom', false);
      this.condenseOnScroll = this.condenseOnScroll || (0, _parseAttribute.boolean)(this.el, 'data-condense', false);
      this.unlockBreakPoint = this.unlockBreakPoint || (0, _parseAttribute.string)(this.el, 'data-breakpoint', null);
      this.documentBody = document.querySelector('body');

      // Checks to see if a non-Spark header is provided by the user
      if (this.headerEl !== null) {
        this.foreignHeader = true;
      } else {
        // If no header is given then, search for a Spark header.
        this.headerEl = document.querySelector('.spark-header:not(.spark-header__placeholder)');
        if (this.headerEl) {
          this.headerHideOnScroll = (0, _parseAttribute.boolean)(this.headerEl, 'data-hide-on-scroll', false);
        }
      }
    }

    /**
     * Add Fixed Panel window listeners
     */
  }, {
    key: "_addListeners",
    value: function _addListeners() {
      window.addEventListener('scroll', this._onScrollBound);
      window.addEventListener('resize', this._onResizeBound);

      // if there is a header it may have transitions that change the height, watch for it and adjust accordingly
      if (this.headerEl) {
        if (window.getComputedStyle(this.headerEl).getPropertyValue('transition') !== "") {
          this.headerEl.addEventListener('transitionend', this._onResizeBound);
        }
      }
    }

    /**
     * Remove Fixed Panel window listeners
     */
  }, {
    key: "_removeListeners",
    value: function _removeListeners() {
      window.removeEventListener('scroll', this._onScrollBound);
      window.removeEventListener('resize', this._onResizeBound);
      if (this.headerEl) {
        if (window.getComputedStyle(this.headerEl).getPropertyValue('transition') !== "") {
          this.headerEl.removeEventListener('transitionend', this._onResizeBound);
        }
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onScrollBound = this._onScroll.bind(this);
      this._onResizeBound = (0, _debounce.default)(this._onResize.bind(this), 100);
    }

    /**
     * Sets up references
     * @param  {Element} el base DOM element
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
    }

    /**
     * This method will determine where on the viewport the Fixed Panel will dock to,
     * and gets the dimensions of the Fixed Panel and Header (if fixed to the top of the viewport).
     */
  }, {
    key: "_setPanelLocation",
    value: function _setPanelLocation() {
      this.currentScrollPosition = window.pageYOffset !== undefined ? window.pageYOffset : window.document.body.scrollTop;
      this._getPanelDimensions();
      if (this.fixToBottom) {
        // Adding padding to the bottom of the body equivalent to the height of the
        // Fixed Panel when using the "fix to bottom" config
        if (this.documentBody) {
          this.documentBody.style['padding-bottom'] = this.panelHeight + 'px';
        }
      } else if (this.headerEl) {
        // Gets the next Element of page content below the Fixed Panel
        this.pageContent = this.el.nextSibling.nextSibling;
      }
      if (this.headerPositionFixed) {
        // If a Fixed Header exists, append the Fixed Panel to it and sets the
        // top margin of the parent of the Header to the height of the Header and Fixed Panel
        this.headerEl.appendChild(this.el);
        this.headerEl.parentNode.style['margin-top'] = (0, _outerHeight.default)(this.headerEl) + this.panelHeight + 24 + 'px';

        // If the header hides on scroll, but the panel scrolls to an element,
        // make it fix to the top of the viewport until that element
        if (this.headerHideOnScroll && this.scrolledToEl) {
          (0, _addClass.default)(this.el, 'fix-to-fixed-header');
          (0, _addClass.default)(this.headerEl, 'hide-top-show-panel');
        } else if (this.headerHideOnScroll && this.hideOnScroll) {
          (0, _addClass.default)(this.headerEl, 'hide-top-with-panel');
        }
      }
    }

    /**
     * This method checks the current viewport size against the breakpoint
     * set in the configs, returning false if the viewport size is less
     * than or equal to the breakpoint config and true if it is not.
     */
  }, {
    key: "_checkBreakPoint",
    value: function _checkBreakPoint() {
      // Gets the current breakpoint of the current window
      var windowWidth = window.innerWidth;
      var currentBreakpoint = (0, _breakpoint.get)(windowWidth);

      // Returns false if the current breakpoint is equal to the config breakpoint
      // or any other breakpoint that is smaller than the breakpoint config
      if (this.unlockBreakPoint === currentBreakpoint) {
        return false;
      }
      if (this.unlockBreakPoint === 'sm' && currentBreakpoint === 'xs') {
        return false;
      }
      if (this.unlockBreakPoint === 'md' && (currentBreakpoint === 'sm' || currentBreakpoint === 'xs')) {
        return false;
      }
      if (this.unlockBreakPoint === 'lg' && (currentBreakpoint === 'md' || currentBreakpoint === 'sm' || currentBreakpoint === 'xs')) {
        return false;
      }
      if (this.unlockBreakPoint === 'xl') {
        return false;
      }
      return true;
    }

    /**
     * This method fixes the Fixed Panel to the top of the viewport when a user has
     * scrolled beyond the Header or if no Header is present by default fixes to the
     * top of viewport.
     */
  }, {
    key: "_fixToTopViewport",
    value: function _fixToTopViewport() {
      var lockPanel = this._checkBreakPoint();
      if (this.currentScrollPosition > this.headerHeight) {
        if (lockPanel) {
          // When scrolled past the height of the Header, the Fixed Panel will fix
          // itself to the top of the viewport
          if (!(0, _hasClass.default)(this.el, 'is-fixed-top')) {
            (0, _addClass.default)(this.el, 'is-fixed-top');

            // Add top margin to the next element that is under the Fixed Panel
            this.pageContent.style['margin-top'] = this.panelHeight + 'px';
          }

          // Method call to condense the Fixed Panel, if the condense config is set
          this.condensePanel();
        }
      } else {
        if (this.headerHeight !== 0) {
          // Upon returning to the bottom of a present header the Fixed Panel will
          // dock to the bottom of the header
          if ((0, _hasClass.default)(this.el, 'is-fixed-top')) {
            (0, _removeClass.default)(this.el, 'is-fixed-top');

            // Eliminates top margin to the next element that is under the Fixed Panel
            this.pageContent.style['margin-top'] = 0 + 'px';
          }
        }

        // Method call to extend the Fixed Panel from a condensed state if the condense config is set
        this.extendPanel();
      }
    }

    /**
     * This method will show or hide the Fixed panel if it is currently out of view
     * and the user scrolls up or down
     */
  }, {
    key: "_showPanelOnScroll",
    value: function _showPanelOnScroll() {
      var totalHeight = this.headerHeight + this.panelHeight;

      // If scrolled down the height of the Header, and the Fixed Panel the Panel will hide.
      // If scrolled up the Fixed Panel will show, and if the header is in the viewport the Fix Panel
      // will dock to the bottom of the Header
      if (this.currentScrollPosition > totalHeight) {
        if (this.currentScrollPosition < this.previousScrollPosition) {
          this.showPanel();
        } else if (this.currentScrollPosition >= this.previousScrollPosition) {
          this.hidePanel();
        }
      }
    }

    /**
     * Trigger Event function is called to show the panel based off of a desired event
     */
  }, {
    key: "showPanel",
    value: function showPanel() {
      if (this.fixToBottom) {
        (0, _removeClass.default)(this.el, 'hide-panel-bottom');
        this.documentBody.style['padding-bottom'] = this.panelHeight + 'px';
      } else {
        (0, _removeClass.default)(this.el, 'hide-panel-top');
      }
    }

    /**
     * Trigger Event function is called to hide the panel based off of a desired event
     */
  }, {
    key: "hidePanel",
    value: function hidePanel() {
      if (this.fixToBottom) {
        (0, _addClass.default)(this.el, 'hide-panel-bottom');
        this.documentBody.style['padding-bottom'] = 0;
      } else {
        (0, _addClass.default)(this.el, 'hide-panel-top');
      }
    }

    /**
     * Trigger Event function is called to condense the panel based off of a desired event
     */
  }, {
    key: "condensePanel",
    value: function condensePanel() {
      // If a condense config is added than this checks for the a custom condense class
      // to apply to the Fixed Panel, if no class is provided than apply default class 'spark-panel--condensed'
      if (this.condenseOnScroll) {
        if (this.customCondenseClass) {
          (0, _addClass.default)(this.el, this.customCondenseClass);
        } else {
          (0, _addClass.default)(this.el, 'spark-panel--condensed');
        }
      }
    }

    /**
     * Trigger Event function is called to extend the panel from a condensed state based off of a desired event
     */
  }, {
    key: "extendPanel",
    value: function extendPanel() {
      if (this.condenseOnScroll) {
        if (this.customCondenseClass) {
          (0, _removeClass.default)(this.el, this.customCondenseClass);
        } else {
          (0, _removeClass.default)(this.el, 'spark-panel--condensed');
        }
      }
    }

    /**
     * This method gets the height and location of the Header and also updates the
     * height of the Fixed Panel and Fixed Panel PlaceHolder to allow for the appropriate window modifications
     */
  }, {
    key: "_getPanelDimensions",
    value: function _getPanelDimensions() {
      this.panelHeight = this.el.getBoundingClientRect().height;
      if (this.fixToBottom) {
        (0, _addClass.default)(this.el, 'is-fixed-bottom');
      } else if (this.headerEl) {
        this.headerTop = this.headerEl.getBoundingClientRect().top + this.currentScrollPosition;
        this.headerBottom = this.headerEl.getBoundingClientRect().bottom + this.currentScrollPosition;
        this.headerHeight = this.headerTop + (0, _outerHeight.default)(this.headerEl);

        // Checks to see if the Header is fixed or not
        var position = (0, _hasClass.default)(this.headerEl, 'spark-header--fixed') ? 'fixed' : window.getComputedStyle(this.headerEl, null).getPropertyValue('position');
        var lockPanel = this._checkBreakPoint();

        // If the Header is fixed no Header calculations are need, if not the height of the Header
        // based off it's position on the page is calculated
        if (position === 'fixed') {
          this.headerPositionFixed = true;
        } else {
          this.headerHeight = (0, _outerHeight.default)(this.headerEl) + this.headerTop;
        }
        if (!lockPanel) {
          (0, _removeClass.default)(this.el, 'is-fixed-top');
          if (this.pageContent) {
            this.pageContent.style['margin-top'] = 0;
          }
        }
      } else {
        var _lockPanel = this._checkBreakPoint();
        if (_lockPanel) {
          // Disregarding other configs, by default if a header is not provided and a
          // Spark header is not present Fixed Panel will fix to the top of viewport
          (0, _addClass.default)(this.el, 'is-fixed-top');
          this.el.style['margin-bottom'] = this.panelHeight + 'px';
          this.headerHeight = 0;
        }
      }
    }

    /**
     * Update the margin or padding of the body element or Header based on the position of
     * the Fixed Panel and presence of a Header.
     */
  }, {
    key: "_updatePanels",
    value: function _updatePanels() {
      if (this.fixToBottom) {
        this.documentBody.style['padding-bottom'] = this.panelHeight + 'px';
      }

      // Checks the current breakpoint aganist that of the breakpoint config to determine
      // if the Fixed Panel will remian fixed to the top viewport
      var lockPanel = this._checkBreakPoint();
      if (!this.headerEl && !this.fixToBottom && lockPanel) {
        (0, _addClass.default)(this.el, 'is-fixed-top');
        this.documentBody.style['padding-top'] = this.panelHeight + 'px';
      }

      // Updates the margin of the parent node of the header to account for page content on resize
      if (this.headerPositionFixed) {
        this.headerEl.parentNode.style['margin-top'] = (0, _outerHeight.default)(this.headerEl) + this.panelHeight + 24 + 'px';
      }
    }

    /**
     * On any resize event this method will recalculate the height of the header
     * as the Header may condense based off of window size, and adjusts the margin/padding
     * of elements if the Fixed Panel content wraps because of a smaller viewport size
     */
  }, {
    key: "_onResize",
    value: function _onResize() {
      this._getPanelDimensions();
      this.panelHeight = this.el.getBoundingClientRect().height;
      if (this.pageContent && parseInt(this.pageContent.style['margin-top']) > 0) {
        this.pageContent.style['margin-top'] = this.panelHeight + 'px';
      }
      this._updatePanels();
    }

    /**
     * On any scroll event this method will apply which ever variation and/or
     * config to the Fixed Panel on a scroll event
     */
  }, {
    key: "_onScroll",
    value: function _onScroll() {
      this.previousScrollPosition = this.currentScrollPosition;
      this.currentScrollPosition = window.pageYOffset !== undefined ? window.pageYOffset : window.document.body.scrollTop;
      this._getPanelDimensions();
      if (this.fixToBottom) {
        if (this.condenseOnScroll) {
          this._condensePanelonScroll();
        }
      } else {
        if (this.headerPositionFixed) {
          if (this.condenseOnScroll) {
            if (!this.foreignHeader) {
              this._onHeaderCondense();
            } else {
              this._condensePanelonScroll();
            }
          }
        } else if (!this.headerPositionFixed) {
          if (this.hideOnScroll) {
            this._showPanelOnScroll();
            this._fixToTopViewport();
          } else {
            this._fixToTopViewport();
          }
        }
      }
      this._showUntilElement();
    }

    /**
     * Add a condensed class to the Fixed Panel when scrolled an amount of pixels greater
     * than the height of the Fixed Panel
     */
  }, {
    key: "_condensePanelonScroll",
    value: function _condensePanelonScroll() {
      if (this.currentScrollPosition > this.panelHeight) {
        this.condensePanel();
      } else {
        this.extendPanel();
      }
    }

    /**
     * This method will show/hide the Fixed panel on scroll based on its position
     * relative to a specified page-level element (scrolledToEl)
     */
  }, {
    key: "_showUntilElement",
    value: function _showUntilElement() {
      if (!this.scrolledToEl || this.fixToBottom) {
        return;
      }
      var targetScrollPosition;

      // Calculates the scroll position of the targeted element for a Fixed Panel
      if (this.headerEl && (0, _hasClass.default)('spark-header--fixed')) {
        // If the Header is fixed, the height of the header is factored into the calculations
        targetScrollPosition = this.scrolledToEl.getBoundingClientRect().top + window.pageYOffset - ((0, _outerHeight.default)(this.el) + (0, _outerHeight.default)(this.headerEl));
      } else {
        targetScrollPosition = this.scrolledToEl.getBoundingClientRect().top + window.pageYOffset - (0, _outerHeight.default)(this.el);
      }

      // If the current scroll position is greater or equal to the top of the target position
      // than the Fixed Panel hides, else it remains visible
      if (this.currentScrollPosition >= targetScrollPosition && this.currentScrollPosition > 0) {
        if (this.transitionComplete) {
          this.hidePanel();
        }
        if (this.transitionComplete && this.headerHideOnScroll && this.scrolledToEl && this.headerEl.contains(this.el)) {
          this.transitionComplete = false;
          var self = this;

          // Prevents the panel from 'snapping' around due to the transition into and out of
          // the header in the markup by only doing so at transitionend
          window.addEventListener('transitionend', function makeElementSibling(e) {
            if (!e || self.el.getBoundingClientRect().bottom >= 0) return;
            self.headerEl.parentNode.insertBefore(self.el, self.headerEl.nextElementSibling);
            self.transitionComplete = true;
            this.window.removeEventListener('transitionend', makeElementSibling, false);
            if (!(self.currentScrollPosition > 0)) {
              self.showPanel();
            }
          }, false);
        }
      } else {
        if (this.transitionComplete) {
          this.showPanel();
        }
        if (this.transitionComplete && this.headerHideOnScroll && this.scrolledToEl && !this.headerEl.contains(this.el)) {
          this.transitionComplete = false;
          var _self = this;

          // Prevents the panel from 'snapping' around due to the transition into and out of
          // the header in the markup by only doing so at transitionend
          window.addEventListener('transitionend', function makeElementChild(e) {
            if (!e || _self.el.getBoundingClientRect().top < 0) return;
            _self.headerEl.appendChild(_self.el);

            // Edge was redoing the transition after moving the HTML, so we remove the transition
            // markup when it's done moving so it doesnt reanimate. Abandon all hope ye who enter here
            if (this.navigator.userAgent.indexOf('Edge') > -1) {
              this.addEventListener('transitionstart', function stopTransition(e) {
                if (!e || _self.el.getBoundingClientRect().top >= targetScrollPosition) return;
                _self.el.style.transform = 'none';
                _self.el.style.transition = '0s';

                // Need to wait for it to stop or else it won't actually remove the style
                this.addEventListener('transitionend', function removeStyles(e) {
                  if (!e) return;
                  _self.el.removeAttribute('style');
                  this.removeEventListener('transitionend', removeStyles, false);
                }, false);
                this.removeEventListener('transitionstart', stopTransition, false);
              }, false);
            }
            _self.transitionComplete = true;
            this.window.removeEventListener('transitionend', makeElementChild, false);
          }, false);
        }
      }
    }

    /**
     * This method will apply/disable the condensed class onto the Fixed Panel at the same time as the Header requires
     * use of the Spark Header.
     */
  }, {
    key: "_onHeaderCondense",
    value: function _onHeaderCondense() {
      if ((0, _hasClass.default)(this.headerEl, "spark-header--condensed")) {
        this.condensePanel();
      } else {
        this.extendPanel();
      }
    }
  }]);
  return FixedPanel;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
*/
FixedPanel.prototype._whitelistedParams = ['headerEl', 'scrolledToEl', 'unlockBreakPoint', 'hideOnScroll', 'condenseOnScroll', 'fixToBottom', 'customCondenseClass'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
FixedPanel.prototype.defaults = {
  el: null,
  scrolledToEl: null,
  headerEl: null,
  headerPosition: null,
  headerHeight: null,
  headerTop: null,
  headerPositionFixed: null,
  previousScrollPosition: null,
  currentScrollPosition: null,
  hideOnScroll: null,
  condenseOnScroll: null,
  fixToBottom: null,
  unlockBreakPoint: null,
  customCondenseClass: null,
  foreignHeader: null,
  panelHeight: null,
  transitionComplete: true,
  documentBody: null,
  _onScrollBound: null,
  _onResizeBound: null
};
var _default = FixedPanel;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/add-class":59,"../helpers/dom/breakpoint":60,"../helpers/dom/has-class":61,"../helpers/dom/outer-height":64,"../helpers/dom/parse-attribute":66,"../helpers/dom/remove-class":67,"../helpers/util/debounce":93,"./base":3,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],15:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _isInteger = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/number/is-integer"));
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _hasParent = _interopRequireDefault(require("../helpers/traversal/has-parent"));
var _parseAttribute = require("../helpers/dom/parse-attribute");
var _breakpoint = require("../helpers/dom/breakpoint");
var _mixin = _interopRequireDefault(require("../helpers/util/mixin"));
var _events = _interopRequireDefault(require("../mixins/events"));
var _underlay = _interopRequireDefault(require("./underlay"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * Floating Action Button
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new FloatingActionButton(el, {
                                                                                                                                                                                                                                                                                                                                              *   showUnderlay: true
                                                                                                                                                                                                                                                                                                                                              * });
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/floating-action-button.js
                                                                                                                                                                                                                                                                                                                                              * @since 3.3.0
                                                                                                                                                                                                                                                                                                                                             */
var breakpoints = ['xs', 'sm', 'md', 'lg', 'xl'];
var FloatingActionButton = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(FloatingActionButton, _BaseComponent);
  var _super = _createSuper(FloatingActionButton);
  /**
   * FloatingActionButton Constructor
   * @param {Element} el
   * @param {Object} params
   * @constructor
   */
  function FloatingActionButton(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, FloatingActionButton);
    _this = _super.call(this, el, params);
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    return _this;
  }

  /**
   * Create bound versions of event listener callbacks and store them. Otherwise we cannot
   * unbind from these events later because the function signatures won't match.
   * @private
   */
  (0, _createClass2.default)(FloatingActionButton, [{
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onClickBound = this._onClick.bind(this);
      this._onUnderlayDismissBound = this._onUnderlayDismiss.bind(this);
      this._onKeyDownBound = this._onKeyDown.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     * @private
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.el.addEventListener('click', this._onClickBound);
      this.underlay.on('dismiss', this._onUnderlayDismissBound);
      this.el.addEventListener('keydown', this._onKeyDownBound, true);
    }

    /**
     * Remove event listeners for DOM events.
     * @private
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.el.removeEventListener('click', this._onClickBound);
      this.underlay.off('dismiss', this._onUnderlayDismissBound);
      this.el.removeEventListener('keydown', this._onKeyDownBound, true);
    }

    /**
     * Cache elements.
     * @param {Element} el
     * @private
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.expandEl = this.el.querySelector('.spark-fab-group__expand');
      this.collapseEl = this.el.querySelector('.spark-fab-group__collapse');
      this.underlay = new _underlay.default({
        interactive: true,
        display: false,
        style: 'dark'
      });
    }

    /**
     * Parse parameters from the elements.
     * @private
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      this.isExtendedFab = (0, _hasClass.default)(this.expandEl, 'spark-fab-group__expand--extended') ? true : false;
      this.showUnderlay = this.showUnderlay !== null ? this.showUnderlay : (0, _parseAttribute.boolean)(this.el, 'data-show-underlay', false);
      this.underlayBreakPoint = this.underlayBreakPoint !== null ? this.underlayBreakPoint : (0, _parseAttribute.string)(this.el, 'data-underlay-breakpoint', null);
      this.isActive = (0, _hasClass.default)(this.el, 'expanded');
      this.autoClose = this.autoClose !== null ? this.autoClose : (0, _parseAttribute.boolean)(this.el, 'data-auto-close', true);
    }

    /**
     * Determine whether the Underlay should be shown at a specific breakpoint.
     * @private
     */
  }, {
    key: "_determineUnderlayVisibility",
    value: function _determineUnderlayVisibility() {
      if (typeof this.underlayBreakPoint === 'number' && this.underlayBreakPoint > 0 && window.innerWidth <= this.underlayBreakPoint) {
        // The provided breakpoint is a number and meets necessary criteria for displaying Underlay
        return true;
      } else if (typeof this.underlayBreakPoint === 'string') {
        // The provided breakpoint is a string, so first check if it is numeric in nature
        var breakpointNumCheck = parseInt(this.underlayBreakPoint);
        if ((0, _isInteger.default)(breakpointNumCheck) && breakpointNumCheck > 0 && window.innerWidth <= breakpointNumCheck) {
          // The provided breakpoint converts to an Integer and meets necessary criteria for displaying Underlay
          return true;
        } else {
          // The provided breakpoint does not convert to an Integer so check if it is one of the preset Spark breakpoints
          var setBreakpointIndex = breakpoints.indexOf(this.underlayBreakPoint);
          var currentBreakpointIndex = breakpoints.indexOf((0, _breakpoint.get)(window.innerWidth));
          if (currentBreakpointIndex <= setBreakpointIndex && setBreakpointIndex !== -1) {
            return true;
          }
        }
      }

      // The provided breakpoint does not meet the appropriate types so do not show Underlay
      return false;
    }

    /**
     * Expand the FAB Group options and animate the width of the expand button if it is an extended FAB.
     * @public
     */
  }, {
    key: "expand",
    value: function expand() {
      // If both showUnderlay and underlayBreakPoint configs are set, determine whether
      // we should show Underlay based on current viewport size.
      if (this.showUnderlay && this.underlayBreakPoint) {
        if (this._determineUnderlayVisibility()) {
          this.underlay.show({
            interactive: true,
            style: 'dark'
          });
        }
      } else if (this.showUnderlay) {
        this.underlay.show({
          interactive: true,
          style: 'dark'
        });
      }
      (0, _addClass.default)(this.el, 'expanded');
      var collapseBtnWidth = this.collapseEl.offsetWidth;
      var expandBtnWidth = this.expandEl.offsetWidth;
      if (this.isExtendedFab) {
        this.expandEl.setAttribute('data-width', expandBtnWidth);
        requestAnimationFrame(function () {
          this.expandEl.style.width = expandBtnWidth + 'px';
          requestAnimationFrame(function () {
            this.expandEl.style.width = collapseBtnWidth + 'px';
          }.bind(this));
        }.bind(this));
      }
      this.expandEl.setAttribute('tabindex', '-1');
      this.expandEl.setAttribute('aria-expanded', 'true');
      this.collapseEl.focus();
      this.isActive = true;
      this.trigger('expand');
      this.onExpand.call(this);
    }

    /**
     * Collapse the FAB Group options and animate the width of the expand button if it is an extended FAB.
     * @public
     */
  }, {
    key: "collapse",
    value: function collapse() {
      if (this.showUnderlay) {
        if (this.underlay.active) this.underlay.hide();
      }
      (0, _removeClass.default)(this.el, 'expanded');
      if (this.isExtendedFab) {
        this.expandEl.style.width = this.expandEl.getAttribute('data-width') + 'px';
        this.expandEl.addEventListener('transitionend', this._removeButtonAttributes());
      }
      this.expandEl.removeAttribute('tabindex');
      this.expandEl.setAttribute('aria-expanded', 'false');
      this.expandEl.focus();
      this.isActive = false;
      this.trigger('collapse');
      this.onCollapse.call(this);
    }

    /**
     * Remove attributes from the expand button and remove its event listener.
     * @private
     */
  }, {
    key: "_removeButtonAttributes",
    value: function _removeButtonAttributes() {
      this.expandEl.removeAttribute('style');
      this.expandEl.removeAttribute('data-width');
      this.expandEl.removeEventListener('transitionend', this._removeButtonAttributes);
    }

    /**
     * When the underlay is dismissed, collapse the FAB Group options.
     * @private
     */
  }, {
    key: "_onUnderlayDismiss",
    value: function _onUnderlayDismiss() {
      this.collapse();
    }

    /**
     * When a control in the FAB Group is clicked, determine if we need to expand or collapse the options.
     * @param {Object} e
     * @private
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      if (!this.el.contains(e.target)) {
        return;
      }

      // If Expand or Collapse buttons are clicked
      if (e.target === this.expandEl || (0, _hasParent.default)(e.target, this.expandEl)) {
        this.expand();
        return;
      } else if (e.target === this.collapseEl || (0, _hasParent.default)(e.target, this.collapseEl)) {
        this.collapse();
        return;
      }

      // If related actions are clicked, determine whether FAB Group should be collapsed
      if (this.autoClose) {
        this.collapse();
      }
    }

    /**
     * When a key is pressed, determine if it is the Tab Key or Esc key.
     * On Tab, cycle through the options in the FAB Group if it is expanded.
     * On ESC, close the FAB Group if the underlay is currently active.
     * @param {Object} e
     * @private
     */
  }, {
    key: "_onKeyDown",
    value: function _onKeyDown(e) {
      if (!this.showUnderlay || !this.underlay.active) {
        return;
      }
      var TAB_KEY_CODE = 9;
      var ESC_KEY_CODE = 27;
      switch (e.keyCode) {
        case ESC_KEY_CODE:
          this.collapse();
          break;
        case TAB_KEY_CODE:
          {
            var fabFocusableEls = this.el.querySelectorAll('a[href]:not([tabindex^="-"]):not([disabled]), button:not([tabindex^="-"]):not([disabled]), [tabindex]:not([tabindex^="-"]):not([disabled]), [tabindex="0"]');
            if (fabFocusableEls.length > 0) {
              var focusableElements = (0, _slice.default)(Array.prototype).call(fabFocusableEls);
              if (focusableElements.length === 1) {
                e.preventDefault();
              } else if (e.shiftKey && document.activeElement === focusableElements[0]) {
                e.preventDefault();
                focusableElements[focusableElements.length - 1].focus();
              } else if (!e.shiftKey && document.activeElement === focusableElements[focusableElements.length - 1]) {
                e.preventDefault();
                focusableElements[0].focus();
              }
            }
            break;
          }
        default:
          return;
      }
    }

    /**
     * Return state of the FAB Group i.e. whether expanded(true) or collapsed(false).
     * @return {Boolean}
     * @public
     */
  }, {
    key: "active",
    get: function get() {
      return this.isActive;
    }
  }]);
  return FloatingActionButton;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
FloatingActionButton.prototype._whitelistedParams = ['showUnderlay', 'underlayBreakPoint', 'autoClose', 'onCollapse', 'onExpand'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
FloatingActionButton.prototype.defaults = {
  el: null,
  isActive: false,
  showUnderlay: null,
  underlayBreakPoint: null,
  autoClose: null,
  onCollapse: function onCollapse() {},
  onExpand: function onExpand() {}
};
(0, _mixin.default)(FloatingActionButton.prototype, _events.default);
var _default = FloatingActionButton;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/add-class":59,"../helpers/dom/breakpoint":60,"../helpers/dom/has-class":61,"../helpers/dom/parse-attribute":66,"../helpers/dom/remove-class":67,"../helpers/traversal/has-parent":91,"../helpers/util/mixin":96,"../mixins/events":103,"./base":3,"./underlay":51,"@babel/runtime-corejs3/core-js-stable/instance/slice":115,"@babel/runtime-corejs3/core-js-stable/number/is-integer":120,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],16:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));
var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _menu = _interopRequireDefault(require("./menu"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _appendChildren = _interopRequireDefault(require("../helpers/manipulation/append-children"));
var _insertBefore = _interopRequireDefault(require("../helpers/manipulation/insert-before"));
var _breakpoint = require("../helpers/dom/breakpoint");
var _parseAttribute = require("../helpers/dom/parse-attribute");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Header
                                                                                                                                                                                                                                                                                                                                              * A primary page header/navigation.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Header(el, {
                                                                                                                                                                                                                                                                                                                                              *   // Optional. Alternate breakpoint values.
                                                                                                                                                                                                                                                                                                                                              *   breakpoints: {
                                                                                                                                                                                                                                                                                                                                              *    xs: {
                                                                                                                                                                                                                                                                                                                                              *      min: 0,
                                                                                                                                                                                                                                                                                                                                              *      max: 639
                                                                                                                                                                                                                                                                                                                                              *    }
                                                                                                                                                                                                                                                                                                                                              *    // ...
                                                                                                                                                                                                                                                                                                                                              *  }
                                                                                                                                                                                                                                                                                                                                              * });
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/header.js
                                                                                                                                                                                                                                                                                                                                              */
var Header = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(Header, _BaseComponent);
  var _super = _createSuper(Header);
  /**
   * Header constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function Header(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Header);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    _this._determineInitialSize();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Update the elements used.
   * @param {Element} el Optional
   */
  (0, _createClass2.default)(Header, [{
    key: "update",
    value: function update(el) {
      this._removeEventListeners();
      this._removePlaceholder();
      this._cleanUpOverflowItems();
      this._cacheElements(el || this.el);
      this._parseParams();
      this._addEventListeners();
      this.checkHideOnScroll();
      this.checkFixed();

      // recalculate the menu size for overflow children.
      this._determineMenuSize();
      return this;
    }

    /**
     * Cleans up the nav list overflow items.
     */
  }, {
    key: "_cleanUpOverflowItems",
    value: function _cleanUpOverflowItems() {
      if (this.listMoreListEl.children.length > 0) {
        (0, _appendChildren.default)(this.listEl, this.listMoreListEl.children);
        this._removeListMore();
      }
    }

    /**
     * Check if we should be fixed.
     */
  }, {
    key: "checkFixed",
    value: function checkFixed() {
      if (!this.fixed) {
        return this;
      }
      this.scrollTop = window.pageYOffset !== undefined ? window.pageYOffset : window.document.body.scrollTop;
      var isCondensed = this.scrollTop > this.fixedDistance;
      (0, _toggleClass.default)(this.el, 'spark-header--condensed', isCondensed);
      (0, _toggleClass.default)(document.body, 'spark-header-condensed', isCondensed);
      return this;
    }

    /**
     * Check if we should be hidden on scroll.
     */
  }, {
    key: "checkHideOnScroll",
    value: function checkHideOnScroll() {
      if (!this.hideOnScroll) {
        return this;
      }

      // Insurance in case scrollTop wasn't initialized
      if (this.scrollTop === undefined) {
        this.scrollTop = window.pageYOffset !== undefined ? window.pageYOffset : window.document.body.scrollTop;
      }

      // If the side menu is open, don't scroll the header
      var navMenu = document.querySelector(".spark-header__nav");
      if (navMenu) {
        if ((0, _hasClass.default)(navMenu, 'active')) {
          return this;
        }
      }
      this.previousPosition = this.scrollTop;
      this.scrollTop = window.pageYOffset !== undefined ? window.pageYOffset : window.document.body.scrollTop;
      var isHidden = this.scrollTop <= 0 ? false : this.scrollTop >= this.previousPosition;
      if ((0, _hasClass.default)(this.el, 'hide-header-top') || !(this.scrollTop <= this.previousPosition)) {
        (0, _toggleClass.default)(this.el, 'hide-header-top', isHidden);
      }

      // Disable Popovers when the header hides
      var popButton = document.querySelectorAll(".spark-popover__toggle");
      var pop = document.querySelectorAll('.spark-popover__content, [class*="spark-popover__content--"]');
      if (isHidden) {
        for (var p = 0; p < popButton.length; p++) {
          if (popButton[p].onclick) {
            popButton[p].onclick();
          } else if (popButton[p].click) {
            popButton[p].click();
          }
        }
        for (var _p = 0; _p < pop.length; _p++) {
          pop[_p].parentElement.removeChild(pop[_p]);
        }
      }
      return this;
    }

    /**
     * Store a reference to the tabs list, each tab and each panel.
     * Set which tab is active, or use the first.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.navEl = this.el.querySelector('.spark-header__nav');
      this.menuEl = this.navEl && this.navEl.querySelector('.spark-header__menu');
      this.listEl = this.menuEl && this.menuEl.querySelector('.spark-header__list');
      this.toggleEl = this.el.querySelector('.spark-header__toggle');

      // Create a new instance of the menu component
      if (this.menuEl) {
        if (this.menu) {
          this.menu.update(this.menuEl, {
            onToggle: this._onToggleClickBound = this._onToggleClick.bind(this),
            onKeydown: this._onMenuKeyDownBound = this._onMenuKeyDown.bind(this)
          });
        } else {
          this.menu = new _menu.default(this.menuEl, {
            onToggle: this._onToggleClickBound = this._onToggleClick.bind(this),
            onKeydown: this._onMenuKeyDownBound = this._onMenuKeyDown.bind(this)
          });
        }
      }

      // The items in the list need to show/hide based on the width of the container.
      // Cache these items so we can manipulate their display independent of what is
      // currently in the DOM. Also, create the "More" dropdown which will be shown
      // and hidden based on availabile space.
      if (this.listEl && this.listEl.children.length) {
        this.listEls = (0, _slice.default)(Array.prototype).call(this.listEl.children, 0);
        this._createListMore();
      }

      // Create a clone of the header which will NOT be affected by changes in breakpoint.
      // This lets us continue to measure how many list elements will fit. Since we go to the
      // "condensed" view when we are at the sm/xs breakpoint OR only one item will fit in the nav,
      // we can't rely on breakpoints alone to determine what to show. Without a cloned placeholder
      // it is impossible to continue to measure the available space once we show the condensed view.
      if (this.listEl) {
        this._createPlaceholder();
      }
    }

    /**
     * Get all the elements within the Header Menu that can be focused on
     */
  }, {
    key: "_parseFocusableElements",
    value: function _parseFocusableElements() {
      var headerFocusableEls = this.menuEl.querySelectorAll('a[href]:not([tabindex^="-"]):not([disabled]), button:not([tabindex^="-"]):not([disabled]), input:not([tabindex^="-"]):not([disabled]), select:not([tabindex^="-"]):not([disabled]), textarea:not([tabindex^="-"]):not([disabled]), [tabindex]:not([tabindex^="-"]):not([disabled]), [tabindex="0"]');
      if (headerFocusableEls.length > 0) {
        this.focusableElements = (0, _slice.default)(Array.prototype).call(headerFocusableEls);
        this.firstHeaderFocusableEl = this.focusableElements[0];
        this.lastHeaderFocusableEl = this.focusableElements[this.focusableElements.length - 1];
      }
    }

    /**
     * Parse parameters from the elements.
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      this.fixed = this.fixed !== null ? this.fixed : (0, _hasClass.default)(this.el, 'spark-header--fixed');
      this.fixedDistance = this.fixedDistance !== null ? this.fixedDistance : (0, _parseAttribute.number)(this.el, 'data-fixed-distance', 10);
      this.hideOnScroll = this.hideOnScroll !== null ? this.hideOnScroll : (0, _parseAttribute.boolean)(this.el, 'data-hide-on-scroll', false);

      // Initialize the scrollTop value so it isn't undefined initially
      if (this.hideOnScroll) {
        this.scrollTop = window.pageYOffset !== undefined ? window.pageYOffset : window.document.body.scrollTop;
      }

      // If the data-hide-on-scroll wasn't added, add it so other elements can see it
      if (this.hideOnScroll && !(0, _parseAttribute.boolean)(this.el, 'data-hide-on-scroll', false)) {
        this.el.setAttribute('data-hide-on-scroll', '');
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._determineInitialSizeBound = this._determineInitialSize.bind(this);
      this._onResizeBound = this._onResize.bind(this);
      this._onScrollBound = this._onScroll.bind(this);
      this._onNavClickBound = this._onNavClick.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      if (this.fixed || this.hideOnScroll) {
        window.addEventListener('scroll', this._onScrollBound);
      }
      if (!this.listEl) {
        return;
      }
      window.addEventListener('resize', this._onResizeBound);
      window.addEventListener('orientationchange', this._onResizeBound);
      if (this.toggleEl) {
        this.toggleEl.addEventListener('click', this._onToggleClickBound);
      }
      if (this.navEl) {
        this.navEl.addEventListener('click', this._onNavClickBound);
      }
      if (this.menuEl) {
        this.menuEl.addEventListener('keydown', this._onMenuKeyDownBound, true);
      }
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      if (!this.listEl) {
        return;
      }
      window.removeEventListener('resize', this._onResizeBound);
      window.removeEventListener('orientationchange', this._onResizeBound);
      if (this.toggleEl) {
        this.toggleEl.removeEventListener('click', this._onToggleClickBound);
      }
      if (this.navEl) {
        this.navEl.removeEventListener('click', this._onNavClickBound);
      }
      if (this.fixed) {
        window.removeEventListener('scroll', this._onScrollBound);
      }
      if (this.menuEl) {
        this.menuEl.removeEventListener('keydown', this._onMenuKeyDownBound);
      }
    }

    /**
     * Get the current breakpoint for the header.
     */
  }, {
    key: "_getCurrentBreakpoint",
    value: function _getCurrentBreakpoint() {
      this.lastBreakpoint = this.currentBreakpoint;
      this.currentBreakpoint = (0, _breakpoint.get)(this.el.clientWidth, this.breakpoints);
      this.el.setAttribute('data-breakpoint', this.currentBreakpoint);
    }

    /**
     * Create a placeholder for the whole header so that we can keep track
     * of the width of each child element regardless of whether or not we're
     * condensed. Condensed styles do not apply to instances of the element
     * with the placeholder class.
     */
  }, {
    key: "_createPlaceholder",
    value: function _createPlaceholder() {
      var div = document.createElement('div');
      div.innerHTML = this.navEl.outerHTML;
      var el = div.children[0];
      el.setAttribute('aria-hidden', true);
      (0, _addClass.default)(el, 'spark-header__placeholder');
      this.el.appendChild(el);

      // Cache the common elements
      this.placeholder = {
        el: el,
        menuEl: el.querySelector('.spark-header__menu'),
        listEl: el.querySelector('.spark-header__list')
      };

      // Add a copy of the "more" button to the list so we always know what size it would be
      if (this.listMoreEl) {
        this.placeholder.listEl.innerHTML += this.listMoreEl.outerHTML;
        this.placeholder.listMoreEl = this.placeholder.listEl.querySelector('.spark-header__more');
      }
      this._disablePlaceholderLinkTab(el);
    }

    /**
     * Remove the placeholder
     */
  }, {
    key: "_removePlaceholder",
    value: function _removePlaceholder() {
      if (this.placeholder) {
        this.placeholder.el.parentNode.removeChild(this.placeholder.el);
        this.placeholder.menuEl.parentNode.removeChild(this.placeholder.menuEl);
        this.placeholder.listEl.parentNode.removeChild(this.placeholder.listEl);
      }
      if (this.listMoreEl) {
        this.placeholder.listMoreEl.parentNode.removeChild(this.placeholder.listMoreEl);
      }
    }

    /**
     * Disable tabbing for items in the placeholder.
     * @param {Element} el
     */
  }, {
    key: "_disablePlaceholderLinkTab",
    value: function _disablePlaceholderLinkTab(el) {
      // Set a negative tab index on each link in the placeholder
      var links = el.querySelectorAll('a');
      for (var i = 0; i < links.length; i++) {
        links.item(i).setAttribute('tabindex', '-1');
      }

      // Set a negative tab index on each button in the placeholder
      var buttons = el.querySelectorAll('button');
      for (var k = 0; k < buttons.length; k++) {
        buttons.item(k).setAttribute('tabindex', '-1');
      }

      // Set a negative tab index on the role="menu" element as it becomes focusable
      // when tabbing through and other elements are not focusable
      var menu = el.querySelector('.spark-header__menu');
      menu.setAttribute('tabindex', '-1');
    }

    /**
     * Create a place to store overflow items of the list.
     * Also add this item to the placeholder element so we always know
     * which size it would be.
     */
  }, {
    key: "_createListMore",
    value: function _createListMore() {
      var div = document.createElement('div');
      div.innerHTML = '<li><a class="spark-menu__list-link spark-menu__ignore" tabindex="0" title="More Items"><i class="spark-icon-menu-ellipsis-horizontal spark-icon--fill"></i></a><ul class="spark-menu__list"></ul></li>';
      var li = div.children[0];
      (0, _addClass.default)(li, 'spark-menu__list-item spark-header__more spark-no-animate');
      this.listMoreEl = li;
      this.listMoreListEl = li.querySelector('ul');
    }

    /**
     * Determine the menu size..
     */
  }, {
    key: "_determineInitialSize",
    value: function _determineInitialSize() {
      (0, _addClass.default)(this.el, 'spark-header--visible');
      this._determineMenuSize();
    }

    /**
     * Determine how many nav items can fit.
     */
  }, {
    key: "_determineMenuSize",
    value: function _determineMenuSize() {
      // Don't do anything w/o primary nav.
      if (!this.el || !this.listEls || !this.listEls.length) {
        return;
      }

      // If we're at the XS or SM breakpoint, don't worry about this stuff.
      if (this._isMenuBreakpoint(['xs', 'sm'])) {
        this._removeListMore();
        return this._toggleCollapsed(true);
      }

      // Get the items to show and hide
      var items = this._getItemsToShowAndHide();

      // Add a class saying that the size has been determined. This removes the overflow:hidden
      // so that dropdowns will appear.
      (0, _addClass.default)(this.el, 'spark-header--overflow-checked');

      // If there are less than two elements to show and we have hidden elements, collapse the nav.
      if (items.show.length < 2 && items.hide.length) {
        this._removeListMore();
        return this._toggleCollapsed(true);
      }

      // We aren't at the XS breakpoint and there aren't too few items to show, so disable collapsing
      this._toggleCollapsed(false);

      // If the number of children to hide is the same as those already hidden, stop.
      if (items.hide.length === this.listMoreListEl.children.length) {
        if (!items.hide.length) {
          this._removeListMore();
        }
        return;
      }

      // Add the elements we're supposed to show before the "more element"
      (0, _insertBefore.default)(this.listEl, this.listMoreEl, items.show);

      // If we have items to hide, append them to the more element
      if (items.hide.length) {
        var _context, _context2;
        (0, _appendChildren.default)(this.listMoreListEl, items.hide);
        var hasShowActive = (0, _filter.default)(_context = items.show).call(_context, function (element) {
          return (0, _hasClass.default)(element, 'active');
        }).length > 0;
        var hasHideActive = (0, _filter.default)(_context2 = items.hide).call(_context2, function (element) {
          return (0, _hasClass.default)(element, 'active');
        }).length > 0;
        if (hasShowActive) {
          (0, _removeClass.default)(this.listMoreEl, 'child-active open');
        }
        if (hasHideActive) {
          (0, _addClass.default)(this.listMoreEl, 'child-active open');
        }

        // Otherwise, remove the more element
      } else {
        this._removeListMore();
      }
    }

    /**
     * Listen for the ready state change and rerun the menu size determination.
     */
  }, {
    key: "_listenForReadyStateChange",
    value: function _listenForReadyStateChange() {
      // Already loaded
      if (document.readyState === 'complete' || document.readyState === 'loaded') {
        return;
      }

      // Bound listener
      var run = function () {
        if (document.readyState === 'complete' || document.readyState === 'loaded') {
          this._determineMenuSize();
          document.removeEventListener('readystatechange', run);
        }
      }.bind(this);

      // Only run once
      document.addEventListener('readystatechange', run);
    }

    /**
     * Check the primary nav breakpoint.
     * @param {String|Array} name A string or array of string names of breakpoints to check for
     */
  }, {
    key: "_isMenuBreakpoint",
    value: function _isMenuBreakpoint(name) {
      this._getCurrentBreakpoint();
      return name instanceof Array ? name.indexOf(this.currentBreakpoint) !== -1 : this.currentBreakpoint === 'xs';
    }

    /**
     * Get the items to show and hide.
     * @return {Object}
     */
  }, {
    key: "_getItemsToShowAndHide",
    value: function _getItemsToShowAndHide() {
      var width = this.placeholder.listEl.clientWidth;
      var children = this.placeholder.listEl.children;
      var i = 0;
      var len = children.length;
      var hideIndex = -1;
      this._addListMore();

      // Always include the width of the more button.
      var childrenWidth = this.placeholder.listMoreEl.clientWidth || 0;

      // Loop through the children until we hit a point where they don't fit anymore
      for (; i < len && hideIndex === -1; i++) {
        childrenWidth += children[i].clientWidth;
        if (childrenWidth > width) {
          hideIndex = i;
        }
      }

      // Find all the children that fit and don't fit
      var items = {
        show: hideIndex !== -1 ? (0, _slice.default)(Array.prototype).call(this.listEls, 0, hideIndex) : this.listEls,
        hide: hideIndex !== -1 ? (0, _slice.default)(Array.prototype).call(this.listEls, hideIndex) : []
      };
      return items;
    }

    /**
     * Add a placeholder for overflow items to the list.
     */
  }, {
    key: "_addListMore",
    value: function _addListMore() {
      if (this.listMoreEl.parentNode !== this.listEl) {
        this.listEl.appendChild(this.listMoreEl);
      }
    }

    /**
     * Remove a placeholder for overflow items from the primary nav.
     */
  }, {
    key: "_removeListMore",
    value: function _removeListMore() {
      if (this.listMoreEl.parentNode) {
        this.listMoreEl.parentNode.removeChild(this.listMoreEl);
      }
    }

    /**
     * Reset the children of the primary navigation.
     */
  }, {
    key: "_resetMenuChildren",
    value: function _resetMenuChildren() {
      (0, _removeClass.default)(this.el, 'spark-header--overflow-checked');
      (0, _appendChildren.default)(this.listEl, this.listEls);
    }

    /**
     * Toggle the collapsed nav style.
     * @param {Boolean} enable
     */
  }, {
    key: "_toggleCollapsed",
    value: function _toggleCollapsed(enable) {
      // Same collapsed state is already set
      if (enable === this.isCollapsed) {
        return;
      }

      // Reset children and remove a special no-animate class to top-level items when we collapse
      if (enable) {
        this._enableTopLevelToggling();
        this._resetMenuChildren();
      } else {
        if (this.menu) {
          this.menu._removeAllCachedLists();
        }
        this._disableTopLevelToggling();
      }
      this.isCollapsed = enable;
      (0, _toggleClass.default)(this.el, 'spark-header--collapsed', enable);
      (0, _toggleClass.default)(this.el, 'spark-header--visible', !enable);
    }

    /**
     * Enable toggling on top-level items.
     */
  }, {
    key: "_enableTopLevelToggling",
    value: function _enableTopLevelToggling() {
      var i = 0;
      var len = this.listEls.length;
      for (; i < len; i++) {
        (0, _removeClass.default)(this.listEls[i], 'spark-no-animate');
      }
    }

    /**
     * Disable toggling on top-level items.
     */
  }, {
    key: "_disableTopLevelToggling",
    value: function _disableTopLevelToggling() {
      var i = 0;
      var len = this.listEls.length;
      for (; i < len; i++) {
        (0, _addClass.default)(this.listEls[i], 'spark-no-animate');
      }
    }

    /**
     * When the window resizes, redetermine the size of the primary nav elements.
     */
  }, {
    key: "_onResize",
    value: function _onResize() {
      this._determineMenuSize();

      // If we are fixed, do the scroll check
      if (this.fixed && !this.hideOnScroll) {
        this.checkFixed();
      }
    }

    /**
     * Check to see if the header should be fixed.
     * @param {Object} e
     */
  }, {
    key: "_onScroll",
    value: function _onScroll() {
      if (this.hideOnScroll) {
        this.checkHideOnScroll();
      } else {
        this.checkFixed();
      }
    }

    /**
     * When the toggle is clicked, toggle the active state on the nav
     * @param {Object} e
     */
  }, {
    key: "_onToggleClick",
    value: function _onToggleClick(e) {
      e.preventDefault();
      this.isActive = !this.isActive;
      (0, _toggleClass.default)(this.navEl, 'active', this.isActive);
      this.menu._openActiveParents();
      if (this.menuEl && this.isActive) {
        // When the menu is expanded, determine which elements are focusable to
        // allow focus to be set to the first focusable element.
        this._parseFocusableElements();
        if (this.focusableElements && this.focusableElements.length > 0) {
          this.firstHeaderFocusableEl.focus();
        }
      } else {
        // When the menu is collapsed, set focus to the Hamburger toggle element.
        this.toggleEl.focus();
      }
    }

    /**
     * Close the Hamburger menu
     */
  }, {
    key: "closeHamburgerMenu",
    value: function closeHamburgerMenu() {
      this.isActive = false;
      (0, _removeClass.default)(this.navEl, 'active');

      // Set focus to the Hamburger toggle
      this.toggleEl.focus();
    }

    /**
     * When the nav's underlay is clicked, set to inactive.
     * @param {Object} e
     */
  }, {
    key: "_onNavClick",
    value: function _onNavClick(e) {
      if (this.listEls || this.listEls.length) {
        (0, _removeClass.default)(this.listMoreEl, 'open');
      }
      if (e.target === this.navEl && this.isCollapsed) {
        this.closeHamburgerMenu();
      }
    }

    /**
     * When a key is pressed while within the Menu
     * @param {Object} e
     */
  }, {
    key: "_onMenuKeyDown",
    value: function _onMenuKeyDown(e) {
      // If the Hamburger menu is expanded and a user presses the Esc key then collapse the menu
      if (this.isCollapsed && this.isActive && e.keyCode === 27) {
        this.closeHamburgerMenu();
      }

      // Determine the focusable elements when Enter, Space or Tab keys are pressed as these
      // are the keys used to traverse the Menu links. The number of focusable elements could
      // change as nested menus are expanded or collapsed, and the last focusable element could
      // change if the last link is within an expanded nested menu.
      if (this.menuEl && (e.keyCode === 9 || e.keyCode === 13 || e.keyCode === 32)) {
        this._parseFocusableElements();
      }
      if (this.isCollapsed && this.isActive && e.keyCode === 9) {
        if (this.focusableElements.length === 1) {
          e.preventDefault();
        }
        if (e.shiftKey) {
          if (document.activeElement === this.firstHeaderFocusableEl) {
            e.preventDefault();
            this.lastHeaderFocusableEl.focus();
          }
        } else {
          if (document.activeElement === this.lastHeaderFocusableEl) {
            e.preventDefault();
            this.firstHeaderFocusableEl.focus();
          }
        }
      }
    }
  }]);
  return Header;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
Header.prototype._whitelistedParams = ['breakpoints', 'fixed', 'fixedDistance', 'hideOnScroll'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
Header.prototype.defaults = {
  el: null,
  fixed: null,
  fixedDistance: null,
  navEl: null,
  menuEl: null,
  listEl: null,
  listEls: null,
  listMoreEl: null,
  listMoreListEl: null,
  placeholder: null,
  toggleEl: null,
  lastBreakpoint: null,
  currentBreakpoint: null,
  isActive: false,
  isCollapsed: null,
  menu: null,
  breakpoints: null,
  hideOnScroll: null,
  _onResizeBound: null,
  _onScrollBound: null,
  _onToggleClickBound: null,
  _onNavClickBound: null,
  _onMenuKeyDownBound: null
};
var _default = Header;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/add-class":59,"../helpers/dom/breakpoint":60,"../helpers/dom/has-class":61,"../helpers/dom/parse-attribute":66,"../helpers/dom/remove-class":67,"../helpers/dom/toggle-class":68,"../helpers/manipulation/append-children":73,"../helpers/manipulation/insert-before":75,"./base":3,"./menu":18,"@babel/runtime-corejs3/core-js-stable/instance/filter":110,"@babel/runtime-corejs3/core-js-stable/instance/slice":115,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],17:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _getParent = _interopRequireDefault(require("../helpers/traversal/get-parent"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _debounce = _interopRequireDefault(require("../helpers/util/debounce"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _breakpoint = require("../helpers/dom/breakpoint");
var _fixedPanel = _interopRequireDefault(require("./fixed-panel"));
var _panelCarousel = _interopRequireDefault(require("./panel-carousel"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # KPI
                                                                                                                                                                                                                                                                                                                                              * Key Performance Indicator
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new KPI(el, {
                                                                                                                                                                                                                                                                                                                                              *    // ...
                                                                                                                                                                                                                                                                                                                                              *  }
                                                                                                                                                                                                                                                                                                                                              * });
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/kpi.js
                                                                                                                                                                                                                                                                                                                                              */
var KPI = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(KPI, _BaseComponent);
  var _super = _createSuper(KPI);
  /**
   * KPI constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function KPI(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, KPI);
    _this = _super.call(this, el, params);
    if (!el) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    if ((0, _hasClass.default)(_this.el, 'spark-kpi--tabs')) {
      _this._hasTabs = true;
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    _this._calcBreakpoint();
    _this._updateOrientation();
    _this._initFixedPanel(el, params);
    _this._initPanelCarousel(el, params);
    return _this;
  }

  /**
   * If using a locked panel create a Fixed Panel Component and pass along config options
   */
  (0, _createClass2.default)(KPI, [{
    key: "_initFixedPanel",
    value: function _initFixedPanel() {
      if (this.lockPanel === true) {
        (0, _addClass.default)(this.el, 'spark-panel--fixed');
        (0, _addClass.default)(this.el, 'spark-panel--shadow-0');
        (0, _addClass.default)(this.el, 'spark-panel--border-0');
        this.fixedPanel = new _fixedPanel.default(this.el, {
          condenseOnScroll: this.condenseOnScroll,
          unlockBreakPoint: this.stackBreakPoint,
          fixToBottom: this.fixToBottom,
          customCondenseClass: this.customCondenseClass,
          scrolledToEl: this.scrolledToEl,
          hideOnScroll: this.hideOnScroll || false,
          headerEl: this.headerEl
        });
      }
    }

    /**
     * Add Panel Carousel Functionality pass parameters to the them
     */
  }, {
    key: "_initPanelCarousel",
    value: function _initPanelCarousel() {
      if (!(0, _hasClass.default)(this.el, '.spark-panel-carousel')) {
        (0, _addClass.default)(this.el, 'spark-panel-carousel');
      }
      if (!(0, _hasClass.default)(this.el.querySelector('.spark-kpi__list'), 'spark-panel-carousel__list')) {
        (0, _addClass.default)(this.el.querySelector('.spark-kpi__list'), 'spark-panel-carousel__list');
      }
      if (!(0, _hasClass.default)(this.el.querySelector('.spark-kpi__item'), 'spark-panel-carousel__item')) {
        var items = this.el.querySelectorAll('.spark-kpi__item');
        for (var i = 0; i < items.length; i++) {
          (0, _addClass.default)(items[i], 'spark-panel-carousel__item');
        }
      }
      this.panelCarousel = new _panelCarousel.default(this.el, {
        noCarouselBreakPoint: this.stackBreakPoint,
        singleCarouselAdvance: this.singleCarouselAdvance,
        controlBreakPoint: this.controlBreakPoint,
        nextLabel: this.nextLabel,
        previousLabel: this.previousLabel,
        hasTabs: this._hasTabs
      });
    }

    /**
     * Add event listeners
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      window.addEventListener('resize', this._onResizeBound);
      if (this._hasTabs === true) {
        this._kpiList.addEventListener('click', this._onTabListClickBound);
      }
    }

    /**
     * Remove components
     */
  }, {
    key: "remove",
    value: function remove() {
      this.panelCarousel.remove();
      if (this.lockPanel === true) {
        this.lockPanel.remove();
      }
      (0, _get2.default)((0, _getPrototypeOf2.default)(KPI.prototype), "remove", this).call(this);
    }

    /**
     * Remove event listeners
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      window.removeEventListener('resize', this._onResizeBound);
      if (this._hasTabs === true) {
        this._kpiList.removeEventListener('click', this._onTabListClickBound);
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onResizeBound = (0, _debounce.default)(this._onResize.bind(this), 90);
      this._onTabListClickBound = this._onTabListClick.bind(this);
    }

    /**
     * Store a reference to the tabs list, each tab and each panel.
     * Set which tab is active, or use the first.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this._currentTab = this.el.querySelector('[aria-selected="true"]');
      this._kpiList = this.el.querySelector('.spark-kpi__list');
      this._kpiItems = this.el.querySelectorAll('.spark-kpi__item');
    }

    /**
     * Window resize event, keeps the carousel fresh... debounced from the listener. an event is passed to the method, but not used.
     */
  }, {
    key: "_onResize",
    value: function _onResize() {
      this._calcBreakpoint();
      this._updateOrientation();
    }

    /**
     * Calculate the current Break point, update flags based on value
     */
  }, {
    key: "_calcBreakpoint",
    value: function _calcBreakpoint() {
      this.currentBreakpoint = (0, _breakpoint.get)(window.innerWidth);
      var breakpoints = ['xs', 'sm', 'md', 'lg', 'xl'];
      var currentBreakIndex = breakpoints.indexOf(this.currentBreakpoint);
      var stackBreakIndex = breakpoints.indexOf(this.stackBreakPoint);
      if (currentBreakIndex <= stackBreakIndex && stackBreakIndex !== -1) {
        this._useStackedKPI = true;
      } else {
        this._useStackedKPI = false;
      }
    }

    /**
     * Update the orientation, row or stacked KPI
     */
  }, {
    key: "_updateOrientation",
    value: function _updateOrientation() {
      if (this._useStackedKPI === true) {
        if (!(0, _hasClass.default)(this.el, 'spark-kpi--column')) {
          (0, _addClass.default)(this.el, 'spark-kpi--column');
          this.el.removeAttribute('data-overflow');
        }
      } else {
        (0, _removeClass.default)(this.el, 'spark-kpi--column');
      }
    }

    /**
     * Tab KPI list was clicked.
     * @param  {clickEvent} _event click
     */
  }, {
    key: "_onTabListClick",
    value: function _onTabListClick(_event) {
      _event.preventDefault();
      var tab = _event.target;
      if (tab.nodeName !== 'A') {
        tab = (0, _getParent.default)(tab, 'a', this.el);
      }
      if (tab === false) {
        return;
      }
      if (this._currentTab !== null) {
        this._currentTab.removeAttribute('aria-selected');
      }
      tab.setAttribute('aria-selected', 'true');
      this._currentTab = tab;
      if (typeof this.onTabClick === 'function') {
        this.onTabClick(tab.getAttribute('aria-controls'), tab, this);
      }
    }
  }]);
  return KPI;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
KPI.prototype._whitelistedParams = ['singleCarouselAdvance', 'lockPanel', 'condenseOnScroll', 'customCondenseClass', 'unlockBreakPoint', 'stackBreakPoint', 'controlBreakPoint', 'fixToBottom', 'hideOnScroll', 'onTabClick', 'scrolledToEl', 'headerEl'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
KPI.prototype.defaults = {
  el: null,
  singleCarouselAdvance: false,
  lockPanel: false,
  condenseOnScroll: true,
  customCondenseClass: 'spark-kpi--condensed',
  unlockBreakPoint: null,
  stackBreakPoint: 'xs',
  controlBreakPoint: 'xs',
  fixToBottom: null,
  hideOnScroll: false,
  onTabClick: null,
  nextLabel: 'show next',
  previousLabel: 'show previous',
  scrolledToEl: null,
  headerEl: null,
  _useControls: true,
  _useStackedKPI: false,
  _currentTab: null,
  _kpiItemsWidth: 0,
  _kpiWidth: 0,
  _kpiChange: 0,
  _positionX: 0,
  _forwardLimit: false,
  _backwardLimit: true,
  _overflow: false,
  _hasTabs: false,
  fixedPanel: null
};
var _default = KPI;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/add-class":59,"../helpers/dom/breakpoint":60,"../helpers/dom/has-class":61,"../helpers/dom/remove-class":67,"../helpers/traversal/get-parent":87,"../helpers/util/debounce":93,"./base":3,"./fixed-panel":14,"./panel-carousel":22,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],18:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _height = _interopRequireDefault(require("../helpers/animation/height"));
var _transform = _interopRequireDefault(require("../helpers/css/transform"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _hasParent = _interopRequireDefault(require("../helpers/traversal/has-parent"));
var _getParent = _interopRequireDefault(require("../helpers/traversal/get-parent"));
var _getParents = _interopRequireDefault(require("../helpers/traversal/get-parents"));
var _getChild = _interopRequireDefault(require("../helpers/traversal/get-child"));
var _wrapElement = _interopRequireDefault(require("../helpers/manipulation/wrap-element"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Menu
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Menu(el, {
                                                                                                                                                                                                                                                                                                                                              *   // Optional. Callback method for when the menu toggles.
                                                                                                                                                                                                                                                                                                                                              *   onToggle: function(){}
                                                                                                                                                                                                                                                                                                                                              * });
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/menu.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var Menu = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(Menu, _BaseComponent);
  var _super = _createSuper(Menu);
  /**
   * Menu constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function Menu(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Menu);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    _this._checkAnimation();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Store a reference to the tabs list, each tab and each panel.
   * Set which tab is active, or use the first.
   * @param {Element} el
   */
  (0, _createClass2.default)(Menu, [{
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.toggleEl = this.el.querySelector('.spark-menu__toggle');
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onClickBound = this._onClick.bind(this);
      this._onFocusBound = this._onFocus.bind(this);
      this._onBlurBound = this._onBlur.bind(this);
      this._onKeydownBound = this._onKeydown.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.el.addEventListener('click', this._onClickBound);
      this.el.addEventListener('focus', this._onFocusBound, true);
      this.el.addEventListener('blur', this._onBlurBound, true);
      this.el.addEventListener('keydown', this._onKeydownBound);
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.el.removeEventListener('click', this._onClickBound);
      this.el.removeEventListener('focus', this._onFocusBound);
      this.el.removeEventListener('blur', this._onBlurBound);
      this.el.removeEventListener('keydown', this._onKeydownBound);
    }

    /**
     * Toggle the open state of an item.
     * @param {Element} item
     */
  }, {
    key: "_toggleItem",
    value: function _toggleItem(item) {
      if ((0, _hasClass.default)(item, 'open')) {
        this._closeItem(item);
      } else {
        this._openItem(item);
      }
    }

    /**
     * Toggle aria-checked state of the Expand/Collapse toggle carets
     * @param {Element} item
     */
  }, {
    key: "_toggleAriaCheckedState",
    value: function _toggleAriaCheckedState(item) {
      if (item.hasAttribute('aria-checked')) {
        var ariaState = item.getAttribute('aria-checked') === 'true';
        item.setAttribute('aria-checked', String(!ariaState));
      }
    }

    /**
     * Check for a nested list and create the wrappers needed
     * for animating the lists
     *
     */
  }, {
    key: "_checkAnimation",
    value: function _checkAnimation() {
      if (this.el.querySelector('.spark-menu__list-next')) {
        this.cachedList = this.cachedList || [];
        this._createMenuAnimationWrapper();
        this._animateListChange();
      }
    }

    /**
     * Create wrapper class to help with animation of sliding lists
     *
     */
  }, {
    key: "_createMenuAnimationWrapper",
    value: function _createMenuAnimationWrapper() {
      if (this.wrapperEl) {
        return;
      }
      var wrapperEl = document.createElement('div');
      (0, _addClass.default)(wrapperEl, 'spark-menu__animation-wrapper');
      (0, _wrapElement.default)(this.el.querySelector('.spark-menu__list'), wrapperEl);
      this.wrapperEl = wrapperEl;
    }

    /**
     * Animate the position of the animation wrapper. Optionally, do
     * so immediately without waiting for an animation.
     * @param {Boolean} noAnimate
     */
  }, {
    key: "_animateListChange",
    value: function _animateListChange(noAnimate) {
      if (noAnimate) {
        (0, _addClass.default)(this.wrapperEl, 'no-animate');
      }

      // Translating at exactly 100% increments results in artifacting on the left side because of subpixel.
      this.wrapperEl.setAttribute('style', (0, _transform.default)('translateX', '-' + this.cachedList.length * 100 + '.2%'));
      if (noAnimate) {
        setTimeout(function () {
          (0, _removeClass.default)(this.wrapperEl, 'no-animate');
        }.bind(this), 1);
      }
    }

    /**
     * Append list to menu element
     * @param {Element} list
     * @param {Boolean} noAnimate
     */
  }, {
    key: "_appendList",
    value: function _appendList(item, noAnimate) {
      // Create wrapper
      this._createMenuAnimationWrapper();
      var newList = item.cloneNode(true);
      (0, _addClass.default)(newList, 'nestedList');
      newList.setAttribute('data-nested-list-id', newList.getAttribute('id'));
      newList.removeAttribute('id');
      if (this.wrapperEl) {
        // Add child node to wrapper
        this.wrapperEl.appendChild(newList);

        // Add to cached Array to keep track of all added lists
        this.cachedList.push(newList);

        // Slide navigation
        this._animateListChange(noAnimate);
      }
    }

    /**
     * Remove list to nav
     *
     */
  }, {
    key: "_removeLastList",
    value: function _removeLastList() {
      // If there are any items to remove
      if (this.cachedList.length) {
        // Retrieve last item from list
        var removeElement = this.cachedList.pop();
        if (this.wrapperEl) {
          // Slide navigation
          this._animateListChange();
        }
        window.setTimeout(function () {
          // Remove itself from DOM
          removeElement.parentNode.removeChild(removeElement);
        }, 250);
      }
    }

    /**
     * Remove all lists from panel menu
     *
     */
  }, {
    key: "_removeAllCachedLists",
    value: function _removeAllCachedLists() {
      if (this.cachedList) {
        // If there are any items to remove
        while (this.cachedList.length) {
          // While there are still items, remove them
          this._removeLastList();
        }
      }
    }

    /**
     * Finds and returns the next nested list
     * @param {Object} item
     * @return {Object}
     */
  }, {
    key: "_getNextList",
    value: function _getNextList(item) {
      return item.querySelector('.spark-menu__list-next') ? document.querySelector(item.querySelector('.spark-menu__list-next').getAttribute('data-menu')) : null;
    }

    /**
     * Open an item by animating it.
     * @param {Object} item
     */
  }, {
    key: "_openItem",
    value: function _openItem(item) {
      // Item is already open
      if ((0, _hasClass.default)(item, 'open')) {
        return;
      }
      (0, _height.default)({
        el: item,
        toggleEl: '.spark-menu__list'
      });
      (0, _addClass.default)(item, 'open');
    }

    /**
     * Close an item by animating it shut.
     * @param {Object} item
     */
  }, {
    key: "_closeItem",
    value: function _closeItem(item) {
      // Item is already closed
      if (!(0, _hasClass.default)(item, 'open')) {
        return;
      }
      (0, _height.default)({
        el: item,
        toggleEl: '.spark-menu__list',
        toggleValue: 'none',
        action: 'collapse'
      });
      (0, _removeClass.default)(item, 'open');
    }

    /**
     * Make an item active.
     * @param {Element} item
     */
  }, {
    key: "_activateItem",
    value: function _activateItem(item) {
      // Item is already active
      if ((0, _hasClass.default)(item, 'active')) {
        return;
      }

      // Deactivate any active items
      var parents = (0, _getParents.default)(item, '.spark-menu__list', this.el);
      this._deactivateItems(parents[parents.length - 1]);
      this._deactivateItemSiblings(item);

      // Add the active class
      (0, _addClass.default)(item, 'active');

      // If there is a parent that is also a list item, open it.
      this._activateItemParents(item, this.el);
    }

    /**
     * Activate parent items.
     * @param {Element} el
     * @param {Element} limitEl
     */
  }, {
    key: "_activateItemParents",
    value: function _activateItemParents(el, limitEl) {
      var parents = (0, _getParents.default)(el.parentNode, '[class*="list-item"]', limitEl);
      var len = parents.length;

      // Add the active class
      for (var i = 0; i < len; i++) {
        this._openItem(parents[i]);
        (0, _addClass.default)(parents[i], 'child-active');
      }
    }

    /**
     * Deactivate items' parents
     * @param {Element} el
     */
  }, {
    key: "_deactivateItemParents",
    value: function _deactivateItemParents(el) {
      var activeParents = el.querySelectorAll('[class*="list-item"].child-active');
      var len = activeParents.length;

      // Remove the active child class
      for (var i = 0; i < len; i++) {
        (0, _removeClass.default)(activeParents.item(i), 'child-active');
      }
    }

    /**
     * Deactivate items.
     * @param {Element} el
     */
  }, {
    key: "_deactivateItems",
    value: function _deactivateItems(el) {
      var actives = el.querySelectorAll('[class*="list-item"].active');
      var len = actives.length;

      // Remove the active class
      for (var i = 0; i < len; i++) {
        (0, _removeClass.default)(actives.item(i), 'active');
      }
      this._deactivateItemParents(el);
    }

    /**
     * Deactivate siblings items.
     * @param {Element} el
     */
  }, {
    key: "_deactivateItemSiblings",
    value: function _deactivateItemSiblings(el) {
      var actives = el.parentNode.querySelectorAll('[class*="list-item"].child-active');
      var len = actives.length;

      // Remove the active class
      for (var i = 0; i < len; i++) {
        (0, _removeClass.default)(actives[i], 'child-active');
        (0, _removeClass.default)(actives[i], 'open');
      }
    }

    /**
     * Open the parents of the active item.
     *
     */
  }, {
    key: "_openActiveParents",
    value: function _openActiveParents() {
      var activeItem = this.el.querySelector('.active');
      if (activeItem) {
        var parentItems = (0, _getParents.default)(activeItem, '.spark-menu__list-item', this.el);
        var itemLinks;
        var nextList;
        for (var i = parentItems.length - 1; i >= 0; i--) {
          itemLinks = (0, _getChild.default)(parentItems[i], '.spark-menu__list-links');
          if (itemLinks && itemLinks.querySelector('.spark-menu__list-next')) {
            nextList = this._getNextList(parentItems[i]);
            if (nextList && !this._cachedListContainsID(nextList.getAttribute('id'))) {
              this._appendList(nextList, true);
            }
          } else {
            (0, _addClass.default)(parentItems[i], 'open');
          }
        }
      }
    }

    /**
     * Check if the cached list contains a certain ID
     * @param {String} id
     * @return {Boolean}
     */
  }, {
    key: "_cachedListContainsID",
    value: function _cachedListContainsID(id) {
      var i = this.cachedList.length;
      while (i--) {
        if (this.cachedList[i].getAttribute('data-nested-list-id') === id) {
          return true;
        }
      }
      return false;
    }

    /**
     * When an item is clicked, make it active. Determine if the click was on an expand
     * button and open the list if so.
     * @todo: It should be possible to opt out of this behavior.
     * @param {Object} e
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      // Don't make forms active
      if ((0, _getParent.default)(e.target, 'form', this.el) || e.target.nodeName.toUpperCase() === 'UL') {
        return;
      }

      // Toggle the visibility of the menu?
      var toggle = e.target === this.toggleEl || (0, _hasParent.default)(e.target, this.toggleEl);
      if (toggle) {
        return (this.onToggle || noop)(e, this);
      }

      // Is there a parent to open and an item?
      var open = (0, _getParent.default)(e.target, '.spark-menu__list-expand', this.el);
      var item = (0, _getParent.default)(e.target, '.spark-menu__list-item', this.el);

      // If we have no item or have been told to ignore the item
      if (!item || (0, _getParent.default)(e.target, '.spark-menu__ignore', this.el)) {
        return;
      }
      if (open) {
        this._toggleAriaCheckedState(open);
        return this._toggleItem(item);
      }

      // Check if we have a valid item and we aren't inside the expanded header
      if (item && !(0, _hasParent.default)(e.target, document.querySelector('.spark-header--visible'))) {
        var next = this._getNextList(item);
        if (next && (0, _hasClass.default)(e.target, 'spark-menu__list-next')) {
          // Active item
          this._activateItem(item);
          this._appendList(next);
          return;
        }
        var back = (0, _getParent.default)(e.target, '.spark-menu__list-back', item);
        if (back && (0, _hasClass.default)(e.target, 'spark-menu__list-back')) {
          this._removeLastList();
          return;
        }
      }

      // Active item
      this._activateItem(item);
    }

    /**
     * When the space or enter key is pressed on a focused item, make it active.
     * Determine if the click was on an expand button or link and open the list if so.
     * @todo: It should be possible to opt out of this behavior.
     * @param {Object} e
     */
  }, {
    key: "_onKeydown",
    value: function _onKeydown(e) {
      var code = e.keyCode || e.which;

      // Don't make forms active
      if ((0, _getParent.default)(e.target, 'form', this.el)) {
        return;
      }

      // Toggle the visibility of the menu?
      var toggle = e.target === this.toggleEl || (0, _hasParent.default)(e.target, this.toggleEl);
      if (toggle && (code === 32 || code === 13)) {
        return (this.onToggle || noop)(e, this);
      }

      // Is there a parent to open and an item?
      var open = (0, _getParent.default)(e.target, '.spark-menu__list-expand', this.el);
      var item = (0, _getParent.default)(e.target, '.spark-menu__list-item', this.el);

      // If we have no item or have been told to ignore the item
      if (!item || (0, _getParent.default)(e.target, '.spark-menu__ignore', this.el)) {
        return;
      }
      if (open) {
        if (code === 32 || code === 13) {
          e.preventDefault();
          this._toggleAriaCheckedState(open);
          return this._toggleItem(item);
        }
      }

      // Check if we have a valid item and we aren't inside the expanded header
      if (item && !(0, _hasParent.default)(e.target, document.querySelector('.spark-header--visible'))) {
        var next = this._getNextList(item);
        if (next && (0, _hasClass.default)(e.target, 'spark-menu__list-next')) {
          if (code === 32 || code === 13) {
            e.preventDefault();

            // Active item
            this._activateItem(item);
            this._appendList(next);
            return;
          }
        }
        var back = (0, _getParent.default)(e.target, '.spark-menu__list-back', item);
        if (back && (0, _hasClass.default)(e.target, 'spark-menu__list-back')) {
          if (code === 32 || code === 13) {
            e.preventDefault();
            this._removeLastList();
            return;
          }
        }
      }
      if (code === 32 || code === 13) {
        this._activateItem(item);
      }
      this.onKeydown.call(this, e, this);
    }

    /**
     * Keep track of when items have focus.
     * @param {Object} e
     */
  }, {
    key: "_onFocus",
    value: function _onFocus(e) {
      var parent = e.target;
      var lastParent = parent;
      while (parent) {
        parent = (0, _getParent.default)(lastParent.parentNode, '.spark-menu__list-item', this.el);
        if (!parent || parent === lastParent) break;
        (0, _addClass.default)(parent, 'has-focus');
        lastParent = parent;
      }
    }

    /**
     * Keep track of when items lose focus.
     * @param {Object} e
     */
  }, {
    key: "_onBlur",
    value: function _onBlur(e) {
      var parent = e.target;
      var lastParent = parent;
      while (parent) {
        parent = (0, _getParent.default)(lastParent.parentNode, '.spark-menu__list-item', this.el);
        if (!parent || parent === lastParent) break;
        (0, _removeClass.default)(parent, 'has-focus');
        lastParent = parent;
      }
    }
  }]);
  return Menu;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
Menu.prototype._whitelistedParams = ['onToggle', 'onKeydown'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
Menu.prototype.defaults = {
  cachedList: null,
  el: null,
  toggleEl: null,
  wrapperEl: null,
  onToggle: function onToggle() {},
  onKeydown: function onKeydown() {},
  _onClickBound: null,
  _onFocusBound: null,
  _onBlurBound: null,
  _onKeydownBound: null
};
var _default = Menu;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/animation/height":52,"../helpers/css/transform":56,"../helpers/dom/add-class":59,"../helpers/dom/has-class":61,"../helpers/dom/remove-class":67,"../helpers/manipulation/wrap-element":76,"../helpers/traversal/get-child":84,"../helpers/traversal/get-parent":87,"../helpers/traversal/get-parents":88,"../helpers/traversal/has-parent":91,"./base":3,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],19:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Modal
                                                                                                                                                                                                                                                                                                                                              * Show content in a modal.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Modal(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/modal.js
                                                                                                                                                                                                                                                                                                                                              */
var Modal = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(Modal, _BaseComponent);
  var _super = _createSuper(Modal);
  /**
   * Modal constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function Modal(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Modal);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Open
   */
  (0, _createClass2.default)(Modal, [{
    key: "open",
    value: function open() {
      this.onBeforeOpen.call(this);
      this.isActive = true;
      document.activeElement ? this.focusedElBeforeOpen = document.activeElement : null;
      this._addWindowEventListeners();
      this._updateClasses();
      (0, _addClass.default)(document.body, 'spark-modal-open');

      // Set focus to close button once modal has been displayed
      if (this.focusableElements && this.focusableElements.length > 0) {
        this.firstModalFocusableEl.focus();
      }
      this.onAfterOpen.call(this);
      return this;
    }

    /**
     * Close
     */
  }, {
    key: "close",
    value: function close() {
      this.onBeforeClose.call(this);
      this.isActive = false;
      this.focusedElBeforeOpen ? this.focusedElBeforeOpen.focus() : null;
      this._removeWindowEventListeners();
      this._updateClasses();
      (0, _removeClass.default)(document.body, 'spark-modal-open');
      this.onAfterClose.call(this);
      return this;
    }

    /**
     * Update the component to use a new element or reparse from
     * the existing element.
     * @param {Element} el Optional
     * @param {Object} params
     */
  }, {
    key: "update",
    value: function update(el) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this._removeEventListeners();
      this._cacheElements(el || this.el, params);
      this._addEventListeners();
      this._updateClasses();
      this._removeWindowEventListeners();
      if (this.isActive) {
        this._addWindowEventListeners();
      }
      return this;
    }

    /**
     * Get all the elements within the Modal that can be focused on
     */
  }, {
    key: "parseFocusableElements",
    value: function parseFocusableElements() {
      var modalFocusableEls = this.modalEl.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex="0"]');
      if (modalFocusableEls.length > 0) {
        this.focusableElements = (0, _slice.default)(Array.prototype).call(modalFocusableEls);
        this.firstModalFocusableEl = this.focusableElements[0];
        this.lastModalFocusableEl = this.focusableElements[this.focusableElements.length - 1];
      }
    }

    /**
     * Store a reference to the element. Either a modal itself
     * or a button referencing a modal may be passed.
     * @param {Element} el
     * @param {Element} params @optional
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el, params) {
      var modalPassed = (0, _hasClass.default)(el, 'spark-modal');
      var modalEl = params.modalEl;
      if (modalPassed) {
        this.modalEl = el;
      } else {
        this.el = el;
        this.modalEl = modalEl || document.querySelector(el.getAttribute('data-modal'));
      }
      this.scrollEl = this.modalEl.querySelector('.spark-modal__scroll') || this.modalEl;
      this.isActive = (0, _hasClass.default)(this.modalEl, 'active');
      this.parseFocusableElements();
    }

    /**
     * Update classes for the open or close state.
     */
  }, {
    key: "_updateClasses",
    value: function _updateClasses() {
      (0, _toggleClass.default)(this.modalEl, 'active', this.isActive);
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onClickBound = this._onClick.bind(this);
      this._onKeyupBound = this._onKeyup.bind(this);
      this._onKeydownBound = this._onKeydown.bind(this);
      this._onModalClickBound = this._onModalClick.bind(this);
      this._onMouseDownBound = this._onMouseDown.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      if (this.el) this.el.addEventListener('click', this._onClickBound);
      if (this.modalEl) {
        this.modalEl.addEventListener('click', this._onModalClickBound);
        this.modalEl.addEventListener('mousedown', this._onMouseDownBound);
      }
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      if (this.el) this.el.removeEventListener('click', this._onClickBound);
      if (this.modalEl) {
        this.modalEl.removeEventListener('click', this._onModalClickBound);
        this.modalEl.removeEventListener('mousedown', this._onMouseDownBound);
      }
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addWindowEventListeners",
    value: function _addWindowEventListeners() {
      this._removeWindowEventListeners();
      window.addEventListener('keyup', this._onKeyupBound);
      window.addEventListener('keydown', this._onKeydownBound);
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeWindowEventListeners",
    value: function _removeWindowEventListeners() {
      window.removeEventListener('keyup', this._onKeyupBound);
      window.removeEventListener('keydown', this._onKeydownBound);
    }

    /**
     * When the button is clicked.
     * @param {Object} e
     */
  }, {
    key: "_onClick",
    value: function _onClick() {
      this.open();
    }

    /**
     * On Mouse Down, capture the target
     * @param {Object} e
     */
  }, {
    key: "_onMouseDown",
    value: function _onMouseDown(e) {
      this._mouseDownTargetEl = e.target;
    }

    /**
     * When we are clicked, toggle the opened state.
     * @param {Object} e
     */
  }, {
    key: "_onModalClick",
    value: function _onModalClick(e) {
      if (this._mouseDownTargetEl === e.target && this._mouseDownTargetEl === this.modalEl || (0, _hasClass.default)(this._mouseDownTargetEl, 'spark-modal__close') || (0, _hasClass.default)(this._mouseDownTargetEl, 'spark-modal__dismiss') || (0, _hasClass.default)(this._mouseDownTargetEl, 'spark-modal__scroll')) {
        this.close();
      }
    }

    /**
     * When tabbing backwards, localize traversal to modal elements only
     * @param {Object} e
     */
  }, {
    key: "_onBackwardTab",
    value: function _onBackwardTab(e) {
      if (document.activeElement === this.firstModalFocusableEl) {
        e.preventDefault();
        this.lastModalFocusableEl.focus();
      }
    }

    /**
     * When tabbing forwards, localize traversal to modal elements only
     * @param {Object} e
     */
  }, {
    key: "_onForwardTab",
    value: function _onForwardTab(e) {
      if (document.activeElement === this.lastModalFocusableEl) {
        e.preventDefault();
        this.firstModalFocusableEl.focus();
      }
    }

    /**
     * When a key is pressed on the window and it's an ESC, close the modal.
     * @param {Object} e
     */
  }, {
    key: "_onKeyup",
    value: function _onKeyup(e) {
      if (e.keyCode === 27) {
        this.close();
      }
    }

    /**
     * When a key is pressed and it is the Tab key or Shift+Tab keys, determine whether to adjust focus
     * @param {Object} e
     */
  }, {
    key: "_onKeydown",
    value: function _onKeydown(e) {
      if (e.keyCode === 9) {
        if (this.focusableElements.length === 1) {
          e.preventDefault();
        }
        if (e.shiftKey) {
          this._onBackwardTab(e);
        } else {
          this._onForwardTab(e);
        }
      }
      if (e.keyCode === 13) {
        if (e.target === document.querySelector('.spark-modal__close') || e.target === document.querySelector('.spark-modal__dismiss')) {
          e.preventDefault();
          this.close();
        }
      }
    }
  }]);
  return Modal;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
Modal.prototype._whitelistedParams = ['onBeforeOpen', 'onAfterOpen', 'onBeforeClose', 'onAfterClose'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
Modal.prototype.defaults = {
  el: null,
  modalEl: null,
  scrollEl: null,
  isActive: false,
  focusableElements: null,
  onBeforeOpen: function onBeforeOpen() {},
  onAfterOpen: function onAfterOpen() {},
  onBeforeClose: function onBeforeClose() {},
  onAfterClose: function onAfterClose() {},
  _onClickBound: null,
  _onKeyupBound: null,
  _onKeydownBound: null,
  _onModalClickBound: null
};
var _default = Modal;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/add-class":59,"../helpers/dom/has-class":61,"../helpers/dom/remove-class":67,"../helpers/dom/toggle-class":68,"./base":3,"@babel/runtime-corejs3/core-js-stable/instance/slice":115,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],20:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _mixin = _interopRequireDefault(require("../helpers/util/mixin"));
var _messaging = _interopRequireDefault(require("../mixins/messaging"));
var _validation = _interopRequireDefault(require("../mixins/validation"));
var _makeElement = _interopRequireDefault(require("../helpers/dom/make-element"));
var _each = _interopRequireDefault(require("../helpers/util/each"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Multiple SelectInput
                                                                                                                                                                                                                                                                                                                                              * A multiple select input container.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new MultiSelectInput(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/multi-select-input.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var MultiSelectInput = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(MultiSelectInput, _BaseComponent);
  var _super = _createSuper(MultiSelectInput);
  /**
   * MultiSelectInput constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function MultiSelectInput(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, MultiSelectInput);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Get the value.
   * @return {Array}
   */
  (0, _createClass2.default)(MultiSelectInput, [{
    key: "getValue",
    value: function getValue() {
      var vals = [];
      (0, _each.default)(this._isNative ? this.selectEl.options : this.checkboxEls, function (o) {
        if (o.checked || o.selected) {
          vals.push(o.value);
        }
      });
      return vals;
    }

    /**
     * Set the value.
     * @param {Array} vals
     */
  }, {
    key: "setValue",
    value: function setValue(vals) {
      var setVals = [];
      var propName = this._isNative ? 'selected' : 'checked';
      (0, _each.default)(this._isNative ? this.selectEl.options : this.checkboxEls, function (o) {
        if (vals.indexOf(o.value) !== -1) {
          o[propName] = true;
          setVals.push(o.value);
        } else {
          o[propName] = false;
        }
      });
      (this.onChange || noop)(setVals, this);
      return this;
    }

    /**
     * Clear the selected value.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      return this.setValue([]);
    }

    /**
     * Disable entry into the input.
     */
  }, {
    key: "disable",
    value: function disable() {
      (this.selectEl || this.el).setAttribute('disabled', '');
      return this;
    }

    /**
     * Enable entry into the input.
     */
  }, {
    key: "enable",
    value: function enable() {
      (this.selectEl || this.el).removeAttribute('disabled');
      return this;
    }

    /**
     * Store a reference to the needed elements.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.selectEl = this.el.querySelector('select');
      this.checkboxEls = this.el.querySelectorAll('[type="checkbox"]');
      if (!this.selectEl && !this.checkboxEls.length) throw new Error('Multi select needs either a select input or a series of checkboxes.');
      this.messageEl = this.el.querySelector('.spark-select__message') || (0, _makeElement.default)('<span class="spark-select__message"></span>');
    }

    /**
     * Parse parameters.
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      this._isNative = this.selectEl ? true : false;
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onInputBound = this._onInput.bind(this);
    }

    /**
     * Add event listeners for focus, blur and input.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      if (this._isNative) {
        this.selectEl.addEventListener('change', this._onInputBound);
      } else {
        this.el.addEventListener('change', this._onInputBound, true);
      }
    }

    /**
     * Remove event listeners for focus, blur and input.
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      if (this._isNative) {
        this.selectEl.removeEventListener('change', this._onInputBound);
      } else {
        this.el.removeEventListener('change', this._onInputBound, true);
      }
    }

    /**
     * When the value is about to change, run the validation, set the characters count
     * and resize if we're a textarea.
     * @param {Object} e
     */
  }, {
    key: "_onInput",
    value: function _onInput() {
      var value = this.getValue();
      if (value !== this.previousValue) {
        this.previousValue = value;
        (this.onChange || noop)(value, this);
      }
    }
  }]);
  return MultiSelectInput;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
MultiSelectInput.prototype._whitelistedParams = ['validate', 'onValidate', 'onChange'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
MultiSelectInput.prototype.defaults = {
  el: null,
  messageEl: null,
  selectEl: null,
  labelEl: null,
  onChange: null,
  previousValue: null,
  _isNative: false,
  _onFocusBound: null,
  _onBlurBound: null,
  _onInputBound: null
};
(0, _mixin.default)(MultiSelectInput.prototype, _messaging.default, _validation.default);
var _default = MultiSelectInput;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/make-element":62,"../helpers/util/each":94,"../helpers/util/mixin":96,"../mixins/messaging":104,"../mixins/validation":105,"./base":3,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],21:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _isInteger = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/number/is-integer"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _messaging = _interopRequireDefault(require("../mixins/messaging"));
var _mixin = _interopRequireDefault(require("../helpers/util/mixin"));
var _validation = _interopRequireDefault(require("../mixins/validation"));
var _makeElement = _interopRequireDefault(require("../helpers/dom/make-element"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # NumberSelector
                                                                                                                                                                                                                                                                                                                                              * An increment/decrement for number inputs.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new NumberSelector(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/number-selector.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var NumberSelector = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(NumberSelector, _BaseComponent);
  var _super = _createSuper(NumberSelector);
  /**
   * NumberSelector constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function NumberSelector(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, NumberSelector);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    _this._initializeValue();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Set the initial value of the field with correct number of decimal points if necessary.
   * Provide a default value if one is not provided.
   */
  (0, _createClass2.default)(NumberSelector, [{
    key: "_initializeValue",
    value: function _initializeValue() {
      if (this.inputEl.value !== '') {
        this.setValue(parseFloat(this.inputEl.value));
      } else {
        this.setValue(0);
      }
    }

    /**
     * Get the current value of the number selector.
     * @return {Number} The current value
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return parseFloat(this.inputEl.value);
    }

    /**
     * Set the current value of the number selector.
     * @param {Number} val
     */
  }, {
    key: "setValue",
    value: function setValue(val) {
      if (isNaN(val)) {
        val = this._getMin();
      }
      var newVal = this._getConformedNumber(val);
      if (newVal !== this.inputEl.value) {
        this.inputEl.value = newVal;
        (this.onChange || noop)(newVal, this);
      }
      return this;
    }

    /**
     * Clear the value.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      return this.setValue(0);
    }

    /**
     * Increment by the step value.
     */
  }, {
    key: "increment",
    value: function increment() {
      // Account for rounding errors in JS, but only up to 2 digits after the decimal
      return this.setValue((this.getValue() * 100 + this._getStep() * 100) / 100);
    }

    /**
     * Decrement by the step value.
     */
  }, {
    key: "decrement",
    value: function decrement() {
      // Account for rounding errors in JS, but only up to 2 digits after the decimal
      return this.setValue((this.getValue() * 100 - this._getStep() * 100) / 100);
    }

    /**
     * Get number of digits after the decimal point (fractional part)
     * @param {Number} val
     * @return {Number}
     */
  }, {
    key: "_countDecimals",
    value: function _countDecimals(val) {
      return !val || isNaN(val) || !val.toString().split(".")[1] ? 0 : val.toString().split(".")[1].length || 0;
    }

    /**
     * Round a number and fix to the provided number of decimal places
     * @param {Number} val
     * @param {Number} decimals
     * @return {Number}
     */
  }, {
    key: "_roundConformedNumber",
    value: function _roundConformedNumber(val, decimals) {
      var roundedValue = Number(Math.round(val + 'e' + decimals) + 'e-' + decimals);
      var roundedValueString = '';
      if (roundedValue < 0) {
        roundedValueString = Math.abs(roundedValue).toString();
      } else {
        roundedValueString = roundedValueString.toString();
      }
      if (decimals > 0 && ((0, _isInteger.default)(roundedValue) || roundedValueString.length !== this._getStep().toString().length)) {
        return roundedValue.toFixed(decimals);
      }
      return roundedValue;
    }

    /**
     * Enable the input and buttons.
     */
  }, {
    key: "enable",
    value: function enable() {
      var btns = this.el.querySelectorAll('button');
      var len = btns.length;
      for (var i = 0; i < len; i++) {
        btns[i].removeAttribute('disabled');
      }
      this.inputEl.removeAttribute('disabled');
      return this;
    }

    /**
     * Disable the input and buttons.
     */
  }, {
    key: "disable",
    value: function disable() {
      var btns = this.el.querySelectorAll('button');
      var len = btns.length;
      for (var i = 0; i < len; i++) {
        btns[i].attributes.setNamedItem(document.createAttribute('disabled'));
      }
      this.inputEl.attributes.setNamedItem(document.createAttribute('disabled'));
      return this;
    }

    /**
     * Store a reference to the whole number-selector, as well as the
     * input element. Also, get some default values from the input
     * element (min, max, steps).
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.inputEl = el.querySelector('input');
      this.incrementButton = el.querySelector('.spark-number-selector__up');
      this.decrementButton = el.querySelector('.spark-number-selector__down');
      this.messageEl = this.el.querySelector('.spark-input__message') || (0, _makeElement.default)('<span class="spark-input__message"></span>');
      if (!this.inputEl || !this.incrementButton || !this.decrementButton) {
        throw new Error('NumberSelector missing a required element!');
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onClickBound = this._onClick.bind(this);
      this._onInputChangeBound = this._onInputChange.bind(this);
      this._onInputFocusBound = this._onInputFocus.bind(this);
      this._onInputBlurBound = this._onInputBlur.bind(this);
      this._onInputInputBound = this._onInputInput.bind(this);
      this._onKeyPressBound = this._onKeyPress.bind(this);
      this._onButtonKeyPressBound = this._onButtonKeyPress.bind(this);
    }

    /**
     * Add event listeners for touchstart and mouse click.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.el.addEventListener('click', this._onClickBound);
      this.el.addEventListener('change', this._onInputChangeBound);
      this.el.addEventListener('focus', this._onInputFocusBound);
      this.el.addEventListener('blur', this._onInputBlurBound);
      this.inputEl.addEventListener('input', this._onInputInputBound);
      this.inputEl.addEventListener('keydown', this._onKeyPressBound);
      this.inputEl.addEventListener('keyup', this._onKeyPressBound);
      this.incrementButton.addEventListener('keydown', this._onButtonKeyPressBound);
      this.decrementButton.addEventListener('keydown', this._onButtonKeyPressBound);
      this.decrementButton.addEventListener('keyup', this._onButtonKeyPressBound);
      this.incrementButton.addEventListener('keyup', this._onButtonKeyPressBound);
    }

    /**
     * Checks for enter on the button, to mimic the button being clicked
     * @param  {type} _event Key Event
     */
  }, {
    key: "_onButtonKeyPress",
    value: function _onButtonKeyPress(_event) {
      // enter keyCode 13
      if (_event.keyCode === 13) {
        if (_event.type === 'keydown') {
          if ((0, _hasClass.default)(_event.target, 'spark-number-selector__up')) {
            (0, _addClass.default)(this.incrementButton, 'active');
          } else {
            (0, _addClass.default)(this.decrementButton, 'active');
          }
        } else {
          if ((0, _hasClass.default)(_event.target, 'spark-number-selector__up')) {
            (0, _removeClass.default)(this.incrementButton, 'active');
          } else {
            (0, _removeClass.default)(this.decrementButton, 'active');
          }
        }
      }
    }

    /**
     * Checks for up and down arrow, to mimic the button being clicked
     * @param  {type} _event Key Event
     */
  }, {
    key: "_onKeyPress",
    value: function _onKeyPress(_event) {
      // Up arrow is keyCode 40, down arrow is keyCode 38
      if (_event.type === 'keydown') {
        if (_event.keyCode === 40) {
          (0, _addClass.default)(this.el.querySelector('button:first-of-type'), 'active');
        } else if (_event.keyCode === 38) {
          (0, _addClass.default)(this.el.querySelector('button:last-of-type'), 'active');
        }
      } else {
        if (_event.keyCode === 40) {
          (0, _removeClass.default)(this.el.querySelector('button:first-of-type'), 'active');
        } else if (_event.keyCode === 38) {
          (0, _removeClass.default)(this.el.querySelector('button:last-of-type'), 'active');
        }
      }
    }

    /**
     * Remove event listeners for touchstart and mouse click.
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.el.removeEventListener('click', this._onClickBound);
      this.el.removeEventListener('change', this._onInputChangeBound);
      this.el.removeEventListener('focus', this._onInputFocusBound);
      this.el.removeEventListener('blur', this._onInputBlurBound);
      this.inputEl.removeEventListener('input', this._onInputInputBound);
      this.inputEl.removeEventListener('keydown', this._onKeyPressBound);
      this.inputEl.removeEventListener('keyup', this._onKeyPressBound);
      this.incrementButton.removeEventListener('keydown', this._onButtonKeyPressBound);
      this.decrementButton.removeEventListener('keydown', this._onButtonKeyPressBound);
      this.decrementButton.removeEventListener('keyup', this._onButtonKeyPressBound);
      this.incrementButton.removeEventListener('keyup', this._onButtonKeyPressBound);
    }

    /**
     * Get the current value of the min property.
     * @return {Number}
     */
  }, {
    key: "_getMin",
    value: function _getMin() {
      return this._getInputPropAsNumber('min');
    }

    /**
     * Get the current value of the max property.
     * @return {Number}
     */
  }, {
    key: "_getMax",
    value: function _getMax() {
      return this._getInputPropAsNumber('max');
    }

    /**
     * Get the current value of the step property.
     * @return {Number}
     */
  }, {
    key: "_getStep",
    value: function _getStep() {
      var stepString = this.inputEl.getAttribute('step');
      if (!stepString) {
        return 1;
      }
      var digitsAfterDecimal = stepString.split('.')[1] ? stepString.split('.')[1].length : 0;
      return parseFloat(stepString).toFixed(digitsAfterDecimal);
    }

    /**
     * Get a property as a number.
     * @param {String} key
     * @return {Number}
     */
  }, {
    key: "_getInputPropAsNumber",
    value: function _getInputPropAsNumber(key) {
      return parseFloat(this.inputEl.getAttribute(key));
    }

    /**
     * Get the given number within the min/max range of the input element.
     * @param {Number} num
     * @return {Number}
     */
  }, {
    key: "_getConformedNumber",
    value: function _getConformedNumber(num) {
      var max = this._getMax();
      var min = this._getMin();
      var step = this._getStep();
      if (step) {
        var digitsAfterDecimal = this._countDecimals(step);
        if (digitsAfterDecimal > 0) {
          num = this._roundConformedNumber(num, digitsAfterDecimal);
          if (!isNaN(max)) {
            max = this._roundConformedNumber(max, digitsAfterDecimal);
          }
          if (!isNaN(min)) {
            min = this._roundConformedNumber(min, digitsAfterDecimal);
          }
        }
      }
      var exceedsUpperBound = parseFloat(num) > parseFloat(max);
      var exceedsLowerBound = parseFloat(num) < parseFloat(min);
      return max !== undefined && exceedsUpperBound ? max : min !== undefined && exceedsLowerBound ? min : num;
    }

    /**
     * When either of the buttons are clicked, update the value.
     * @param {Object} e
     */
  }, {
    key: "_onClick",
    value: function _onClick(_event) {
      // IE 11 has a bug where click events for disabled buttons still propagate.
      // Add a check to ensure that we are not incrementing/decrementing in this scenario
      if (!_event.target.hasAttribute('disabled')) {
        if ((0, _hasClass.default)(_event.target, 'spark-number-selector__up')) {
          // The increment button is clicked
          _event.preventDefault();
          this.increment();
        } else if ((0, _hasClass.default)(_event.target, 'spark-number-selector__down')) {
          // The decrement button is clicked
          _event.preventDefault();
          this.decrement();
        }
      }
    }

    /**
     * When the input value changes, max sure we are in bounds.
     * @param {Object} e
     */
  }, {
    key: "_onInputChange",
    value: function _onInputChange() {
      this.setValue(parseFloat(this.inputEl.value));
    }

    /**
     * When the input gains focus.
     * @param {Object} e
     */
  }, {
    key: "_onInputFocus",
    value: function _onInputFocus() {
      if (this.onFocus) {
        this.onFocus(this.getValue(), this);
      }
    }

    /**
     * When the input loses focus.
     * @param {Object} e
     */
  }, {
    key: "_onInputBlur",
    value: function _onInputBlur() {
      if (this.onBlur) {
        this.onBlur(this.getValue(), this);
      }
    }

    /**
     * When the input loses focus.
     * @param {Object} e
     */
  }, {
    key: "_onInputInput",
    value: function _onInputInput() {
      if (this.onInput) {
        this.onInput(this.getValue(), this);
      }
    }
  }]);
  return NumberSelector;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
NumberSelector.prototype._whitelistedParams = ['validate', 'onValidate', 'onChange', 'onFocus', 'onBlur', 'onInput'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
NumberSelector.prototype.defaults = {
  el: null,
  inputEl: null,
  onValidate: null,
  onChange: null,
  onFocus: null,
  onBlur: null,
  onInput: null,
  _onInputChangeBound: null,
  _onClickBound: null
};
(0, _mixin.default)(NumberSelector.prototype, _messaging.default, _validation.default);
var _default = NumberSelector;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/add-class":59,"../helpers/dom/has-class":61,"../helpers/dom/make-element":62,"../helpers/dom/remove-class":67,"../helpers/util/mixin":96,"../mixins/messaging":104,"../mixins/validation":105,"./base":3,"@babel/runtime-corejs3/core-js-stable/number/is-integer":120,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],22:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _debounce = _interopRequireDefault(require("../helpers/util/debounce"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _outerWidth = _interopRequireDefault(require("../helpers/dom/outer-width"));
var _offset = _interopRequireDefault(require("../helpers/dom/offset"));
var _breakpoint = require("../helpers/dom/breakpoint");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # PanelCarousel
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * Panel Carousel, as used in KPI, summary bar.
                                                                                                                                                                                                                                                                                                                                              * unofficial component
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/panel-carousel.js
                                                                                                                                                                                                                                                                                                                                              */
var PanelCarousel = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(PanelCarousel, _BaseComponent);
  var _super = _createSuper(PanelCarousel);
  /**
   * PanelCarousel constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function PanelCarousel(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, PanelCarousel);
    _this = _super.call(this, el, params);
    if (!el) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    _this._initCarousel();
    return _this;
  }

  /**
   * Creates the carousel controls.
   */
  (0, _createClass2.default)(PanelCarousel, [{
    key: "_addControls",
    value: function _addControls() {
      this._forwards = document.createElement('div');
      (0, _addClass.default)(this._forwards, 'spark-panel-carousel__forwards');
      this._forwards.innerHTML = '<button type="button" aria-label=' + this.nextLabel + '><i class="spark-icon-arrow-chevron-right spark-icon--fill"></i></button>';
      this._backwards = document.createElement('div');
      (0, _addClass.default)(this._backwards, 'spark-panel-carousel__backwards');
      this._backwards.innerHTML = '<button type="button" aria-label=' + this.previousLabel + '><i class="spark-icon-arrow-chevron-left spark-icon--fill"></i></button>';
      this.el.appendChild(this._backwards);
      this.el.appendChild(this._forwards);
      if (this._hasTabs === true) {
        this._forwards.querySelector('button').setAttribute('tabIndex', -1);
        this._backwards.querySelector('button').setAttribute('tabIndex', -1);
        this._panelCarouselList.addEventListener('click', this._onTabListClickBound);
      }
      (0, _addClass.default)(this._backwards, 'spark-panel-carousel__limit');
    }

    /**
     * Remove event listeners
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this._forwards.removeEventListener('click', this._onControlClickBound);
      this._backwards.removeEventListener('click', this._onControlClickBound);
      this._panelCarouselList.removeEventListener('touchstart', this._onMoveStartBound);
      this.el.removeEventListener('mousedown', this._onMoveStartBound);
      this._panelCarouselList.removeEventListener('keyup', this._onKeyUpBound);
      window.removeEventListener('scroll', this._onScrollBound);
      window.removeEventListener('resize', this._onResizeBound);
    }

    /**
     * Bind and add Carousel listeners
     */
  }, {
    key: "_addCarouselListeners",
    value: function _addCarouselListeners() {
      this._onKeyUpBound = this._onKeyUp.bind(this);
      this._onControlClickBound = this._onControlClick.bind(this);
      this._onMoveStartBound = this._onMoveStart.bind(this);
      this._onMoveBound = this._onMove.bind(this);
      this._onMoveEndBound = this._onMoveEnd.bind(this);
      this._forwards.addEventListener('click', this._onControlClickBound);
      this._backwards.addEventListener('click', this._onControlClickBound);
      this._panelCarouselList.addEventListener('touchstart', this._onMoveStartBound);
      this.el.addEventListener('mousedown', this._onMoveStartBound);
      this._panelCarouselList.addEventListener('keyup', this._onKeyUpBound);
    }

    /**
     * Remove Carousel listeners
     */
  }, {
    key: "_removeCarouselListeners",
    value: function _removeCarouselListeners() {
      this._forwards.removeEventListener('click', this._onControlClickBound);
      this._backwards.removeEventListener('click', this._onControlClickBound);
      this.el.removeEventListener('mousedown', this._onMoveStartBound);
      this._panelCarouselList.removeEventListener('keyup', this._onKeyUpBound);
    }

    /**
     * Add move listeners.
     * @param {Event} _event either a TouchEvent or a MouseEvent
     */
  }, {
    key: "_addMoveListeners",
    value: function _addMoveListeners(_event) {
      if (_event.touches) {
        this._panelCarouselList.addEventListener('touchmove', this._onMoveBound);
        this._panelCarouselList.addEventListener('touchend', this._onMoveEndBound);
      } else {
        window.addEventListener('mouseup', this._onMoveEndBound);
        window.addEventListener('mousemove', this._onMoveBound);
      }
    }

    /**
     * Remove move listeners
     * @param  {Event} _event MouseEvent or TouchEvent
     */
  }, {
    key: "_removeMoveListeners",
    value: function _removeMoveListeners(_event) {
      if (_event.touches) {
        this._panelCarouselList.removeEventListener('touchmove', this._onMoveBound);
        this._panelCarouselList.removeEventListener('touchend', this._onMoveEndBound);
      } else {
        window.removeEventListener('mouseup', this._onMoveEndBound);
        window.removeEventListener('mousemove', this._onMoveBound);
      }
    }

    /**
     * Add bound event listeners
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      window.addEventListener('scroll', this._onScrollBound);
      window.addEventListener('resize', this._onResizeBound);
      this.el.addEventListener('scroll', function (_event) {
        if (this.scrollLeft !== 0) {
          this.scrollLeft = 0;
        }
        _event.stopImmediatePropagation();
        _event.preventDefault();
        return false;
      });
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onScrollBound = this._onScroll.bind(this);
      this._onResizeBound = (0, _debounce.default)(this._onResize.bind(this), 90);
    }

    /**
     * Store a reference to the tabs list, each tab and each panel.
     * Set which tab is active, or use the first.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this._panelCarouselList = this.el.querySelector('.spark-panel-carousel__list');
      this._panelCarouselItems = this.el.querySelectorAll('.spark-panel-carousel__item');
      this.listTransitionDuration = window.getComputedStyle(this._panelCarouselList).getPropertyValue('transition-duration') || '800ms';
    }

    /**
     * Calculate the width of the Panel Carousel Items. widths are not static, may change based on screen size.
     */
  }, {
    key: "_calcWidth",
    value: function _calcWidth() {
      this._panelCarouselWidth = (0, _outerWidth.default)(this._panelCarouselList);
      this._panelCarouselItemsWidth = 0;
      for (var i = this._panelCarouselItems.length - 1; i > -1; i--) {
        this._panelCarouselItemsWidth += (0, _outerWidth.default)(this._panelCarouselItems[i]);
        void this._panelCarouselItems.offsetWidth;
      }
      this.maxX = this._panelCarouselWidth - this._panelCarouselItemsWidth;

      // <= 0 means its part of a hidden div
      if (this._panelCarouselItemsWidth > this._panelCarouselWidth || this._panelCarouselWidth <= 0) {
        this._overflow = true;
        this.el.setAttribute('data-overflow', true);
      } else {
        this._overflow = false;
        this.el.removeAttribute('data-overflow');
      }
    }

    /**
     * Calculate the current Break point, update flags based on value
     *
     */
  }, {
    key: "_calcBreakpoint",
    value: function _calcBreakpoint() {
      this.currentBreakpoint = (0, _breakpoint.get)(window.innerWidth);
      var breakpoints = ['xs', 'sm', 'md', 'lg', 'xl'];
      var currentBreakIndex = breakpoints.indexOf(this.currentBreakpoint);
      var noCarouselBreakIndex = breakpoints.indexOf(this.noCarouselBreakPoint);
      var controlBreakIndex = breakpoints.indexOf(this.controlBreakPoint);

      // if not using the carousel, don't monitor touch events
      if (currentBreakIndex <= noCarouselBreakIndex && noCarouselBreakIndex !== -1) {
        this._useCarousel = false;
      } else {
        this._useCarousel = true;
      }
      if (currentBreakIndex <= controlBreakIndex) {
        this._useControls = false;
      } else {
        this._useControls = true;
      }
    }

    /**
     * Initialize the carousel slider.
     */
  }, {
    key: "_initCarousel",
    value: function _initCarousel() {
      this.currentBreakpoint = (0, _breakpoint.get)(window.innerWidth);
      this._calcWidth();
      this._calcBreakpoint();
      this._addControls();
      this._showControls();
      this._addCarouselListeners();
    }

    /**
     * onScroll, if there is padding, if a carousel is in a fixed panel it will expand to fill 100%, need to watch if the isFixed class is applied and recalculate the width
     */
  }, {
    key: "_onScroll",
    value: function _onScroll() {
      // if you have already done the calculation for the change in fixed state, don't recalc for every scroll event
      if (this.isFixed === (0, _hasClass.default)(this.el, 'is-fixed-top')) {
        return;
      }
      if ((0, _hasClass.default)(this.el, 'is-fixed-top')) {
        this.isFixed = true;
      } else {
        this.isFixed = false;
      }
      this._calcWidth();
      if (this._forwardLimit === true) {
        this._updateCarousel(this.maxX);
      }
    }

    /**
     * See if you are tabbing through the carousel. This is only attached when it's a tabbed variation.
     * @param  {KeyEvent} _event KeyEvent
     *
     */
  }, {
    key: "_onKeyUp",
    value: function _onKeyUp(_event) {
      var tab = _event.target;
      if (_event.keyCode !== 9) {
        return;
      }

      // turn of transition for rapid tabbing.
      this._panelCarouselList.style['transition-duration'] = '0s';
      if (_event.shiftKey === true) {
        if ((0, _offset.default)(tab).left <= (0, _outerWidth.default)(this._backwards)) {
          this._backwards.click();
        } else if ((0, _offset.default)(tab).left > (0, _outerWidth.default)(this._panelCarouselList)) {
          this._forwardLimit = true;
          this._calcWidth();
          this._updateCarousel(this.maxX);
        }
      } else {
        if ((0, _offset.default)(tab).left + (0, _outerWidth.default)(tab) > (0, _outerWidth.default)(this._panelCarouselList) - (0, _outerWidth.default)(this._forwards)) {
          if (this._forwardLimit !== true) {
            this._forwards.click();
          }
        } else if ((0, _offset.default)(tab).left + (0, _outerWidth.default)(tab) < 0) {
          this._backwardLimit = true;
          this._updateCarousel(0);
        }
      }

      // turn on transition
      this._panelCarouselList.style['transition-duration'] = this.listTransitionDuration;
    }

    /**
     * Window resize event, keeps the carousel fresh... debounced from the listener. An event is passed to the method, but not used.
     */
  }, {
    key: "_onResize",
    value: function _onResize() {
      this._calcWidth();
      this._calcBreakpoint();
      this._updateCarousel(0);
      this._calcWidth();
    }

    /**
     * Track touch end event, re-add transition
     * @param  {TouchEvent} _event touchmove
     */
  }, {
    key: "_onMoveEnd",
    value: function _onMoveEnd(_event) {
      var xPosition;
      var screenX = this._startX;

      // touch event or mouse event
      if (_event.changedTouches) {
        screenX = _event.changedTouches[0].screenX;
        xPosition = screenX - this._startX + this._positionX;
      } else {
        screenX = _event.screenX;
        xPosition = screenX - this._startX + this._positionX;
      }
      this._moving = false;
      this._removeMoveListeners(_event);
      this._panelCarouselList.style['transition-duration'] = this.listTransitionDuration;

      // if difference is 0 then it was a click not a move;
      // a press looks like a move, this avoids it looking like a forward or backward click when it's a tab click
      if (this._useCarousel === false || Math.round(screenX - this._startX) === 0) {
        return;
      }
      if (xPosition > this._positionX) {
        this._backwards.click();
      } else {
        this._forwards.click();
      }
    }

    /**
     * Track touch move event. Moves the bar along with the touch movement.
     * @param  {TouchEvent} _event touchmove
     */
  }, {
    key: "_onMove",
    value: function _onMove(_event) {
      // don't track if the move hasn't started
      if (this._moving === false) {
        return;
      }
      var xPosition;

      // test if has touch events or if it's a mouse event
      if (_event.changedTouches) {
        xPosition = _event.changedTouches[0].screenX - this._startX + this._positionX;
      } else {
        xPosition = _event.screenX - this._startX + this._positionX;
      }
      if (this._useCarousel === false) {
        return;
      }

      // the max is 0
      if (xPosition > 0) {
        xPosition = 0;
      }

      // maxX is a negative number, which is why this looks odd;
      if (xPosition < this.maxX) {
        xPosition = this.maxX;
      }

      // need to remove the transition or the move will try and transition rather than just going along with the move event.
      this._panelCarouselList.style['transition-duration'] = '0s';
      this._panelCarouselList.style.transform = 'translateX(' + xPosition + 'px)';
      if (_event) {
        _event.preventDefault();
      }
    }

    /**
     * Track touch start event. Calculates the maximum distance that you can scroll based on number of items and current position.
     * @param  {TouchEvent} _event touchmove
     */
  }, {
    key: "_onMoveStart",
    value: function _onMoveStart(_event) {
      if (this._useCarousel === false) {
        return;
      }
      this._moving = true;
      this._addMoveListeners(_event);
      if (_event.changedTouches) {
        this._startX = _event.changedTouches[0].screenX;
        this._startY = _event.changedTouches[0].screenY;
      } else {
        this._startX = _event.screenX;
        this._startY = _event.screenY;
      }
      this._elRect = this.el.getBoundingClientRect();
      if (this._useControls === true) {
        this.maxX = -(this._panelCarouselItemsWidth - this._elRect.width + (0, _outerWidth.default)(this._forwards) + (0, _outerWidth.default)(this._backwards));
      } else {
        this.maxX = this._elRect.width - this._panelCarouselItemsWidth;
      }
      this.maxX = Math.round(this.maxX);
    }

    /**
     * Update the carousel position
     *
     * @param  {type} xPosition
     */
  }, {
    key: "_updateCarousel",
    value: function _updateCarousel(xPosition) {
      if (xPosition === this.maxX) {
        this._forwardLimit = true;
      } else {
        this._forwardLimit = false;
      }
      if (xPosition === 0) {
        this._backwardLimit = true;
      } else {
        this._backwardLimit = false;
      }
      this._panelCarouselList.style.transform = "translateX(" + xPosition + "px)";
      this._positionX = xPosition;
      this._showControls();
    }

    /**
     * Identify which carousel button was clicked trigger correct arrow
     * @param  {clickEvent} _event click
     */
  }, {
    key: "_onControlClick",
    value: function _onControlClick(_event) {
      _event.preventDefault();
      var button = _event.currentTarget;
      var xPosition = 0;
      if ((0, _hasClass.default)(button, 'spark-panel-carousel__forwards')) {
        if (this.singleCarouselAdvance === false && this._useControls === true) {
          xPosition = this._setForwardClick(_event);
        } else {
          xPosition = this._singleForwardClick(_event);
        }
      } else if ((0, _hasClass.default)(button, 'spark-panel-carousel__backwards')) {
        if (this.singleCarouselAdvance === false && this._useControls === true) {
          xPosition = this._setBackwardClick(_event);
        } else {
          xPosition = this._singleBackwardClick(_event);
        }
      } else {
        // not our click;
        return;
      }
      this._updateCarousel(Math.round(xPosition));
      _event.preventDefault();
    }

    /**
     * Advance the carousel one set.
     * @param  {clickEvent} _event click
     * @return {Number}
     */
  }, {
    key: "_setForwardClick",
    value: function _setForwardClick(_event) {
      var button = _event.currentTarget;
      var buttonLeft = (0, _offset.default)(button).left;
      var buttonWidth = (0, _outerWidth.default)(button);
      var left = (0, _offset.default)(this._panelCarouselItems[0]).left;
      var listBoxWidth = (0, _outerWidth.default)(this._panelCarouselList);
      var max = buttonLeft;
      var xPosition = 0;
      var totalWidth = 0;
      this._backwardLimit = false;

      // recalculate the total width incase content was updated outside of resize.
      for (var i = 0; i < this._panelCarouselItems.length; i++) {
        totalWidth += (0, _outerWidth.default)(this._panelCarouselItems[i]);
      }
      this.maxX = Math.round(-totalWidth + listBoxWidth);
      xPosition = this.maxX;
      for (var _i = 0; _i < this._panelCarouselItems.length; _i++) {
        if ((0, _offset.default)(this._panelCarouselItems[_i]).left + (0, _outerWidth.default)(this._panelCarouselItems[_i]) - buttonWidth > max) {
          xPosition = left - ((0, _offset.default)(this._panelCarouselItems[_i]).left - buttonWidth);
          if (-xPosition > totalWidth - listBoxWidth) {
            xPosition = -totalWidth + listBoxWidth;
            this.maxX = Math.round(xPosition);
          }
          break;
        }
      }

      // if you can't go any further set the forwardLimit to true
      if (this.maxX === xPosition) {
        this._forwardLimit = true;
      }
      return xPosition;
    }

    /**
     * Reverse the carousel one set of items.
     * @param  {clickEvent} _event click
     * @return {Number}
     */
  }, {
    key: "_setBackwardClick",
    value: function _setBackwardClick(_event) {
      var button = _event.currentTarget;
      var xPosition = (0, _outerWidth.default)(this._panelCarouselList);
      this._forwardLimit = false;
      for (var i = this._panelCarouselItems.length - 1; i > -1; i--) {
        if ((0, _offset.default)(this._panelCarouselItems[i]).left <= (0, _offset.default)(this.el).left) {
          xPosition -= (0, _outerWidth.default)(this._panelCarouselItems[i]);
        }
      }
      xPosition -= (0, _outerWidth.default)(button);

      // if you can't go back any further, set to 0
      if (xPosition >= -(0, _outerWidth.default)(button)) {
        xPosition = 0;
      }
      return xPosition;
    }

    /**
     * Shows or hides controls based on screen width, specified break points.
     */
  }, {
    key: "_showControls",
    value: function _showControls() {
      // only need controls if there is an overflow and if you are still using the carousel__list
      if (this._overflow === true && this._useCarousel === true) {
        if (this._backwardLimit === true) {
          (0, _addClass.default)(this._backwards, 'spark-panel-carousel__limit');
        } else {
          (0, _removeClass.default)(this._backwards, 'spark-panel-carousel__limit');
        }
        if (this._forwardLimit === true) {
          (0, _addClass.default)(this._forwards, 'spark-panel-carousel__limit');
        } else {
          (0, _removeClass.default)(this._forwards, 'spark-panel-carousel__limit');
        }
        if (this._useControls === false) {
          (0, _addClass.default)(this._backwards, 'spark-panel-carousel-no-controls');
          (0, _addClass.default)(this._forwards, 'spark-panel-carousel-no-controls');
        } else {
          (0, _removeClass.default)(this._backwards, 'spark-panel-carousel-no-controls');
          (0, _removeClass.default)(this._forwards, 'spark-panel-carousel-no-controls');
        }
      } else {
        (0, _addClass.default)(this._backwards, 'spark-panel-carousel__limit');
        (0, _addClass.default)(this._forwards, 'spark-panel-carousel__limit');
      }
    }

    /**
     * Reverse the carousel one items.
     * @param  {clickEvent} _event click
     * @return {Number}
     */
  }, {
    key: "_singleBackwardClick",
    value: function _singleBackwardClick(_event) {
      var button = _event.currentTarget;
      var buttonWidth = (0, _outerWidth.default)(button);
      var buttonLeft = (0, _offset.default)(button).left;
      var left = (0, _offset.default)(this._panelCarouselList).left;
      var xPosition = 0;
      for (var i = this._panelCarouselItems.length - 1; i > 0; i--) {
        if ((0, _offset.default)(this._panelCarouselItems[i]).left < buttonLeft + buttonWidth) {
          xPosition = left - (0, _offset.default)(this._panelCarouselItems[i]).left + buttonWidth;

          // this is the margin of error so that if the browser size so it looks better at a browser size that may cause a button click to show a couple pixels
          if (xPosition > buttonWidth - 2) {
            xPosition = 0;
          }
          break;
        }
      }
      return xPosition;
    }

    /**
     * Advance the carousel one item.
     * @param  {clickEvent} _event click
     * @return {Number}
     */
  }, {
    key: "_singleForwardClick",
    value: function _singleForwardClick(_event) {
      var button = _event.currentTarget;
      var xPosition = 0;
      var buttonWidth = (0, _outerWidth.default)(button);
      var maxLeft = this._panelCarouselWidth + (0, _offset.default)(this.el).left;
      var totalWidth = 0;
      if (this._useControls === true) {
        maxLeft -= buttonWidth;
      }
      xPosition = maxLeft;
      var adjustLeft = (0, _offset.default)(this._panelCarouselItems[0]).left - (0, _offset.default)(this.el).left;
      for (var i = 0; i < this._panelCarouselItems.length; i++) {
        totalWidth += (0, _outerWidth.default)(this._panelCarouselItems[i]);
      }
      this.maxX = Math.round(-totalWidth + this._panelCarouselWidth);
      xPosition = this.maxX;
      for (var _i2 = 0; _i2 < this._panelCarouselItems.length; _i2++) {
        var itemRight = (0, _offset.default)(this._panelCarouselItems[_i2]).left + (0, _outerWidth.default)(this._panelCarouselItems[_i2]);
        if (itemRight > maxLeft) {
          xPosition = maxLeft - itemRight + adjustLeft;
          if (this._panelCarouselItems[_i2 + 1] === undefined) {
            if (this._useControls === true) {
              xPosition += buttonWidth;
            }
            this.maxX = Math.round(xPosition);
          }
          break;
        }
      }
      if (this.maxX === xPosition) {
        this._forwardLimit = true;
      }
      return xPosition;
    }
  }]);
  return PanelCarousel;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
PanelCarousel.prototype._whitelistedParams = ['singleCarouselAdvance', 'noCarouselBreakPoint', 'controlBreakPoint', 'nextLabel', 'previousLabel', 'hasTabs'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
PanelCarousel.prototype.defaults = {
  el: null,
  singleCarouselAdvance: false,
  noCarouselBreakPoint: null,
  controlBreakPoint: 'xs',
  nextLabel: 'Show next',
  previousLabel: 'Show previous',
  _useControls: true,
  _panelCarouselItemsWidth: 0,
  _panelCarouselWidth: 0,
  _positionX: 0,
  _forwardLimit: false,
  _backwardLimit: true,
  _overflow: false,
  _hasTabs: false
};
var _default = PanelCarousel;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/add-class":59,"../helpers/dom/breakpoint":60,"../helpers/dom/has-class":61,"../helpers/dom/offset":63,"../helpers/dom/outer-width":65,"../helpers/dom/remove-class":67,"../helpers/util/debounce":93,"./base":3,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],23:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _cardNumber = _interopRequireDefault(require("./payments/card-number"));
var _cardExpiration = _interopRequireDefault(require("./payments/card-expiration"));
var _cardSecurityCode = _interopRequireDefault(require("./payments/card-security-code"));
var _unifiedCreditCard = _interopRequireDefault(require("./payments/unified-credit-card"));
var _cardSet = _interopRequireDefault(require("./payments/card-set"));
var _currencyInput = _interopRequireDefault(require("./payments/currency-input"));
/**
 * # Payment Inputs
 * Input containers for payment details.
 *
 * @module components/payments.js
 */

var Payments = {
  CardNumber: _cardNumber.default,
  CardExpiration: _cardExpiration.default,
  CardSecurityCode: _cardSecurityCode.default,
  UnifiedCreditCard: _unifiedCreditCard.default,
  CardSet: _cardSet.default,
  CurrencyInput: _currencyInput.default
};
var _default = Payments;
exports.default = _default;
module.exports = exports.default;


},{"./payments/card-expiration":24,"./payments/card-number":25,"./payments/card-security-code":26,"./payments/card-set":27,"./payments/currency-input":28,"./payments/unified-credit-card":29,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],24:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));
var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("../base"));
var _typeahead = _interopRequireDefault(require("../typeahead"));
var _mixin = _interopRequireDefault(require("../../helpers/util/mixin"));
var _addClass = _interopRequireDefault(require("../../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../../helpers/dom/remove-class"));
var _toggleClass = _interopRequireDefault(require("../../helpers/dom/toggle-class"));
var _makeElement = _interopRequireDefault(require("../../helpers/dom/make-element"));
var _messaging = _interopRequireDefault(require("../../mixins/messaging"));
var _validation = _interopRequireDefault(require("../../mixins/validation"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Card Expiration Input
                                                                                                                                                                                                                                                                                                                                              * An input container for payment expiration details.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Spark.Payments.CardExpiration(el, {...});
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/payments/card-expiration.js
                                                                                                                                                                                                                                                                                                                                              */
var onValidEvent;
var onInvalidEvent;
var CardExpiration = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(CardExpiration, _BaseComponent);
  var _super = _createSuper(CardExpiration);
  /**
   * CardExpiration constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function CardExpiration(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, CardExpiration);
    _this = _super.call(this, el, params);
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    _this._initTypeahead();
    onValidEvent = document.createEvent('Event');
    onInvalidEvent = document.createEvent('Event');
    onValidEvent.initEvent('valid', true, true);
    onInvalidEvent.initEvent('invalid', true, true);
    return _this;
  }

  /**
   * Sets up references
   * @param {Element} el base DOM element
   */
  (0, _createClass2.default)(CardExpiration, [{
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.inputEl = el ? el.querySelector('input') : undefined;
      if (!this.el || !this.inputEl) {
        throw new Error('CardExpiration markup missing');
      } else {
        if (this.inputEl.value) {
          (0, _addClass.default)(this.el, 'active');
        }
        this.messageEl = this.el.querySelector('.spark-input__message') || (0, _makeElement.default)('<span class="spark-input__message"></span>');
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onBlurBound = this._onBlur.bind(this);
      this._onFocusBound = this._onFocus.bind(this);
      this._onInputBound = this._onInput.bind(this);
      this._onInvalidBound = this._onInvalid.bind(this);
      this._onValidBound = this._onValid.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.inputEl.addEventListener('input', this._onInputBound, false);
      this.inputEl.addEventListener('blur', this._onBlurBound, false);
      this.inputEl.addEventListener('focus', this._onFocusBound, false);
      this.inputEl.addEventListener('invalid', this._onInvalidBound, false);
      this.inputEl.addEventListener('valid', this._onValidBound, false);
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.inputEl.removeEventListener('input', this._onInputBound, false);
      this.inputEl.removeEventListener('blur', this._onBlurBound, false);
      this.inputEl.removeEventListener('focus', this._onFocusBound, false);
      this.inputEl.removeEventListener('invalid', this._onInvalidBound, false);
      this.inputEl.removeEventListener('valid', this._onValidBound, false);
    }

    /**
     * Initialize internal typeahead to restrict input to desired format
     */
  }, {
    key: "_initTypeahead",
    value: function _initTypeahead() {
      if (this.inputEl) {
        this.inputEl.dataset.typeaheadFormat = '\\d\\d - \\d\\d';
        this.typeahead = new _typeahead.default(this.el);
      }
    }

    /**
     * Getter for Month value
     * @return {String}
     */
  }, {
    key: "month",
    get: function get() {
      if (this._month === undefined && this.inputEl.value) {
        if (this.inputEl.value.length >= 2) {
          var _context;
          var month = (0, _slice.default)(_context = this.inputEl.value).call(_context, 0, 2);
          return month >= 1 && month <= 12 ? month : this._month;
        }
      }
      return this._month;
    }

    /**
     * Setter for Month Value
     * @param {Number} value
     */,
    set: function set(value) {
      var _context2;
      if (value && value >= 1 && value <= 12) {
        value = value.toString();
        this._month = value.length === 2 ? value : '0'.concat(value);
      } else {
        this._month = undefined;
      }
      if (this._month && this._month.length === 2) {
        switch (this.inputEl.value.length) {
          case 0:
          case 1:
            (0, _addClass.default)(this.el, 'active');
            this.value = this._month;
            break;
          case 2:
            (0, _addClass.default)(this.el, 'active');
            this.value = this._month;
            if (this.inputEl === document.activeElement) {
              this.typeahead.moveCaret(5);
            }
            break;
          default:
            this.value = this._month + (0, _slice.default)(_context2 = this.inputEl.value).call(_context2, 2);
            break;
        }
      } else {
        this._month = undefined;
        this._year = undefined;
        this.typeahead.clearValue();
      }
    }

    /**
     * Getter for Year value
     * @return {String}
     */
  }, {
    key: "year",
    get: function get() {
      if (this._year === undefined && this.inputEl.value) {
        if (this.inputEl.value.length === 7) {
          return this.inputEl.value.substr(-2);
        }
      }
      return this._year;
    }

    /**
     * Setter for Year value
     * @param {Number} value
     */,
    set: function set(value) {
      if (value >= 0 && value <= 99) {
        value = value.toString();
        this._year = value.length === 2 ? value : '0'.concat(value);
      } else {
        this._year = undefined;
      }
      if (this._year && this._year.length === 2) {
        switch (this.inputEl.value.length) {
          case 0:
          case 1:
            this._year = undefined;
            break;
          default:
            if (this._month) {
              var _context3;
              this.value = (0, _concat.default)(_context3 = this._month).call(_context3, ' - ', this._year);
            }
            break;
        }
      } else {
        var _context4;
        this.value = (0, _slice.default)(_context4 = this.inputEl.value).call(_context4, 0, 5);
      }
    }

    /**
     * Getter for Primary Component Value
     * @return {Object}
     */
  }, {
    key: "value",
    get: function get() {
      return this.valid ? {
        month: this.month,
        year: this.year
      } : undefined;
    }

    /**
     * Setter for Primary Component Value
     * @param {Mixed} val
     */,
    set: function set(val) {
      if (!val) {
        this._month = undefined;
        this._year = undefined;
        if (this.inputEl) {
          this.inputEl.value = '';
        }
        if (this.typeahead) {
          this.typeahead.clearValue();
          this.typeahead.placeholderEl.innerText = this.inputEl.placeholder;
        }
      } else if (val.hasOwnProperty('year') || val.hasOwnProperty('month')) {
        this.month = val.month || this.month;
        this.year = val.year || this.year;
      } else if (this.typeahead && val && typeof val === 'string') {
        this.typeahead.setValue(val);
      }
      if (this.inputEl === document.activeElement) {
        (0, _addClass.default)(this.el, 'active');
      } else {
        (0, _toggleClass.default)(this.el, 'active', this.inputEl.value);
      }
    }

    /**
     * Getter for Valid state, returns true if component value is valid, false if not
     * @return {Boolean}
     */
  }, {
    key: "valid",
    get: function get() {
      var format = new RegExp(this.inputEl.getAttribute('pattern'));
      return this.month && this.year ? this.inputEl.willValidate && format.test(this.inputEl.value) : false;
    }

    /**
     * onBlur callback, for controlling component active state, firing provided callbacks, and running validation
     */
  }, {
    key: "_onBlur",
    value: function _onBlur() {
      if (!this.inputEl.value) {
        (0, _removeClass.default)(this.el, 'active');
      }
      this.onBlur.call(this);
      if (this.inputEl.hasAttribute('data-novalidate')) {
        this.inputEl.removeAttribute('data-novalidate');
      }
      if (!this.valid) {
        this.inputEl.dispatchEvent(onInvalidEvent);
      }
    }

    /**
     * onFocus callback, for controlling component active state and firing provided callbacks
     */
  }, {
    key: "_onFocus",
    value: function _onFocus() {
      (0, _addClass.default)(this.el, 'active');
      this.onFocus.call(this);
    }

    /**
     * onInput callback, for controlling component active state, parsing user input, firing provided callbacks, and running validation
     */
  }, {
    key: "_onInput",
    value: function _onInput() {
      var value = this.inputEl ? this.inputEl.value : 0;
      (0, _addClass.default)(this.el, 'active');
      switch (value.length) {
        case 0:
          this.month = undefined;
          this.year = undefined;
          break;
        case 1:
          if (value > 1) {
            var formattedMonth = '0'.concat(this.inputEl.value, ' - ');
            this.inputEl.value = formattedMonth;
            this.typeahead.setValue(formattedMonth);
            this.typeahead.placeholderEl.innerHTML = '&nbsp;&nbsp; - YY';
            this.typeahead.moveCaret(5);
            this.month = (0, _slice.default)(value).call(value, 0, 2);
            this.year = undefined;
          } else {
            this.year = undefined;
          }
          break;
        case 5:
          {
            var month = (0, _slice.default)(value).call(value, 0, 2);
            if (month >= 1 && month <= 12) {
              this.month = month;
              this.typeahead.moveCaret(5);
            } else {
              var _context5;
              this.typeahead.setValue(month.charAt(0));
              this.typeahead.moveCaret(1);
              this.inputEl.value = month.charAt(0);
              this.typeahead.placeholderEl.innerHTML = '&nbsp;' + (0, _slice.default)(_context5 = this.inputEl.placeholder).call(_context5, 1);
            }
            this.year = undefined;
            break;
          }
        case 6:
          this.month = (0, _slice.default)(value).call(value, 0, 2);
          this.year = undefined;
          break;
        case 7:
          this.month = (0, _slice.default)(value).call(value, 0, 2);
          this.year = value.substr(-2);
          break;
      }
      this.onInput.call(this);
      this._checkValidity();
    }

    /**
     * Triggers validity events
     */
  }, {
    key: "_checkValidity",
    value: function _checkValidity() {
      if (!this.inputEl.hasAttribute('data-novalidate')) {
        this.inputEl.dispatchEvent(this.valid ? onValidEvent : onInvalidEvent);
      }
    }

    /**
     * onInvalid method for firing provided callbacks
     */
  }, {
    key: "_onInvalid",
    value: function _onInvalid() {
      this.onInvalid.call(this);
    }

    /**
     * onValid method for firing provided callbacks
     */
  }, {
    key: "_onValid",
    value: function _onValid() {
      this.onValid.call(this);
    }

    /**
     * Method for triggering focus on component's input element from outside of component
     */
  }, {
    key: "focus",
    value: function focus() {
      this.inputEl.focus();
    }

    /**
     * Returns value as a string of continuous digits in the pattern of MMYY,
     * with no special formatting or spacing
     * @return {String}
     */
  }, {
    key: "valueOf",
    value: function valueOf() {
      return this.inputEl.value.replace(/\D/g, '');
    }

    /**
     * Default validate function. This can be overridden by passing a
     * custom validate method as a parameter.
     */
  }, {
    key: "validate",
    value: function validate() {
      if (this.validatePattern) {
        this.inputEl.setAttribute('pattern', this.validatePattern);
      }
      this.onValidate(this.valid, this.value, this);
      return this;
    }

    /**
     * Show the input by adding the active state and setting character counts (if necessary).
     */
  }, {
    key: "show",
    value: function show() {
      (0, _addClass.default)(this.el, 'active');
      return this;
    }

    /**
     * Hide the input by removing the active state.
     */
  }, {
    key: "hide",
    value: function hide() {
      (0, _removeClass.default)(this.el, 'active');
      return this;
    }

    /**
     * Set the value of the input.
     * @param {Mixed} value
     */
  }, {
    key: "setValue",
    value: function setValue(value) {
      this.value = value;
      if (value) {
        this.show();
      } else {
        this.hide();
      }
      return this;
    }

    /**
     * Get the value of the input.
     * @return {String}
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return this.value;
    }

    /**
     * Clear the value of the input.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      this.value = undefined;
      return this;
    }

    /**
     * Disable the input.
     */
  }, {
    key: "disable",
    value: function disable() {
      this.inputEl.attributes.setNamedItem(document.createAttribute('disabled'));
      return this;
    }

    /**
     * Enable the input.
     */
  }, {
    key: "enable",
    value: function enable() {
      this.inputEl.removeAttribute('disabled');
      return this;
    }

    /**
     * Remove typeahead.
     * @param {Boolean} leaveElement Leave the element intact.
     */
  }, {
    key: "_removeTypeahead",
    value: function _removeTypeahead(leaveElement) {
      if (this.typeahead) {
        this.typeahead.remove(leaveElement);
      }
    }

    /**
     * Remove component from DOM.
     * @param {Boolean} leaveElement
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      this._removeTypeahead(leaveElement);
      return (0, _get2.default)((0, _getPrototypeOf2.default)(CardExpiration.prototype), "remove", this).call(this, leaveElement);
    }

    /**
     * Update the element in use and the position.
     * @param {Element} el
     */
  }, {
    key: "update",
    value: function update(el) {
      this._removeTypeahead(true);
      (0, _get2.default)((0, _getPrototypeOf2.default)(CardExpiration.prototype), "update", this).call(this, el);
      this._initTypeahead();
      return this;
    }
  }]);
  return CardExpiration;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
CardExpiration.prototype._whitelistedParams = ['onInput', 'onBlur', 'onFocus', 'onInvalid', 'onValid', 'onValidate', 'validate', 'validatePattern'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
CardExpiration.prototype.defaults = {
  el: null,
  inputEl: null,
  validate: null,
  validatePattern: null,
  onInput: function onInput() {},
  onBlur: function onBlur() {},
  onFocus: function onFocus() {},
  onInvalid: function onInvalid() {},
  onValid: function onValid() {},
  onValidate: function onValidate() {}
};
(0, _mixin.default)(CardExpiration.prototype, _messaging.default, _validation.default);
var _default = CardExpiration;
exports.default = _default;
module.exports = exports.default;


},{"../../helpers/dom/add-class":59,"../../helpers/dom/make-element":62,"../../helpers/dom/remove-class":67,"../../helpers/dom/toggle-class":68,"../../helpers/util/mixin":96,"../../mixins/messaging":104,"../../mixins/validation":105,"../base":3,"../typeahead":50,"@babel/runtime-corejs3/core-js-stable/instance/concat":108,"@babel/runtime-corejs3/core-js-stable/instance/slice":115,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],25:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));
var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));
var _findIndex = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/find-index"));
var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("../base"));
var _typeahead = _interopRequireDefault(require("../typeahead"));
var _addClass = _interopRequireDefault(require("../../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../../helpers/dom/remove-class"));
var _makeElement = _interopRequireDefault(require("../../helpers/dom/make-element"));
var _assign2 = _interopRequireDefault(require("../../helpers/polyfill/assign"));
var _repeat = _interopRequireDefault(require("../../helpers/polyfill/repeat"));
var _startsWith = _interopRequireDefault(require("../../helpers/polyfill/starts-with"));
var _each = _interopRequireDefault(require("../../helpers/util/each"));
var _isInteger = _interopRequireDefault(require("../../helpers/util/is-integer"));
var _mixin = _interopRequireDefault(require("../../helpers/util/mixin"));
var _messaging = _interopRequireDefault(require("../../mixins/messaging"));
var _validation = _interopRequireDefault(require("../../mixins/validation"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Card Number Input
                                                                                                                                                                                                                                                                                                                                              * An input container for card number payment details.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Spark.Payments.CardNumber(el, {...});
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/payments.js
                                                                                                                                                                                                                                                                                                                                              */
var onCardTypeEvent;
var onValidEvent;
var onInvalidEvent;
var cardDefaults = {
  amex: {
    name: "American Express",
    length: 15,
    cvv: 4,
    prefix: [34, 37],
    pattern: [4, 6, 5]
  },
  china: {
    name: "China UnionPay",
    length: [16, 19],
    cvv: 3,
    prefix: 62,
    pattern: [[4, 4, 4, 4], [6, 13]]
  },
  discover: {
    name: "Discover",
    length: 16,
    cvv: 3,
    prefix: [6011, [622126, 622925], [644, 649], 65],
    pattern: [4, 4, 4, 4]
  },
  jcb: {
    name: "JCB",
    length: 16,
    cvv: 3,
    prefix: [[3528, 3589]],
    pattern: [4, 4, 4, 4]
  },
  mc: {
    name: "MasterCard",
    length: 16,
    cvv: 3,
    prefix: [[51, 55]],
    pattern: [4, 4, 4, 4]
  },
  uatp: {
    name: "UATP",
    length: 15,
    cvv: 3,
    prefix: 1,
    pattern: [4, 5, 6]
  },
  dc: {
    name: "Diners Club International",
    length: 14,
    cvv: 3,
    prefix: [[300, 305], 309, 36, [38, 39]],
    pattern: [4, 6, 4]
  },
  visa: {
    name: "Visa",
    length: [16, 19],
    cvv: 3,
    prefix: [4, 4026, 417500, 4405, 4508, 4844, 4913, 4917],
    pattern: [[4, 4, 4, 4], [6, 4, 8, 1]]
  }
};
var unflipCard = function unflipCard() {
  this.el.dataset.cardType = this.type;
  this.multiPattern = false;
  this.patternIndex = false;
  this.type = "";
  this._initTypeAhead();
};
var patternDefaults = {
  placeholder: "0000 0000 0000 0000",
  minlength: 19,
  maxlength: 19,
  pattern: [4, 4, 4, 4],
  validation: "\\d\\d\\d\\d ?\\d\\d\\d\\d ?\\d\\d\\d\\d ?\\d\\d\\d\\d",
  typeaheadformat: "\\d\\d\\d\\d \\d\\d\\d\\d \\d\\d\\d\\d \\d\\d\\d\\d"
};
var CardNumber = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(CardNumber, _BaseComponent);
  var _super = _createSuper(CardNumber);
  /**
   * CardNumber constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function CardNumber(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, CardNumber);
    _this = _super.call(this, el, params);
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    _this._initTypeAhead();
    _this._currentCardProperties = (0, _assign.default)({}, patternDefaults);
    _this._currentPrefix = 0;
    onCardTypeEvent = document.createEvent("Event");
    onValidEvent = document.createEvent("Event");
    onInvalidEvent = document.createEvent("Event");
    onCardTypeEvent.initEvent("type", true, true);
    onValidEvent.initEvent("valid", true, true);
    onInvalidEvent.initEvent("invalid", true, true);
    return _this;
  }

  /**
   * Parse parameters from the elements.
   */
  (0, _createClass2.default)(CardNumber, [{
    key: "_parseParams",
    value: function _parseParams() {
      if (this.disableAllCardDefaults) {
        if (this.cardTypes === null || (0, _keys.default)(this.cardTypes).length === 0) {
          throw new Error("cardTypes param cannot be null or empty when setting disableAllCardDefaults to true.", this.el);
        }
        this._cardTypes = this.cardTypes;
      } else {
        if (this.disableCardDefaults) {
          var _context;
          var disabledDefaults = this.disableCardDefaults;
          var enabledDefaults = {};
          var defaults = (0, _filter.default)(_context = (0, _keys.default)(cardDefaults)).call(_context, function (config) {
            return !disabledDefaults.some(function (disabled) {
              return disabled === config;
            });
          });
          (0, _each.default)(defaults, function (config) {
            return enabledDefaults[config] = (0, _assign2.default)({}, cardDefaults[config]);
          });
          this._cardTypes = (0, _assign2.default)(enabledDefaults, this.cardTypes || {});
        } else {
          this._cardTypes = (0, _assign2.default)(cardDefaults, this.cardTypes || {});
        }
      }
    }

    /**
     * Sets up references
     * @param {Element} el base DOM element
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.inputEl = el.querySelector("input");
      if (this.inputEl.value) {
        (0, _addClass.default)(this.el, "active");
      }
      this.messageEl = this.el.querySelector(".spark-input__message") || (0, _makeElement.default)('<span class="spark-input__message"></span>');
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onInputBound = this._onInput.bind(this);
      this._onCardTypeBound = this._onCardType.bind(this);
      this._onBlurBound = this._onBlur.bind(this);
      this._onFocusBound = this._onFocus.bind(this);
      this._onInvalidBound = this._onInvalid.bind(this);
      this._onValidBound = this._onValid.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.inputEl.addEventListener("input", this._onInputBound, false);
      this.inputEl.addEventListener("type", this._onCardTypeBound, false);
      this.inputEl.addEventListener("blur", this._onBlurBound, false);
      this.inputEl.addEventListener("focus", this._onFocusBound, false);
      this.inputEl.addEventListener("invalid", this._onInvalidBound, false);
      this.inputEl.addEventListener("valid", this._onValidBound, false);
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.inputEl.removeEventListener("input", this._onInputBound, false);
      this.inputEl.removeEventListener("type", this._onCardTypeBound, false);
      this.inputEl.removeEventListener("blur", this._onBlurBound, false);
      this.inputEl.removeEventListener("focus", this._onFocusBound, false);
      this.inputEl.removeEventListener("invalid", this._onInvalidBound, false);
      this.inputEl.removeEventListener("valid", this._onValidBound, false);
    }

    /**
     * onInvalid method for firing provided callbacks
     */
  }, {
    key: "_onInvalid",
    value: function _onInvalid() {
      this.onInvalid.call(this);
    }

    /**
     * onValid method for firing provided callbacks
     */
  }, {
    key: "_onValid",
    value: function _onValid() {
      this.onValid.call(this);
    }

    /**
     * onBlur callback, for controlling component active state, firing provided callbacks, and running validation
     */
  }, {
    key: "_onBlur",
    value: function _onBlur() {
      if (!this.inputEl.value) {
        (0, _removeClass.default)(this.el, "active");
      }
      this.onBlur.call(this);
    }

    /**
     * onFocus callback, for controlling component active state and firing provided callbacks
     */
  }, {
    key: "_onFocus",
    value: function _onFocus() {
      (0, _addClass.default)(this.el, "active");
      this.onFocus.call(this);
    }

    /**
     * onCardType callback for controlling the displayed card type once a matching pattern has been recognized
     */
  }, {
    key: "_onCardType",
    value: function _onCardType() {
      if (this.type) {
        var cardType = this._cardTypes[this.type];
        this.multiPattern = cardType.pattern.some(function (patternValue) {
          return Array.isArray(patternValue);
        });
      } else {
        this.multiPattern = false;
      }
      this.onCardType.call(this);
    }

    /**
     * Updates typeahead based on cardtype
     */
  }, {
    key: "_updateTypeAhead",
    value: function _updateTypeAhead() {
      this.inputEl.setAttribute("placeholder", this._currentCardProperties.placeholder);
      this.inputEl.setAttribute("minlength", this._currentCardProperties.minlength);
      this.inputEl.setAttribute("maxlength", this._currentCardProperties.maxlength);
      this.inputEl.setAttribute("pattern", this._currentCardProperties.pattern);
      this.inputEl.dataset.typeaheadFormat = this._currentCardProperties.typeaheadformat;
      this.typeahead.format = this.typeahead._parseFormat(this._currentCardProperties.typeaheadformat);
      this.typeahead._parseParams();
      this.typeahead.remove(true);
      var placeholderEl = this.el.querySelector(".spark-input__placeholder");
      placeholderEl.parentNode.removeChild(placeholderEl);
      this.typeahead = new _typeahead.default(this.el);
      this.typeahead.updateValue();
    }

    /**
     * Initialize typeahead based on card type
     */
  }, {
    key: "_initTypeAhead",
    value: function _initTypeAhead() {
      if (!this.typeahead) {
        this.multiPattern = false;
        this.inputEl.setAttribute("placeholder", patternDefaults.placeholder);
        this.inputEl.setAttribute("minlength", patternDefaults.minlength);
        this.inputEl.setAttribute("maxlength", patternDefaults.maxlength);
        this.inputEl.setAttribute("pattern", patternDefaults.validation);
        this.inputEl.dataset.typeaheadFormat = patternDefaults.typeaheadformat;
        this.typeahead = new _typeahead.default(this.el);
      }
    }

    /**
     * Get cardType for input value
     */
  }, {
    key: "_getCardType",
    value: function _getCardType() {
      var cardTypeMatched = false;

      // Loop over card type codes to pull type data and compare to value
      // Cards can have different prefixes; 62* can be Bank Of China unless it's in the range of [622126 - 622925] which is Discover
      for (var type in this._cardTypes) {
        var cardType = this._cardTypes[type];
        if ((0, _isInteger.default)(cardType.prefix)) {
          if ((0, _startsWith.default)(this.value, cardType.prefix.toString())) {
            if (type !== this.type) {
              this.type = type;
              this._currentPrefix = cardType.prefix;
            }
            cardTypeMatched = true;
          }
        } else {
          for (var prefixIndex in cardType.prefix) {
            if ((0, _isInteger.default)(cardType.prefix[prefixIndex])) {
              if ((0, _startsWith.default)(this.value, cardType.prefix[prefixIndex].toString())) {
                this.type = type;
                this._currentPrefix = cardType.prefix[prefixIndex];
                cardTypeMatched = true;
              }
            } else {
              var rangeStart = cardType.prefix[prefixIndex][0];
              var rangeEnd = cardType.prefix[prefixIndex][1];
              var valuePrefixSample = parseInt(this.value.substring(0, rangeEnd.toString().length), 10);
              if (valuePrefixSample >= rangeStart && valuePrefixSample <= rangeEnd) {
                this.type = type;
                this._currentPrefix = valuePrefixSample;
                cardTypeMatched = true;
              }
            }
          }
        }
        if (cardTypeMatched === false) {
          this.type = "";
          this._currentPrefix = 0;
        }
      }
    }

    /**
     * Get cardPattern based off of current card Type
     */
  }, {
    key: "_getCardPatterns",
    value: function _getCardPatterns() {
      var _this2 = this,
        _context3;
      var cardType = this._cardTypes[this.type];

      // pattern is an array like [4, 4, 4, 4] that represents number grouping
      var pattern = patternDefaults.pattern;

      // regexPattern converts pattern into a regex like //d//d//d//d etc.
      var regexPattern = patternDefaults.typeaheadformat;

      // typeaheadFormat is the regex used in the typeahed component.
      var typeaheadFormat = patternDefaults.typeaheadformat;
      if (this.multiPattern) {
        var _context2;
        // Identify which pattern to used based off current value length
        var usePattern = function usePattern(length) {
          return _this2.value.length <= length;
        };
        var patternIndex = (0, _findIndex.default)(_context2 = this._cardTypes[this.type].length).call(_context2, usePattern);

        // If there the value is longer than largest option, uses the largest option
        if (patternIndex === -1) {
          patternIndex = this._cardTypes[this.type].length.length - 1;
        }
        pattern = cardType.pattern[patternIndex];
        regexPattern = (0, _map.default)(pattern).call(pattern, function (digits) {
          return (0, _repeat.default)("\\d", digits);
        }).join(" ");
        typeaheadFormat = regexPattern;

        // Add an extra digit to the typeahead if it's multi-pattern and not the last pattern
        if (patternIndex !== cardType.pattern.length - 1) {
          typeaheadFormat += "\\d";
        }
      } else if (cardType) {
        pattern = cardType.pattern;
        regexPattern = (0, _map.default)(pattern).call(pattern, function (digits) {
          return (0, _repeat.default)("\\d", digits);
        }).join(" ");
        typeaheadFormat = regexPattern;
      }
      this._currentCardProperties.placeholder = (0, _map.default)(_context3 = (0, _slice.default)(pattern).call(pattern, 0)).call(_context3, function (digits) {
        return (0, _repeat.default)("0", digits);
      }).join(" ");
      this._currentCardProperties.maxlength = this._currentCardProperties.placeholder.length;
      this._currentCardProperties.minlength = this._currentCardProperties.placeholder.length;
      this._currentCardProperties.typeaheadformat = typeaheadFormat;
      this._currentCardProperties.pattern = regexPattern;
    }

    /**
     * Update typeahead, component active state, determining the card type, and formatting the display
     * Typeahead will trigger the onInput event
     */
  }, {
    key: "_updateInput",
    value: function _updateInput() {
      var currentPrefix = this._currentPrefix;
      var currentPattern = this._currentCardProperties.pattern;
      if (this.value) {
        (0, _addClass.default)(this.el, "active");
        this._getCardType();
        this._getCardPatterns();

        // If the start of card number updated, or the current pattern changed, update the typeahead
        if (this._currentPrefix !== currentPrefix || this._currentCardProperties.pattern !== currentPattern) {
          this._updateTypeAhead();
        }
      } else {
        this.type = null;
      }
      if (!this.type) {
        unflipCard.call(this);
      }
    }

    /**
     * Validate the value using the Luhn algorithm, tests for valid credit card number combinition
     * @returns boolean
     */
  }, {
    key: "_runLuhnTest",
    value: function _runLuhnTest() {
      var nCheck = 0;
      var nDigit = 0;
      var bEven = false;
      var value = this.value;
      value = value.replace(/\D/g, "");
      for (var n = value.length - 1; n >= 0; n--) {
        var cDigit = value.charAt(n);
        nDigit = parseInt(cDigit, 10);
        if (bEven) {
          if ((nDigit *= 2) > 9) nDigit -= 9;
        }
        nCheck += nDigit;
        bEven = !bEven;
      }
      return nCheck % 10 === 0;
    }

    /**
     * onInput callback, for controlling component active state, firing provided callbacks, running validation,
     * determining the card type, and formatting the display
     */
  }, {
    key: "_onInput",
    value: function _onInput(e) {
      // Pasting needs to update TypeAhead inorder to format correctly
      if (e.inputType === 'insertFromPaste') {
        this._updateTypeAhead();
      }
      this._updateInput();
      this.onInput.call(this);
      this.validate();
    }

    /**
     * Getter that returns the currently recognized card type code
     * @return {String}
     */
  }, {
    key: "type",
    get: function get() {
      if (this.activeCardType) {
        return this.activeCardType;
      }
      return undefined;
    }

    /**
     * Setter for changing the currently recognized card type code, and updating the card type graphic
     */,
    set: function set(cardType) {
      if (cardType && cardType !== this.activeCardType) {
        this.previousPattern = this.activePattern;
        this.activePattern = this._cardTypes[cardType].pattern;
        this.activeCardType = cardType;
        this.el.dataset.cardType = "cc-" + cardType;
        if (this.inputEl) {
          this.inputEl.dispatchEvent(onCardTypeEvent);
        }
      } else if (!cardType) {
        this.previousPattern = this.activePattern;
        this.activePattern = undefined;
        this.activeCardType = "";
        this.multiPattern = false;
      }
    }

    /**
     * Getter for Primary Component Value
     * @return {String}
     */
  }, {
    key: "value",
    get: function get() {
      return this.inputEl.value.replace(/\D/g, "");
    }

    /**
     * Setter for Primary Component Value
     * @param {Number} val
     */,
    set: function set(val) {
      if (val.split(' ').join('') === this.inputEl.value.split(' ').join('')) {
        return;
      }
      this.inputEl.value = val;

      // Run input event;
      this._updateInput();
    }

    /**
     * Getter for Valid state, returns true if component value is valid, false if not
     * Runs Luhn Algorithm
     * @return {Boolean}
     */
  }, {
    key: "valid",
    get: function get() {
      var value = this.value;
      if (/[^0-9-\s]+/.test(value)) return false;
      var input = this.inputEl;
      var format = new RegExp(input.getAttribute("pattern"));
      var _passedLuhnTest = this.useLuhnTest ? this._runLuhnTest() : true;
      return input.willValidate && input.value.length >= input.getAttribute("minlength") && format.test(input.value) && _passedLuhnTest;
    }

    /**
     * Method for triggering focus on component's input element from outside of component
     */
  }, {
    key: "focus",
    value: function focus() {
      this.inputEl.focus();
    }

    /**
     * Default validate function. This can be overridden by passing a
     * custom validate method as a parameter.
     */
  }, {
    key: "validate",
    value: function validate() {
      if (this.inputEl.hasAttribute("data-novalidate")) {
        this.inputEl.removeAttribute("data-novalidate");
      }
      if (this.validatePattern) {
        this.inputEl.setAttribute("pattern", this.validatePattern);
      }

      // Trigger callback, dispatch event
      this.onValidate(this.valid, this.value, this);
      this.inputEl.dispatchEvent(this.valid ? onValidEvent : onInvalidEvent);
      return this;
    }

    /**
     * Show the input by adding the active state and setting character counts (if necessary).
     */
  }, {
    key: "show",
    value: function show() {
      (0, _addClass.default)(this.el, "active");
      return this;
    }

    /**
     * Hide the input by removing the active state.
     */
  }, {
    key: "hide",
    value: function hide() {
      (0, _removeClass.default)(this.el, "active");
      return this;
    }

    /**
     * Set the value of the input.
     * @param {Mixed} value
     */
  }, {
    key: "setValue",
    value: function setValue(value) {
      this.value = value;
      if (value) {
        this.show();
      } else {
        this.hide();
      }
      return this;
    }

    /**
     * Get the value of the input.
     * @return {String}
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return this.value;
    }

    /**
     * Clear the value of the input.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      this.value = "";
      return this;
    }

    /**
     * Disable the input.
     */
  }, {
    key: "disable",
    value: function disable() {
      this.inputEl.attributes.setNamedItem(document.createAttribute("disabled"));
      return this;
    }

    /**
     * Enable the input.
     */
  }, {
    key: "enable",
    value: function enable() {
      this.inputEl.removeAttribute("disabled");
      return this;
    }

    /**
     * Remove typeahead
     * @param {Boolean} leaveElement Leave the element intact.
     */
  }, {
    key: "_removeTypeahead",
    value: function _removeTypeahead(leaveElement) {
      if (this.typeahead) {
        this.typeahead.remove(leaveElement);
      }
    }

    /**
     * Remove component from DOM.
     * @param {Boolean} leaveElement
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      this._removeTypeahead(leaveElement);
      return (0, _get2.default)((0, _getPrototypeOf2.default)(CardNumber.prototype), "remove", this).call(this, leaveElement);
    }

    /**
     * Update the element in use and the position.
     * @param {Element} el
     */
  }, {
    key: "update",
    value: function update(el) {
      this._removeTypeahead(true);
      this.typeahead = null;
      (0, _get2.default)((0, _getPrototypeOf2.default)(CardNumber.prototype), "update", this).call(this, el);
      this._initTypeAhead();
      return this;
    }
  }]);
  return CardNumber;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
CardNumber.prototype._whitelistedParams = ["cardTypes", "disableCardDefaults", "disableAllCardDefaults", "useLuhnTest", "onInput", "onBlur", "onFocus", "onValidate", "validate", "validatePattern", "onInvalid", "onValid", "onCardType"];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
CardNumber.prototype.defaults = {
  el: null,
  inputEl: null,
  type: null,
  cardTypes: null,
  disableCardDefaults: null,
  disableAllCardDefaults: false,
  validatePattern: null,
  useLuhnTest: true,
  onInput: function onInput() {},
  onBlur: function onBlur() {},
  onFocus: function onFocus() {},
  onValidate: function onValidate() {},
  onInvalid: function onInvalid() {},
  onValid: function onValid() {},
  onCardType: function onCardType() {}
};
(0, _mixin.default)(CardNumber.prototype, _messaging.default, _validation.default);
var _default = CardNumber;
exports.default = _default;
module.exports = exports.default;


},{"../../helpers/dom/add-class":59,"../../helpers/dom/make-element":62,"../../helpers/dom/remove-class":67,"../../helpers/polyfill/assign":77,"../../helpers/polyfill/repeat":79,"../../helpers/polyfill/starts-with":80,"../../helpers/util/each":94,"../../helpers/util/is-integer":95,"../../helpers/util/mixin":96,"../../mixins/messaging":104,"../../mixins/validation":105,"../base":3,"../typeahead":50,"@babel/runtime-corejs3/core-js-stable/instance/filter":110,"@babel/runtime-corejs3/core-js-stable/instance/find-index":111,"@babel/runtime-corejs3/core-js-stable/instance/map":113,"@babel/runtime-corejs3/core-js-stable/instance/slice":115,"@babel/runtime-corejs3/core-js-stable/object/assign":122,"@babel/runtime-corejs3/core-js-stable/object/keys":123,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],26:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("../base"));
var _popover = _interopRequireDefault(require("../popover"));
var _mixin = _interopRequireDefault(require("../../helpers/util/mixin"));
var _addClass = _interopRequireDefault(require("../../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../../helpers/dom/remove-class"));
var _makeElement = _interopRequireDefault(require("../../helpers/dom/make-element"));
var _messaging = _interopRequireDefault(require("../../mixins/messaging"));
var _validation = _interopRequireDefault(require("../../mixins/validation"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Card Security Code Input
                                                                                                                                                                                                                                                                                                                                              * An input container for payment security code details.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Spark.Payments.CardSecurityCode(el, {...});
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/payments/card-security-code.js
                                                                                                                                                                                                                                                                                                                                              */
var onValidEvent;
var onInvalidEvent;
var CardSecurityCode = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(CardSecurityCode, _BaseComponent);
  var _super = _createSuper(CardSecurityCode);
  /**
   * CardSecurityCode constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function CardSecurityCode(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, CardSecurityCode);
    _this = _super.call(this, el, params);
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    onValidEvent = document.createEvent('Event');
    onInvalidEvent = document.createEvent('Event');
    onValidEvent.initEvent('valid', true, true);
    onInvalidEvent.initEvent('invalid', true, true);
    return _this;
  }

  /**
   * Sets up references
   * @param {Element} el base DOM element
   * @param {Object} params
   */
  (0, _createClass2.default)(CardSecurityCode, [{
    key: "_cacheElements",
    value: function _cacheElements(el, params) {
      this.el = el;
      this.inputEl = el ? el.querySelector('input') : undefined;
      if (params.info) {
        this.infoPopoverEl = document.querySelector(params.info);
      }
      if (!this.el || !this.inputEl) {
        throw new Error('SecurityCode markup missing');
      } else {
        if (this.inputEl.value) {
          (0, _addClass.default)(this.el, 'active');
        }
        if (this.infoPopoverEl) {
          var existingInfoButton = this.el.querySelector('.spark-payment__info--toggle');
          if (existingInfoButton) {
            this.infoEl = existingInfoButton;
          } else {
            this.infoToggleAriaLabel = params.infoToggleAriaLabel || 'Show Card Security Code instructions';
            this.infoEl = (0, _makeElement.default)('<button aria-label="' + this.infoToggleAriaLabel + '" class="spark-payment__info--toggle spark-icon-question-mark-circle spark-icon--md"></button>');
            this.el.appendChild(this.infoEl);
          }
          this.infoPopover = new _popover.default(this.infoPopoverEl, {
            anchorX: 'center',
            anchorY: 'bottom',
            toggleEl: this.infoEl,
            onOpen: function () {
              (0, _addClass.default)(this.infoEl, 'spark-icon--fill');
            }.bind(this),
            onClose: function () {
              (0, _removeClass.default)(this.infoEl, 'spark-icon--fill');
              this.infoEl.focus();
            }.bind(this)
          });
        }
        this.validatePattern = this.validatePattern || this.inputEl.getAttribute('pattern');
        this.messageEl = this.el.querySelector('.spark-input__message') || (0, _makeElement.default)('<span class="spark-input__message"></span>');
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onBlurBound = this._onBlur.bind(this);
      this._onFocusBound = this._onFocus.bind(this);
      this._onInputBound = this._onInput.bind(this);
      this._onInfoBound = this._onInfo.bind(this);
      this._onInvalidBound = this._onInvalid.bind(this);
      this._onValidBound = this._onValid.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.inputEl.addEventListener('input', this._onInputBound, false);
      this.inputEl.addEventListener('blur', this._onBlurBound, false);
      this.inputEl.addEventListener('focus', this._onFocusBound, false);
      this.inputEl.addEventListener('invalid', this._onInvalidBound, false);
      this.inputEl.addEventListener('valid', this._onValidBound, false);
      if (this.infoEl) {
        this.infoEl.addEventListener('click', this._onInfoBound, false);
        this.infoEl.addEventListener('blur', this._onInfoBlurBound, false);
      }
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.inputEl.removeEventListener('input', this._onInputBound, false);
      this.inputEl.removeEventListener('blur', this._onBlurBound, false);
      this.inputEl.removeEventListener('focus', this._onFocusBound, false);
      this.inputEl.removeEventListener('invalid', this._onInvalidBound, false);
      this.inputEl.removeEventListener('valid', this._onValidBound, false);
      if (this.infoEl) {
        this.infoEl.removeEventListener('click', this._onInfoBound, false);
        this.infoEl.removeEventListener('blur', this._onInfoBlurBound, false);
      }
    }

    /**
     * Getter for Primary Component Value
     * @return {String}
     */
  }, {
    key: "value",
    get: function get() {
      return this.inputEl ? this.inputEl.value : undefined;
    }

    /**
     * Setter for Primary Component Value
     * @param {Number} val
     */,
    set: function set(val) {
      if (this.inputEl) {
        if (!isNaN(val)) {
          (0, _addClass.default)(this.el, 'active');
          this.inputEl.value = val;
        } else if (val === '' || val === undefined || val === null) {
          (0, _removeClass.default)(this.el, 'active');
          this.inputEl.value = '';
        }
      }
    }

    /**
     * Allows adjustment of max length externaly, so that as card types are recognized by number,
     * this input may be updated to reflect the correct CVV length
     * @param {Number} length
     */
  }, {
    key: "maxLength",
    set: function set(length) {
      this.inputEl.maxLength = length && length >= 3 && length <= 4 ? length : 4;
    }

    /**
     * Getter for Valid state, returns true if component value is valid, false if not
     * @return {Boolean}
     */
  }, {
    key: "valid",
    get: function get() {
      var isValid = true;

      // Check against regex pattern
      if (this.validatePattern) {
        isValid = new RegExp(this.validatePattern).test(this.inputEl.value);
      }

      // Check against minlength if it is set
      if (this.inputEl.getAttribute('minlength')) {
        isValid = this.inputEl.value.length >= this.inputEl.getAttribute('minlength') && isValid;
      }

      // Check against maxlength if it is set
      if (this.inputEl.getAttribute('maxlength')) {
        isValid = this.inputEl.value.length <= this.inputEl.getAttribute('maxlength') && isValid;
      }
      return this.inputEl.willValidate && isValid;
    }

    /**
     * onBlur callback, for controlling component active state, firing provided callbacks, and running validation
     */
  }, {
    key: "_onBlur",
    value: function _onBlur() {
      if (!this.value) {
        this.hide();
      }
      this.onBlur.call(this);
      if (this.inputEl.hasAttribute('data-novalidate')) {
        this.inputEl.removeAttribute('data-novalidate');
      }
      if (!this.valid) {
        this.inputEl.dispatchEvent(onInvalidEvent);
      }
    }

    /**
     * onFocus callback, for controlling component active state and firing provided callbacks
     */
  }, {
    key: "_onFocus",
    value: function _onFocus() {
      this.show();
      this.onFocus.call(this);
    }

    /**
     * onInput callback, for controlling component active state, firing provided callbacks, and running validation
     */
  }, {
    key: "_onInput",
    value: function _onInput() {
      this.value = this.toString().replace(/\D/g, '');
      if (this.value) {
        this.show();
      }
      this.onInput.call(this);
      if (this.inputEl.hasAttribute('data-novalidate')) {
        return;
      } else {
        // Use default validation mixin to validate the value of the input if a pattern is provided
        if (this.validatePattern) {
          this.validate();
        }

        // Maintain existing validation events until deprecated and removed
        var validityEvent = this.valid ? onValidEvent : onInvalidEvent;
        this.inputEl.dispatchEvent(validityEvent);
      }
    }

    /**
     * onInfo callback, fired when optional info button addon is interacted with
     * either fires callback method, or displays popover
     * @param {Object} e
     */
  }, {
    key: "_onInfo",
    value: function _onInfo(e) {
      e.preventDefault();
      e.stopPropagation();
      if (this.infoPopover) {
        this.infoPopover.open({
          affixTo: this.infoEl
        });
      }
    }

    /**
     * onInvalid method for firing provided callbacks
     */
  }, {
    key: "_onInvalid",
    value: function _onInvalid() {
      this.onInvalid.call(this);
    }

    /**
     * onValid method for firing provided callbacks
     */
  }, {
    key: "_onValid",
    value: function _onValid() {
      this.onValid.call(this);
    }

    /**
     * Method for triggering focus on component's input element from outside of component
     */
  }, {
    key: "focus",
    value: function focus() {
      this.inputEl.focus();
    }

    /**
     * Returns a string equivilent to the currently visible value of the input
     * @return {String}
     */
  }, {
    key: "toString",
    value: function toString() {
      return this.inputEl.value;
    }

    /**
     * Show the input by adding the active state and setting character counts (if necessary).
     */
  }, {
    key: "show",
    value: function show() {
      (0, _addClass.default)(this.el, 'active');
      return this;
    }

    /**
     * Hide the input by removing the active state.
     */
  }, {
    key: "hide",
    value: function hide() {
      (0, _removeClass.default)(this.el, 'active');
      return this;
    }

    /**
     * Set the value of the input.
     * @param {Mixed} value
     */
  }, {
    key: "setValue",
    value: function setValue(value) {
      this.value = value;
      if (value) {
        this.show();
      } else {
        this.hide();
      }
      return this;
    }

    /**
     * Get the value of the input.
     * @return {String}
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return this.value;
    }

    /**
     * Clear the value of the input.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      this.value = '';
      return this;
    }

    /**
     * Disable the input.
     */
  }, {
    key: "disable",
    value: function disable() {
      this.inputEl.attributes.setNamedItem(document.createAttribute('disabled'));
      return this;
    }

    /**
     * Enable the input.
     */
  }, {
    key: "enable",
    value: function enable() {
      this.inputEl.removeAttribute('disabled');
      return this;
    }

    /**
     * Remove component from DOM.
     * @param {Boolean} leaveElement
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(CardSecurityCode.prototype), "remove", this).call(this, leaveElement);
    }

    /**
     * Update the element in use and the position.
     * @param {Element} el
     */
  }, {
    key: "update",
    value: function update(el) {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(CardSecurityCode.prototype), "update", this).call(this, el);
    }
  }]);
  return CardSecurityCode;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
CardSecurityCode.prototype._whitelistedParams = ['onInput', 'onBlur', 'onFocus', 'onInvalid', 'onValid', 'validate', 'onValidate', 'validatePattern'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
CardSecurityCode.prototype.defaults = {
  el: null,
  inputEl: null,
  validatePattern: null,
  onInput: function onInput() {},
  onBlur: function onBlur() {},
  onFocus: function onFocus() {},
  onInvalid: function onInvalid() {},
  onValid: function onValid() {},
  onValidate: function onValidate() {}
};
(0, _mixin.default)(CardSecurityCode.prototype, _messaging.default, _validation.default);
var _default = CardSecurityCode;
exports.default = _default;
module.exports = exports.default;


},{"../../helpers/dom/add-class":59,"../../helpers/dom/make-element":62,"../../helpers/dom/remove-class":67,"../../helpers/util/mixin":96,"../../mixins/messaging":104,"../../mixins/validation":105,"../base":3,"../popover":30,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],27:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _cardNumber = _interopRequireDefault(require("./card-number"));
var _cardExpiration = _interopRequireDefault(require("./card-expiration"));
var _cardSecurityCode = _interopRequireDefault(require("./card-security-code"));
var _base = _interopRequireDefault(require("../base"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Credit Card Input Set
                                                                                                                                                                                                                                                                                                                                              * A way to instantiate multiple credit card inputs at once.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Spark.Payments.UnifiedCreditCard(el, {...});
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/payments/unified-credit-card.js
                                                                                                                                                                                                                                                                                                                                              */
var onValidEvent;
var onInvalidEvent;
var CardSet = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(CardSet, _BaseComponent);
  var _super = _createSuper(CardSet);
  /**
   * CardSet constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function CardSet(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, CardSet);
    _this = _super.call(this, el, params);
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    onValidEvent = document.createEvent('Event');
    onInvalidEvent = document.createEvent('Event');
    onValidEvent.initEvent('valid', true, true);
    onInvalidEvent.initEvent('invalid', true, true);
    return _this;
  }

  /**
   * Sets up references
   * @param {Element} el base DOM element
   * @param {Object} params
   */
  (0, _createClass2.default)(CardSet, [{
    key: "_cacheElements",
    value: function _cacheElements(el, params) {
      var _this2 = this;
      this.el = el;
      if (!this.el) {
        throw new Error('CardSet markup missing');
      } else {
        this.number = new _cardNumber.default(this.el.querySelector('.spark-payment--card-number'), {
          onInput: this._onInput.bind(this),
          onBlur: this._onBlur.bind(this),
          onFocus: this._onFocus.bind(this),
          onCardType: this._onCardType.bind(this),
          cardTypes: params.cardTypes,
          disableCardDefaults: params.disableCardDefaults,
          disableAllCardDefaults: params.disableAllCardDefaults,
          onInvalid: function onInvalid() {
            onInvalidEvent.input = _this2.number;
            _this2.el.dispatchEvent(onInvalidEvent);
          }
        });
        this.expiration = new _cardExpiration.default(this.el.querySelector('.spark-payment--expiration'), {
          onInput: this._onInput.bind(this),
          onBlur: this._onBlur.bind(this),
          onFocus: this._onFocus.bind(this),
          onInvalid: function onInvalid() {
            onInvalidEvent.input = _this2.expiration;
            _this2.el.dispatchEvent(onInvalidEvent);
          }
        });
        this.securityCode = new _cardSecurityCode.default(this.el.querySelector('.spark-payment--card-security-code'), {
          onInput: this._onInput.bind(this),
          onBlur: this._onBlur.bind(this),
          onFocus: this._onFocus.bind(this),
          info: params.info,
          infoToggleAriaLabel: params.infoToggleAriaLabel,
          onInvalid: function onInvalid() {
            onInvalidEvent.input = _this2.securityCode;
            _this2.el.dispatchEvent(onInvalidEvent);
          }
        });
        this.components = [this.number, this.expiration, this.securityCode];
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onInvalidBound = this._onInvalid.bind(this);
      this._onValidBound = this._onValid.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.el.addEventListener('invalid', this._onInvalidBound, false);
      this.el.addEventListener('valid', this._onValidBound, false);
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.el.removeEventListener('invalid', this._onInvalidBound, false);
      this.el.removeEventListener('valid', this._onValidBound, false);
      this.components.every(function (component) {
        return component._removeEventListeners();
      });
    }

    /**
     * Called when the Card Number field recognizes a new type of card,
     * and used to update the max length of the CVV field
     */
  }, {
    key: "_onCardType",
    value: function _onCardType() {
      var type = this.number._cardTypes[this.number.type];
      this.securityCode.maxLength = type.cvv;
      this.onCardType.call(this);
    }

    /**
     * onInput callback for running validation
     */
  }, {
    key: "_onInput",
    value: function _onInput() {
      if (this.valid) {
        this.el.dispatchEvent(onValidEvent);
      }
      this.onInput.call(this);
    }

    /**
     * onBlur callback, for firing provided callback
     */
  }, {
    key: "_onBlur",
    value: function _onBlur() {
      this.onBlur.call(this);
    }

    /**
     * onFocus callback, for firing provided callback
     */
  }, {
    key: "_onFocus",
    value: function _onFocus() {
      this.onFocus.call(this);
    }

    /**
     * onInvalid method for firing provided callback
     * @param {Event} e
     */
  }, {
    key: "_onInvalid",
    value: function _onInvalid(e) {
      this.onInvalid.call(this, e);
    }

    /**
     * onValid method for firing provided callback
     */
  }, {
    key: "_onValid",
    value: function _onValid() {
      this.onValid.call(this);
    }

    /**
     * Getter for Primary Component Values
     * @return {Object}
     */
  }, {
    key: "value",
    get: function get() {
      return {
        number: this.number.value,
        expiration: this.expiration.value,
        securityCode: this.securityCode.value
      };
    }

    /**
     * Setter for Primary Component Values
     * @param {Object} values
     */,
    set: function set() {
      var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.number.value = values.number || this.number.value;
      this.expiration.value = values.expiration || this.expiration.value;
      this.securityCode.value = values.securityCode || this.securityCode.value;
      if (this.components.some(function (component) {
        return component.value;
      }) && this.valid) {
        this.el.dispatchEvent(onValidEvent);
      } else if (this.components.some(function (component) {
        return component.value;
      })) {
        this.el.dispatchEvent(onInvalidEvent);
      }
    }

    /**
     * Getter for Valid state, returns true if component value is valid, false if not
     * @return {Boolean}
     */
  }, {
    key: "valid",
    get: function get() {
      return this.components.every(function (component) {
        return component.valid;
      });
    }

    /**
     * Default validate function. This can be overridden by passing a
     * custom validate method as a parameter.
     */
  }, {
    key: "validate",
    value: function validate() {
      this.onValidate(this.valid, this.value, this);
      return this;
    }

    /**
     * Show the inputs by adding the active state.
     */
  }, {
    key: "show",
    value: function show() {
      this.components.every(function (component) {
        return component.show();
      });
      return this;
    }

    /**
     * Hide the inputs by removing the active state.
     */
  }, {
    key: "hide",
    value: function hide() {
      this.components.every(function (component) {
        return component.hide();
      });
      return this;
    }

    /**
     * Returns the current values
     * @return {Object}
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return this.value;
    }

    /**
     * Set the value of the input.
     * @param {Object} values
     */
  }, {
    key: "setValue",
    value: function setValue() {
      var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.value = values;
      return this;
    }

    /**
     * Clear the value of the input.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      this.components.every(function (component) {
        return component.value = '';
      });
      return this;
    }

    /**
     * Disable the input.
     */
  }, {
    key: "disable",
    value: function disable() {
      this.components.every(function (component) {
        return component.disable();
      });
      return this;
    }

    /**
     * Enable the input.
     */
  }, {
    key: "enable",
    value: function enable() {
      this.components.every(function (component) {
        return component.enable();
      });
      return this;
    }

    /**
     * Remove component from DOM.
     * @param {Boolean} leaveElement
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      this.components.every(function (component) {
        return component.remove(leaveElement);
      });
      return (0, _get2.default)((0, _getPrototypeOf2.default)(CardSet.prototype), "remove", this).call(this, leaveElement);
    }

    /**
     * Update the element in use and the position.
     * @param {Element} el
     * @param {Object} params
     */
  }, {
    key: "update",
    value: function update(el) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this._removeEventListeners();
      this.components.every(function (component) {
        return component.remove(true);
      });
      this._cacheElements.call(this, el || this.el, params);
      this._addEventListeners();
      return this;
    }
  }]);
  return CardSet;
}(_base.default);
/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
CardSet.prototype.defaults = {
  el: null,
  number: {},
  expiration: {},
  securityCode: {},
  onCardType: function onCardType() {},
  onInput: function onInput() {},
  onBlur: function onBlur() {},
  onFocus: function onFocus() {},
  onValid: function onValid() {},
  onInvalid: function onInvalid() {},
  onValidate: function onValidate() {},
  validate: function validate() {}
};

/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
CardSet.prototype._whitelistedParams = ['onCardType', 'onInput', 'onBlur', 'onFocus', 'onValid', 'onInvalid', 'onValidate', 'validate'];
var _default = CardSet;
exports.default = _default;
module.exports = exports.default;


},{"../base":3,"./card-expiration":24,"./card-number":25,"./card-security-code":26,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],28:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _parseFloat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/number/parse-float"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("../base"));
var _toggleClass = _interopRequireDefault(require("../../helpers/dom/toggle-class"));
var _mixin = _interopRequireDefault(require("../../helpers/util/mixin"));
var _messaging = _interopRequireDefault(require("../../mixins/messaging"));
var _validation = _interopRequireDefault(require("../../mixins/validation"));
var _makeElement = _interopRequireDefault(require("../../helpers/dom/make-element"));
var _isInteger = _interopRequireDefault(require("../../helpers/util/is-integer"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # CurrencyInput
                                                                                                                                                                                                                                                                                                                                              * A currency input container.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Spark.Payments.CurrencyInput(el, {
                                                                                                                                                                                                                                                                                                                                              *   // Optional. Callback for when the input value changes.
                                                                                                                                                                                                                                                                                                                                              *   onChange(value, inputInstance) {}
                                                                                                                                                                                                                                                                                                                                              * });
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/payments/currency-input.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var CurrencyInput = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(CurrencyInput, _BaseComponent);
  var _super = _createSuper(CurrencyInput);
  /**
   * CurrencyInput constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function CurrencyInput(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, CurrencyInput);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    if (_this.inputEl.value) {
      _this._formatValue();
      _this.show();
      _this._onInput();
    }
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Show the input by adding the active state.
   */
  (0, _createClass2.default)(CurrencyInput, [{
    key: "show",
    value: function show() {
      this.isActive = true;
      this._updateClass();
      return this;
    }

    /**
     * Hide the input by removing the active state.
     */
  }, {
    key: "hide",
    value: function hide() {
      this.isActive = false;
      this._updateClass();
      return this;
    }

    /**
     * Set the value of the input.
     * @param {Mixed} value
     */
  }, {
    key: "setValue",
    value: function setValue(value) {
      this.inputEl.value = value;
      this._formatValue();
      if (value) {
        this.show();
      } else {
        this.hide();
      }
      (this.onChange || noop)(this.inputEl.value, this);
      return this;
    }

    /**
     * Get the value of the input.
     * @return {String}
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return this.inputEl.value;
    }

    /**
     * Clear the value of the input.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      this.inputEl.value = '';
      return this;
    }

    /**
     * Disable the input.
     */
  }, {
    key: "disable",
    value: function disable() {
      (0, _toggleClass.default)(this.el, 'disabled', true);
      this.inputEl.setAttribute('disabled', '');
      return this;
    }

    /**
     * Enable the input.
     */
  }, {
    key: "enable",
    value: function enable() {
      (0, _toggleClass.default)(this.el, 'disabled', false);
      this.inputEl.removeAttribute('disabled');
      return this;
    }

    /**
     * Remove.
     * @param {Boolean} leaveElement
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(CurrencyInput.prototype), "remove", this).call(this, leaveElement);
    }

    /**
     * Update the element in use and the position.
     * @param {Element} el
     */
  }, {
    key: "update",
    value: function update(el, params) {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(CurrencyInput.prototype), "update", this).call(this, el, params);
    }

    /**
     * Store a reference to the needed elements.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.inputEl = this.el.querySelector('input');
      if (!this.inputEl) {
        throw new Error('No <input> element present in input container!', this.el);
      }
      this.messageEl = this.el.querySelector('.spark-input__message') || (0, _makeElement.default)('<span class="spark-input__message"></span>');
    }

    /**
     * Parse parameters from the elements.
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      this.validatePattern = this.validatePattern || this.inputEl.getAttribute('data-validate');
      this.isActive = this.inputEl.value ? true : false;
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onFocusBound = this._onFocus.bind(this);
      this._onBlurBound = this._onBlur.bind(this);
      this._onInputBound = this._onInput.bind(this);
      this._onKeydownBound = this._onKeydown.bind(this);
    }

    /**
     * Add event listeners for focus, blur, input, and click.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.inputEl.addEventListener('focus', this._onFocusBound);
      this.inputEl.addEventListener('blur', this._onBlurBound);
      this.inputEl.addEventListener('input', this._onInputBound);
      this.inputEl.addEventListener('keydown', this._onKeydownBound);
    }

    /**
     * Remove event listeners for focus, blur and input.
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.inputEl.removeEventListener('focus', this._onFocusBound);
      this.inputEl.removeEventListener('blur', this._onBlurBound);
      this.inputEl.removeEventListener('input', this._onInputBound);
      this.inputEl.removeventListener('keydown', this._onKeydownBound);
    }

    /**
     * Update the active class.
     */
  }, {
    key: "_updateClass",
    value: function _updateClass() {
      (0, _toggleClass.default)(this.el, 'active', this.isActive);
    }

    /**
     * Check for valid decimal separator
     * @param {Object} evt
     */
  }, {
    key: "_validDecimalSeparator",
    value: function _validDecimalSeparator(evt) {
      var val = this.inputEl.value;
      if (evt.key === this.decimalSeparator && val.indexOf(this.decimalSeparator) === -1) return true;
      return false;
    }

    /**
     * Check if the key pressed is valid for this type of input.
     * @param {Object} evt
     */
  }, {
    key: "_validKey",
    value: function _validKey(evt) {
      var key = evt.key;
      if (key === 'Enter') return true;
      if (key === 'Tab') return true;
      if (key === 'Backspace') return true;
      if (key === 'ArrowRight') return true;
      if (key === 'ArrowLeft') return true;
      if (key === 'Shift') return true;
      if (key === 'v' && evt.metaKey === true) return true;
      if (key === 'v' && evt.crtlKey === true) return true;
      if (key === 'c' && evt.metaKey === true) return true;
      if (key === 'c' && evt.crtlKey === true) return true;
      return false;
    }

    /**
     * Check precision of the value.
     */
  }, {
    key: "_validPrecision",
    value: function _validPrecision() {
      var val = this.inputEl.value;
      var currencyParts = val.split(this.decimalSeparator);
      if (currencyParts[1] && currencyParts[1].length === this.precision) return false;
      return true;
    }

    /**
     * Filter key events.
     * @param {Object} evt
     *
     */
  }, {
    key: "_onKeydown",
    value: function _onKeydown(evt) {
      var val = this.inputEl.value;
      var hasDecimalSeparator = val.indexOf(this.decimalSeparator) !== -1;
      var validInteger = (0, _isInteger.default)(Number(evt.key));

      // Check for special keys pass them
      if (this._validKey(evt) === true) return true;
      if (validInteger && hasDecimalSeparator && val.indexOf(this.decimalSeparator) >= evt.target.selectionStart) {
        return true;
      }
      if (validInteger && !this._validPrecision()) {
        evt.preventDefault();
      }

      // If the key is not a number and the it's not a valid decimal separator don't enter it.
      if (!validInteger && !this._validDecimalSeparator(evt)) {
        evt.preventDefault();
      }
    }

    /**
     * When the input element gains focus.
     */
  }, {
    key: "_onFocus",
    value: function _onFocus() {
      this.show();
      (0, _toggleClass.default)(this.el, 'focus', true);
      (this.onFocus || noop)(this.inputEl.value, this);
    }

    /**
     * Format current value to conform to formatting rules.
     */
  }, {
    key: "_formatValue",
    value: function _formatValue() {
      var val = this.inputEl.value;
      var regExLeadingSeparator = new RegExp("^\\" + this.decimalSeparator);
      if (regExLeadingSeparator.test(this.inputEl.value)) {
        val = "0" + val;
      }

      // Remove leading zeros ie 000001.00 would be 1.00
      val = val.replace(/^0*([1-9]|0.)/, '$1');
      if (val.indexOf(this.decimalSeparator !== -1)) {
        val = val.replace(this.decimalSeparator, '.');
        val = !isNaN((0, _parseFloat.default)(val, 10)) ? (0, _parseFloat.default)(val, 10) : 0.00;
        val = val.toFixed(this.precision);
        val = val.replace('.', this.decimalSeparator);
      }
      this.inputEl.value = this.inputEl.value === '' ? '' : val;
    }

    /**
     * When the input element loses focus.
     */
  }, {
    key: "_onBlur",
    value: function _onBlur() {
      if (!this.inputEl.value) {
        this.hide();
      }
      this._formatValue();
      (0, _toggleClass.default)(this.el, 'focus', false);
      (this.onBlur || noop)(this.inputEl.value, this);
    }

    /**
     * When the value is about to change, run the validation
     */
  }, {
    key: "_onInput",
    value: function _onInput() {
      this.validate();
      (this.onChange || noop)(this.inputEl.value, this);
    }
  }]);
  return CurrencyInput;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
CurrencyInput.prototype._whitelistedParams = ['validate', 'validatePattern', 'onValidate', 'onChange', 'onFocus', 'onBlur', 'precision', 'decimalSeparator'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
CurrencyInput.prototype.defaults = {
  el: null,
  messageEl: null,
  inputEl: null,
  clearEl: null,
  isActive: false,
  precision: 2,
  decimalSeparator: '.',
  validatePattern: false,
  type: null,
  onValidate: noop,
  onChange: noop,
  onFocus: noop,
  onBlur: noop,
  _onFocusBound: null,
  _onBlurBound: null,
  _onInputBound: null
};
(0, _mixin.default)(CurrencyInput.prototype, _messaging.default, _validation.default);
var _default = CurrencyInput;
exports.default = _default;
module.exports = exports.default;


},{"../../helpers/dom/make-element":62,"../../helpers/dom/toggle-class":68,"../../helpers/util/is-integer":95,"../../helpers/util/mixin":96,"../../mixins/messaging":104,"../../mixins/validation":105,"../base":3,"@babel/runtime-corejs3/core-js-stable/number/parse-float":121,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],29:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _cardNumber = _interopRequireDefault(require("./card-number"));
var _cardExpiration = _interopRequireDefault(require("./card-expiration"));
var _cardSecurityCode = _interopRequireDefault(require("./card-security-code"));
var _base = _interopRequireDefault(require("../base"));
var _mixin = _interopRequireDefault(require("../../helpers/util/mixin"));
var _addClass = _interopRequireDefault(require("../../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../../helpers/dom/remove-class"));
var _makeElement = _interopRequireDefault(require("../../helpers/dom/make-element"));
var _messaging = _interopRequireDefault(require("../../mixins/messaging"));
var _validation = _interopRequireDefault(require("../../mixins/validation"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Unified Credit Card Input
                                                                                                                                                                                                                                                                                                                                              * An input container for credit card details.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Spark.Payments.UnifiedCreditCard(el, {...});
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/payments/unified-credit-card.js
                                                                                                                                                                                                                                                                                                                                              */
var onValidEvent;
var onInvalidEvent;
var UnifiedCreditCard = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(UnifiedCreditCard, _BaseComponent);
  var _super = _createSuper(UnifiedCreditCard);
  /**
   * UnifiedCreditCard constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function UnifiedCreditCard(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, UnifiedCreditCard);
    _this = _super.call(this, el, params);
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    onValidEvent = document.createEvent('Event');
    onInvalidEvent = document.createEvent('Event');
    onValidEvent.initEvent('valid', true, true);
    onInvalidEvent.initEvent('invalid', true, true);
    return _this;
  }

  /**
   * Sets up references
   * @param {Element} el base DOM element
   * @param {Object} params
   */
  (0, _createClass2.default)(UnifiedCreditCard, [{
    key: "_cacheElements",
    value: function _cacheElements(el, params) {
      var _this2 = this;
      this.el = el;
      this.number = new _cardNumber.default(this.el.querySelector('.spark-payment--card-number'), {
        unified: this,
        cardTypes: params.cardTypes,
        onInput: function onInput() {
          if (_this2.number.inputEl.hasAttribute('data-novalidate')) {
            _this2.number.inputEl.removeAttribute('data-novalidate');
          }
          _this2._onInput();
        },
        onBlur: this._onBlur.bind(this),
        onFocus: function onFocus() {
          if (_this2.number.value && !_this2.number.inputEl.hasAttribute('data-novalidate')) {
            _this2.number.inputEl.attributes.setNamedItem(document.createAttribute('data-novalidate'));
          }
          _this2._onFocus();
        },
        onCardType: this._onCardType.bind(this),
        onInvalid: function onInvalid() {
          onInvalidEvent.input = _this2.number;
          _this2.el.dispatchEvent(onInvalidEvent);
        },
        onValid: function onValid() {
          _this2.expiration.focus();
        }
      });
      this.expiration = new _cardExpiration.default(this.el.querySelector('.spark-payment--expiration'), {
        unified: this,
        onInput: function onInput() {
          if (_this2.expiration.inputEl.hasAttribute('data-novalidate')) {
            _this2.expiration.inputEl.removeAttribute('data-novalidate');
          }
          _this2._onInput();
        },
        onBlur: this._onBlur.bind(this),
        onFocus: function onFocus() {
          if (_this2.expiration.value && !_this2.expiration.inputEl.hasAttribute('data-novalidate')) {
            _this2.expiration.inputEl.attributes.setNamedItem(document.createAttribute('data-novalidate'));
          }
          _this2._onFocus();
        },
        onInvalid: function onInvalid() {
          onInvalidEvent.input = _this2.expiration;
          _this2.el.dispatchEvent(onInvalidEvent);
        },
        onValid: function onValid() {
          _this2.securityCode.focus();
        }
      });
      this.securityCode = new _cardSecurityCode.default(this.el.querySelector('.spark-payment--card-security-code'), {
        unified: this,
        onInput: this._onInput.bind(this),
        onBlur: this._onBlur.bind(this),
        onFocus: this._onFocus.bind(this),
        info: params.info,
        onInvalid: function onInvalid() {
          onInvalidEvent.input = _this2.securityCode;
          _this2.el.dispatchEvent(onInvalidEvent);
        }
      });
      this.components = [this.number, this.expiration, this.securityCode];
      this.messageEl = this.el.querySelector('.spark-input__message') || (0, _makeElement.default)('<span class="spark-input__message"></span>');
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onInvalidBound = this._onInvalid.bind(this);
      this._onValidBound = this._onValid.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.el.addEventListener('invalid', this._onInvalidBound, false);
      this.el.addEventListener('valid', this._onValidBound, false);
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.el.removeEventListener('invalid', this._onInvalidBound, false);
      this.el.removeEventListener('valid', this._onValidBound, false);
      this.components.every(function (component) {
        return component._removeEventListeners();
      });
    }

    /**
     * Called when the Card Number field recognizes a new type of card,
     * and used to update the max length of the CVV field
     */
  }, {
    key: "_onCardType",
    value: function _onCardType() {
      var type = this.number._cardTypes[this.number.type];
      this.securityCode.maxLength = type.cvv;
      this.onCardType.call(this);
    }

    /**
     * onInput callback for running validation
     */
  }, {
    key: "_onInput",
    value: function _onInput() {
      if (this.valid) {
        this.el.dispatchEvent(onValidEvent);
      }
      this.onInput.call(this);
    }

    /**
     * onBlur callback, for firing provided callback
     */
  }, {
    key: "_onBlur",
    value: function _onBlur() {
      this.hide();
      this.onBlur.call(this);
    }

    /**
     * onFocus callback, for firing provided callback
     */
  }, {
    key: "_onFocus",
    value: function _onFocus() {
      this.show();
      this.onFocus.call(this);
    }

    /**
     * onInvalid method for firing provided callback
     * @param {Event} e
     */
  }, {
    key: "_onInvalid",
    value: function _onInvalid(e) {
      this.onInvalid.call(this, e);
    }

    /**
     * onValid method for firing provided callback
     */
  }, {
    key: "_onValid",
    value: function _onValid() {
      this.onValid.call(this);
    }

    /**
     * Getter for Valid state, returns true if component value is valid, false if not
     * @return {Boolean}
     */
  }, {
    key: "valid",
    get: function get() {
      return this.components.every(function (component) {
        return component.valid;
      });
    }

    /**
     * Getter for Primary Component Values
     * @return {Object}
     */
  }, {
    key: "value",
    get: function get() {
      return {
        number: this.number.value,
        expiration: this.expiration.value,
        securityCode: this.securityCode.value
      };
    }

    /**
     * Setter for Primary Component Values
     * @param {Object} values
     */,
    set: function set() {
      var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.number.value = values.number || this.number.value;
      this.expiration.value = values.expiration || this.expiration.value;
      this.securityCode.value = values.securityCode || this.securityCode.value;
      if (this.components.some(function (component) {
        return !!component.value;
      })) {
        this.show();
      } else {
        this.hide();
      }
    }

    /**
     * Default validate function. This can be overridden by passing a
     * custom validate method as a parameter.
     */
  }, {
    key: "validate",
    value: function validate() {
      this.onValidate(this.valid, this.value, this);
      return this;
    }

    /**
     * Show the input by adding the active state and setting character counts (if necessary).
     */
  }, {
    key: "show",
    value: function show() {
      (0, _addClass.default)(this.el, 'active');
      return this;
    }

    /**
     * Hide the input by removing the active state.
     */
  }, {
    key: "hide",
    value: function hide() {
      (0, _removeClass.default)(this.el, 'active');
      return this;
    }

    /**
     * Returns the current values
     * @return {Object}
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return this.value;
    }

    /**
     * Set the value of the input.
     * @param {Object} values
     */
  }, {
    key: "setValue",
    value: function setValue() {
      var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.value = values;
      return this;
    }

    /**
     * Clear the value of the input.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      this.components.every(function (component) {
        return component.value = '';
      });
      return this;
    }

    /**
     * Disable the input.
     */
  }, {
    key: "disable",
    value: function disable() {
      this.components.every(function (component) {
        return component.disable();
      });
      return this;
    }

    /**
     * Enable the input.
     */
  }, {
    key: "enable",
    value: function enable() {
      this.components.every(function (component) {
        return component.enable();
      });
      return this;
    }

    /**
     * Remove component from DOM.
     * @param {Boolean} leaveElement
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      this.components.every(function (component) {
        return component.remove(leaveElement);
      });
      return (0, _get2.default)((0, _getPrototypeOf2.default)(UnifiedCreditCard.prototype), "remove", this).call(this, leaveElement);
    }

    /**
     * Update the element in use and the position.
     * @param {Element} el
     * @param {Object} params
     */
  }, {
    key: "update",
    value: function update(el) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this._removeEventListeners();
      this.components.every(function (component) {
        return component.remove(true);
      });
      this._cacheElements.call(this, el || this.el, params);
      this._addEventListeners();
      return this;
    }
  }]);
  return UnifiedCreditCard;
}(_base.default);
/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
UnifiedCreditCard.prototype.defaults = {
  el: null,
  number: {},
  expiration: {},
  securityCode: {},
  onCardType: function onCardType() {},
  onInput: function onInput() {},
  onBlur: function onBlur() {},
  onFocus: function onFocus() {},
  onValid: function onValid() {},
  onInvalid: function onInvalid() {},
  onValidate: function onValidate() {},
  validate: function validate() {}
};

/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
UnifiedCreditCard.prototype._whitelistedParams = ['onCardType', 'onInput', 'onBlur', 'onFocus', 'onValid', 'onInvalid', 'onValidate', 'validate'];
(0, _mixin.default)(UnifiedCreditCard.prototype, _messaging.default, _validation.default);
var _default = UnifiedCreditCard;
exports.default = _default;
module.exports = exports.default;


},{"../../helpers/dom/add-class":59,"../../helpers/dom/make-element":62,"../../helpers/dom/remove-class":67,"../../helpers/util/mixin":96,"../../mixins/messaging":104,"../../mixins/validation":105,"../base":3,"./card-expiration":24,"./card-number":25,"./card-security-code":26,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],30:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _appendChildren = _interopRequireDefault(require("../helpers/manipulation/append-children"));
var _hasParent = _interopRequireDefault(require("../helpers/traversal/has-parent"));
var _getParent = _interopRequireDefault(require("../helpers/traversal/get-parent"));
var _parseAttribute = require("../helpers/dom/parse-attribute");
var _affix = _interopRequireDefault(require("../helpers/position/affix"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Popover
                                                                                                                                                                                                                                                                                                                                              * Show and hide a popover. Should do some sanity checks on positioning as well.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Popover(el, {
                                                                                                                                                                                                                                                                                                                                              *   // Optional. Default anchoring of the content's x and y-axis relative to the button.
                                                                                                                                                                                                                                                                                                                                              *   defaultAnchorX: 'center', // 'left', 'center', 'right'
                                                                                                                                                                                                                                                                                                                                              *   defaultAnchorY: 'center' // 'left', 'center', 'right'
                                                                                                                                                                                                                                                                                                                                              * });
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/popover.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var Popover = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(Popover, _BaseComponent);
  var _super = _createSuper(Popover);
  function Popover(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Popover);
    _this = _super.call(this, el, params);
    if (!el) return (0, _possibleConstructorReturn2.default)(_this, (0, _assertThisInitialized2.default)(_this));
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    return _this;
  }

  /**
   * Open.
   * @param {Object} params Optional
   */
  (0, _createClass2.default)(Popover, [{
    key: "open",
    value: function open() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // If there is a timer running for the close event, clear it so it
      // doesn't close stuff during open.
      if (this.closeTimer) {
        clearTimeout(this.closeTimer);
        this.closeTimer = null;
      }

      // If the element we anchor the popover to is fixed, we need to know
      // so that the affixed content can also be fixed.
      this._checkFixedPosition();

      // Update an existing affixed instance.
      if (this.affix) {
        this.affix.targetEl = params.affixTo || this.affix.targetEl;
        this.affix.update();

        // Affix the content to the toggle
      } else {
        this.affix = new _affix.default({
          el: this.contentEl,
          targetEl: params.affixTo || this.el,
          caretEl: this.caretEl,
          anchorX: this.anchorX,
          anchorY: this.anchorY,
          isFixed: this.isFixed
        });
      }

      // Listen for clicks on the window
      this._addWindowEventListeners();
      this.isActive = true;

      // If this is a Multi-Action Button/Menu, adjust the expanded state
      if (this.isMultiAction) {
        this.toggleEl.setAttribute('aria-expanded', 'true');
      }

      // Dispatch a custom event so content inside the popover can respond
      var e = document.createEvent('Event');
      e.initEvent('spark.visible-children', true, true);
      this.contentEl.dispatchEvent(e);

      // Update bindings
      this._updateAttributes();

      // Set focus to first focusable element once Popover has been opened
      if (this.focusableElements && this.focusableElements.length > 0) {
        this.firstPopoverFocusableEl.focus();
      }

      // Callbacks
      (params.complete || noop)();
      (this.onOpen || noop)();
      return this;
    }

    /**
     * Close.
     * @param {Object} params Optional
     */
  }, {
    key: "close",
    value: function close() {
      var _this2 = this;
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // Not open, so don't close.
      if (!this.affix) return this;

      // If there is a timer running for the close event, clear it so we don't run close stuff twice.
      if (this.closeTimer) {
        clearTimeout(this.closeTimer);
        this.closeTimer = null;
      }

      // Stop listening to window clicks.
      this._removeWindowEventListeners();
      this.isActive = false;

      // If this is a Multi-Action Button/Menu, adjust the expanded state
      if (this.isMultiAction) {
        this.toggleEl.setAttribute('aria-expanded', 'false');
      }

      // Update bindings
      this._updateAttributes();

      // Close after the animation has completed
      this.closeTimer = setTimeout(function () {
        _this2._finishClose(params);
      }, 250);
      return this;
    }

    /**
     * Toggle the open state.
     */
  }, {
    key: "toggle",
    value: function toggle() {
      return this[this.isActive ? 'close' : 'open']();
    }

    /**
     * Set the content. Optionally append instead of replacing.
     * @param {Element|Array|NodeList} content
     * @param {Object} params Optional
     */
  }, {
    key: "setContent",
    value: function setContent(content, params) {
      params = params || {};
      (0, _appendChildren.default)(this.contentEl, content.length ? content : [content], !(params.append || false));
      return this;
    }

    /**
     * Update the component to use a new element or reparse from
     * the existing element.
     * @param {Element} el Optional
     */
  }, {
    key: "update",
    value: function update(el) {
      this._removeEventListeners();
      this._cacheElements(el || this.el);
      this._addEventListeners();
      if (this.affix) this.affix.update();
      return this;
    }

    /**
     * Get all the elements within the Modal that can be focused on
     */
  }, {
    key: "parseFocusableElements",
    value: function parseFocusableElements() {
      var popoverFocusableEls = this.contentEl.querySelectorAll('a[href]:not([tabindex="-1"]), area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex="0"]');
      if (popoverFocusableEls.length > 0) {
        this.focusableElements = (0, _slice.default)(Array.prototype).call(popoverFocusableEls);
        this.firstPopoverFocusableEl = this.focusableElements[0];
        this.lastPopoverFocusableEl = this.focusableElements[this.focusableElements.length - 1];
      }
    }

    /**
     * Store a reference to the tabs list, each tab and each panel.
     * Set which tab is active, or use the first.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      // If a content element was already passed, make sure it has a popover content class
      if (this.contentEl) {
        (0, _addClass.default)(this.contentEl, 'spark-popover__content');
      }
      this.el = el;
      this.isActive = (0, _hasClass.default)(this.el, 'popover-active');
      this.toggleEl = this.el.querySelector('.spark-popover__toggle, [data-role="toggle"]') || this.el;
      this.contentEl = this.contentEl || this.el.querySelector('.spark-popover__content, [class*="spark-popover__content--"]') || this._createContentEl();
      this.contentEl.setAttribute('aria-modal', 'true');
      this.contentEl.setAttribute('role', 'dialog');
      this.caretEl = this.contentEl.querySelector('.spark-popover__caret') || this._createCaretEl();
      this.isMultiAction = (0, _hasClass.default)(this.toggleEl, 'spark-btn--multi-action') || (0, _hasClass.default)(this.toggleEl, 'spark-btn-combo__secondary');
      this.parseFocusableElements();
    }

    /**
     * Parse config values from the element.
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      this.anchorY = this.anchorY !== null ? this.anchorY : (0, _parseAttribute.string)(this.contentEl, 'data-anchor-y', null);
      this.anchorX = this.anchorX !== null ? this.anchorX : (0, _parseAttribute.string)(this.contentEl, 'data-anchor-x', null);

      // No anchors defined
      if (!this.anchorY && !this.anchorX) {
        // Left
        if ((0, _hasClass.default)(this.contentEl, 'spark-popover__content--left')) {
          this.anchorY = 'middle';
          this.anchorX = 'left';

          // Right
        } else if ((0, _hasClass.default)(this.contentEl, 'spark-popover__content--right')) {
          this.anchorY = 'middle';
          this.anchorX = 'right';

          // Top
        } else if ((0, _hasClass.default)(this.contentEl, 'spark-popover__content--top')) {
          this.anchorY = 'top';
          this.anchorX = 'center';

          // Bottom
        } else {
          this.anchorY = 'bottom';
          this.anchorX = 'center';
        }
      }
    }

    /**
     * Check to see if the button triggering the popover is fixed.
     * If so, then popover needs to be fixed as well.
     */
  }, {
    key: "_checkFixedPosition",
    value: function _checkFixedPosition() {
      var parent = this.el;
      while (parent && parent !== document) {
        var style = getComputedStyle(parent);
        if (style.position === 'fixed') {
          return this.isFixed = true;
        }
        parent = parent.parentNode;
      }
      return this.isFixed = false;
    }

    /**
     * Update classes for the open or close state.
     */
  }, {
    key: "_updateAttributes",
    value: function _updateAttributes() {
      (0, _toggleClass.default)(this.el, 'popover-active', this.isActive);
      (0, _toggleClass.default)(this.contentEl, 'active', this.isActive);
      (0, _toggleClass.default)(this.toggleEl, 'active', this.isActive);
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onTouchStartBound = this._onTouchStart.bind(this);
      this._onTouchEndBound = this._onTouchEnd.bind(this);
      this._onClickBound = this._onClick.bind(this);
      this._onKeydownBound = this._onKeydown.bind(this);
      this._onContentClickBound = this._onContentClick.bind(this);
      this._onWindowClickBound = this._onWindowClick.bind(this);
      this._onWindowKeyupBound = this._onWindowKeyup.bind(this);
      this._onWindowKeydownBound = this._onWindowKeydown.bind(this);
      this._onWindowMouseDownBound = this._onWindowMouseDown.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.el.addEventListener('click', this._onClickBound);
      this.el.addEventListener('keydown', this._onKeydownBound);
      this.contentEl.addEventListener('click', this._onContentClickBound);
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.el.removeEventListener('click', this._onClickBound);
      this.el.removeEventListener('keydown', this._onKeydownBound);
      this.contentEl.removeEventListener('click', this._onContentClickBound);
    }

    /**
     * Add event listeners to the window.
     */
  }, {
    key: "_addWindowEventListeners",
    value: function _addWindowEventListeners() {
      this._removeWindowEventListeners();
      window.addEventListener('click', this._onWindowClickBound);
      window.addEventListener('keyup', this._onWindowKeyupBound);
      window.addEventListener('keydown', this._onWindowKeydownBound);
      window.addEventListener('touchstart', this._onTouchStartBound);
      window.addEventListener('touchend', this._onTouchEndBound);
      window.addEventListener('mousedown', this._onWindowMouseDownBound);
    }

    /**
     * Remove window event listeners.
     */
  }, {
    key: "_removeWindowEventListeners",
    value: function _removeWindowEventListeners() {
      window.removeEventListener('click', this._onWindowClickBound);
      window.removeEventListener('keyup', this._onWindowKeyupBound);
      window.removeEventListener('keydown', this._onWindowKeydownBound);
      window.removeEventListener('touchstart', this._onTouchStartBound);
      window.removeEventListener('touchend', this._onTouchEndBound);
      window.removeEventListener('mousedown', this._onWindowMouseDownBound);
    }

    /**
     * _onTouchStart note touch target
     * @param  {Object} e Event Object
     */
  }, {
    key: "_onTouchStart",
    value: function _onTouchStart(e) {
      if (e.target !== this.el && e.target !== this.contentEl && !(0, _hasParent.default)(e.target, this.el) && !(0, _hasParent.default)(e.target, this.contentEl)) {
        this._tapStart = e.target;
      }
    }

    /**
     * _onTouchEnd compare touch start target w/ touch end target, if identical, treat as "tap"
     * @param  {Object} e Event Object
     */
  }, {
    key: "_onTouchEnd",
    value: function _onTouchEnd(e) {
      if (e.target === this._tapStart) {
        this.close();
      }
      this._tapStart = undefined;
    }

    /**
     * Create a content element.
     * @return {Element}
     */
  }, {
    key: "_createContentEl",
    value: function _createContentEl() {
      var el = document.createElement('div');
      (0, _addClass.default)(el, 'spark-popover__content');
      el.setAttribute('role', 'tooltip');
      return el;
    }

    /**
     * Create the caret element.
     * @return {Element}
     */
  }, {
    key: "_createCaretEl",
    value: function _createCaretEl() {
      var el = document.createElement('div');
      el.className = 'spark-popover__caret';
      this.contentEl.appendChild(el);
      return el;
    }

    /**
     * Complete the close event by moving the element back and destroying the affix.
     * @param  {Object} params
     */
  }, {
    key: "_finishClose",
    value: function _finishClose() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.closeTimer = null;

      // Move the content back to the parent
      this.el.appendChild(this.contentEl);
      this.affix.remove({
        keepEl: true
      });
      this.affix = null;
      (params.complete || noop)();
      (this.onClose || noop)();
    }

    /**
     * When we are clicked, toggle the popover-active state.
     * @param {Object} e
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      // Do not show the Popover if the target is disabled, or the toggle is (a) a parent of the target and (b) is disabled
      // This could occur in tools such as Puppeteer/BackstopJS if the toggle has additional elements inside of it
      if (e.target !== this.el && (e.target.hasAttribute('disabled') || (0, _getParent.default)(e.target, '.spark-popover__toggle', this.toggleEl).hasAttribute('disabled'))) {
        return;
      }

      // If this is the toggle element, toggle.
      if (e.target === this.toggleEl || (0, _hasParent.default)(e.target, this.toggleEl)) {
        e.preventDefault();
        this.toggle();
        return;
      }
    }

    /**
     * When the Enter Key is pressed while focused on the toggle element,
     * show the Popover if the toggle element is not a button or link
     *
     * @param {Object} e
     */
  }, {
    key: "_onKeydown",
    value: function _onKeydown(e) {
      // If the target is a link or button do not continue as those elements have click event by default
      var nodeName = e.target.nodeName.toLowerCase();
      if (nodeName === 'a' || nodeName === 'button') {
        return;
      }

      // Handle Enter Key for other elements
      if (e.keyCode === 13 && e.target === this.toggleEl) {
        e.preventDefault();
        e.stopPropagation();
        this.toggle();
        return;
      }
    }

    /**
     * When a key is pressed on the window and it's an ESC, close the popover.
     * @param {Object} e
     */
  }, {
    key: "_onWindowKeyup",
    value: function _onWindowKeyup(e) {
      if (e.keyCode === 27) {
        this.close();

        // Set focus back to toggle
        this.toggleEl.focus();
      }
    }

    /**
     * When a key is pressed in an active Popover and it is a Tab key, or Shift+Tab, navigate the popover
     * If it the Enter key, and focus is on the close button, close the Popover
     *
     * @param {Object} e
     */
  }, {
    key: "_onWindowKeydown",
    value: function _onWindowKeydown(e) {
      if (e.keyCode === 9) {
        if (this.focusableElements.length === 1) {
          e.preventDefault();
        }
        if (e.shiftKey) {
          this._onBackwardTab(e);
        } else {
          this._onForwardTab(e);
        }
      }

      // Enter Key
      if (e.keyCode === 13) {
        if (e.target === document.querySelector('.spark-popover__close') || (0, _getParent.default)(e.target, '.spark-popover__close', this.contentEl)) {
          e.preventDefault();
          this.close();

          // Set focus back to toggle
          this.toggleEl.focus();
        }
      }
    }

    /**
     * When tabbing backwards, localize traversal to Popover elements only
     * @param {Object} e
     */
  }, {
    key: "_onBackwardTab",
    value: function _onBackwardTab(e) {
      if (document.activeElement === this.firstPopoverFocusableEl) {
        e.preventDefault();
        this.lastPopoverFocusableEl.focus();
      }
    }

    /**
     * When tabbing forwards, localize traversal to Popover elements only
     * @param {Object} e
     */
  }, {
    key: "_onForwardTab",
    value: function _onForwardTab(e) {
      if (document.activeElement === this.lastPopoverFocusableEl) {
        e.preventDefault();
        this.firstPopoverFocusableEl.focus();
      }
    }

    /**
     * When the toggle is clicked, close if it's a link. If it's content, don't do anything but stop
     * the event from bubbling.
     * @param {Object} e
     */
  }, {
    key: "_onContentClick",
    value: function _onContentClick(e) {
      // If this is a link, close.
      if ((0, _getParent.default)(e.target, '.spark-popover__list-link', this.contentEl) || (0, _getParent.default)(e.target, '.spark-popover__close', this.contentEl)) {
        this.close();
        return;
      }
    }

    /**
     * Capture the target on mousedown
     * @param {Object} e
     */
  }, {
    key: "_onWindowMouseDown",
    value: function _onWindowMouseDown(e) {
      this._mouseDownTargetEl = e.target;
    }

    /**
     * When the window is clicked and it's not part of the popover, close the popover.
     * @param {Objec} e
     */
  }, {
    key: "_onWindowClick",
    value: function _onWindowClick(e) {
      // If a mouse is used, verify that the clicking down within the Popover and releasing the mouse outside the Popover does not close the Popover
      var mouseDownTargetMatch = true;
      if (this._mouseDownTargetEl && this._mouseDownTargetEl !== e.target) {
        mouseDownTargetMatch = false;
      }
      if (mouseDownTargetMatch && e.target !== this.el && e.target !== this.contentEl && !(0, _hasParent.default)(e.target, this.el) && !(0, _hasParent.default)(e.target, this.contentEl)) {
        this.close();
      }
    }
  }]);
  return Popover;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
Popover.prototype._whitelistedParams = ['anchorX', 'anchorY', 'toggleEl', 'contentEl', 'onOpen', 'onClose'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
Popover.prototype.defaults = {
  el: null,
  toggleEl: null,
  contentEl: null,
  caretEl: null,
  affix: null,
  isActive: false,
  isMultiAction: false,
  isPaused: false,
  isFixed: false,
  anchorX: null,
  anchorY: null,
  closeTimer: null,
  focusableElements: null,
  onOpen: null,
  onClose: null,
  _onClickBound: null,
  _onContentClickBound: null,
  _onKeydownBound: null,
  _onWindowKeyupBound: null,
  _onWindowKeydownBound: null,
  _onWindowClickBound: null,
  _onWindowResizeBound: null,
  _onWindowScrollBound: null,
  _onWindowMouseDownBound: null
};
var _default = Popover;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/add-class":59,"../helpers/dom/has-class":61,"../helpers/dom/parse-attribute":66,"../helpers/dom/toggle-class":68,"../helpers/manipulation/append-children":73,"../helpers/position/affix":81,"../helpers/traversal/get-parent":87,"../helpers/traversal/has-parent":91,"./base":3,"@babel/runtime-corejs3/core-js-stable/instance/slice":115,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/assertThisInitialized":143,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],31:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _fill = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/fill"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _round = _interopRequireDefault(require("../helpers/util/round"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # ProgressIndicator
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new ProgressIndicator(el, {
                                                                                                                                                                                                                                                                                                                                              *   // Optional. The precision of the progress percentage.
                                                                                                                                                                                                                                                                                                                                              *   precision: 10 // 10 decimal places
                                                                                                                                                                                                                                                                                                                                              * });
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/progress-indicator.js
                                                                                                                                                                                                                                                                                                                                              */
var sizes = {
  large: {
    diameter: 264,
    stroke: 12,
    track: 'M132 6c69.588 0 126 56.412 126 126s-56.412 126-126 126S6 201.588 6 132 62.412 6 132 6z',
    fill: '',
    border: 'M132 252c-66.274 0-120-53.726-120-120S65.726 12 132 12s120 53.726 120 120-53.726 120-120 120z'
  },
  small: {
    diameter: 60,
    stroke: 6,
    track: 'M30 3c14.912 0 27 12.088 27 27S44.912 57 30 57 3 44.912 3 30 15.088 3 30 3z',
    fill: '',
    border: 'M30 54C16.745 54 6 43.255 6 30S16.745 6 30 6s24 10.745 24 24-10.745 24-24 24z'
  },
  extraSmall: {
    diameter: 24,
    stroke: 3,
    track: ' M12 1.5c5.8 0 10.5 4.7 10.5 10.5S17.8 22.5 12 22.5S1.5 17.8 1.5 12S6.2 1.5 12 1.5z',
    fill: '',
    border: ''
  }
};
var ProgressIndicator = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(ProgressIndicator, _BaseComponent);
  var _super = _createSuper(ProgressIndicator);
  /**
   * ProgressIndicator constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function ProgressIndicator(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, ProgressIndicator);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Set the value of the indicator.
   * @param {Number} val
   */
  (0, _createClass2.default)(ProgressIndicator, [{
    key: "set",
    value: function set(val) {
      if (val === this.value) {
        return this;
      }
      if (val > 1) {
        val = 1;
      }
      this.value = val;
      if (this.isDeterminate && this.progressEl) {
        this.progressEl.setAttribute('value', Math.round(val * 100) / 100);
      }
      this._updateDOM();
      return this;
    }

    /**
     * Store a reference to all the needed elements.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.progressEl = this.el.querySelector('progress');
      this.statusEl = this.el.querySelector('.spark-progress__value-status, [role="status"]');
      this.noteEl = this.el.querySelector('.spark-progress__states');
      this.meterEl = this.el.querySelector('.spark-progress__meter');
      this.isDeterminate = this.progressEl.getAttribute('value') !== null;
      this.size = this._determineSize();

      // If this is a determinate value, replace the meter with the SVG.
      if (this.isDeterminate) {
        var svg = this._buildSVG();
        svg.setAttribute('class', this.meterEl.className);
        this.meterEl.parentNode.replaceChild(svg, this.meterEl);
        this.meterEl = svg;
        this.fillEl = this.meterEl.querySelector('.spark-progress__fill');
      }
      if (this.noteEl) {
        this._parseNotes(this.noteEl);
      }
      if (this.progressEl) {
        this.value = this.progressEl.value;
      }
      this._cacheSize();
      this._updateDOM();
    }

    /**
     * Cache the size of the meter.
     */
  }, {
    key: "_cacheSize",
    value: function _cacheSize() {
      this.meterHeight = this.meterEl.clientHeight;
      this.meterWidth = this.meterEl.clientWidth;
    }

    /**
     * Determine the size of the indicator.
     * @return {String}
     */
  }, {
    key: "_determineSize",
    value: function _determineSize() {
      if (this.el.className.indexOf('progress--sm') !== -1) {
        return 'small';
      } else if (this.el.className.indexOf('progress--xs') !== -1) {
        return 'extraSmall';
      }
      return 'large';
    }

    /**
     * Build the proper SVG element for this size indicator.
     * @return {Element}
     */
  }, {
    key: "_buildSVG",
    value: function _buildSVG() {
      var size = sizes[this.size];
      var template = '<svg viewBox="0 0 ' + size.diameter + ' ' + size.diameter + '" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="' + size.track + '" stroke-width="' + size.stroke + '" class="spark-progress__track"/><path d="' + ((0, _fill.default)(size) || size.track) + '" stroke-width="' + size.stroke + '" class="spark-progress__fill"/><path d="' + size.border + '" class="spark-progress__border"/></g></g></svg>';
      var div = document.createElement('div');
      div.innerHTML = template;
      return div.children[0];
    }

    /**
     * Take an unordered list of notes and determine the ranges for
     * when to show a given note.
     * @param  {Element} el
     * @return {Array}
     */
  }, {
    key: "_parseNotes",
    value: function _parseNotes(el) {
      this.notes = this.notes || [];
      var len = el.children.length;
      var i = len - 1;
      for (; i >= 0; i--) {
        this.notes.push({
          min: parseInt(el.children[i].getAttribute('data-value'), 10),
          max: el.children[i + 1] ? parseInt(el.children[i + 1].getAttribute('data-value'), 10) - 1 : 100,
          el: el.children[i]
        });
      }
    }

    /**
     * Update the text visible based on the value. Also adjust the SVG.
     */
  }, {
    key: "_updateDOM",
    value: function _updateDOM() {
      if (!this.isDeterminate) {
        return;
      }
      var updateTime = Date.now();
      var val = (0, _round.default)(this.value * 100, this.precision);

      // Don't animate if we're animating back to 0 or it's been less than 150ms since our last update.
      var noAnimation = val === 0 || this.lastDOMUpdateTime + 150 > updateTime;
      (0, _toggleClass.default)(this.fillEl, 'no-animation', noAnimation);
      this.statusEl.innerHTML = val + '%';
      var dashArray = (sizes[this.size].diameter - sizes[this.size].stroke) * Math.PI;
      var dashOffset = dashArray - dashArray * (val / 100);
      this.fillEl.setAttribute('style', 'stroke-dasharray: ' + dashArray + '; stroke-dashoffset: ' + dashOffset);
      this.lastDOMUpdateTime = updateTime;
      if (!this.notes) {
        return;
      }
      var i = 0;
      var len = this.notes.length;
      for (; i < len; i++) {
        (0, _toggleClass.default)(this.notes[i].el, 'active', this.notes[i].min <= val && this.notes[i].max >= val);
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onResizeBound = this._onResize.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      window.addEventListener('resize', this._onResizeBound);
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      window.removeEventListener('resize', this._onResizeBound);
    }

    /**
     * When the window resizes, cache the dimensions.
     * @param {Object} e
     */
  }, {
    key: "_onResize",
    value: function _onResize() {
      this._cacheSize();
    }
  }]);
  return ProgressIndicator;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
ProgressIndicator.prototype._whitelistedParams = ['precision'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
ProgressIndicator.prototype.defaults = {
  el: null,
  progressEl: null,
  statusEl: null,
  noteEls: null,
  meterEl: null,
  fillEl: null,
  meterHeight: 0,
  meterWidth: 0,
  notes: null,
  isDeterminate: false,
  value: null,
  precision: 0,
  lastDOMUpdateTime: 0,
  _onResizeBound: null
};
var _default = ProgressIndicator;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/toggle-class":68,"../helpers/util/round":101,"./base":3,"@babel/runtime-corejs3/core-js-stable/instance/fill":109,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],32:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/values"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _offset = _interopRequireDefault(require("../helpers/dom/offset"));
var _getIndex = _interopRequireDefault(require("../helpers/traversal/get-index"));
var _messaging = _interopRequireDefault(require("../mixins/messaging"));
var _mixin = _interopRequireDefault(require("../helpers/util/mixin"));
var _validation = _interopRequireDefault(require("../mixins/validation"));
var _makeElement = _interopRequireDefault(require("../helpers/dom/make-element"));
var _modulo = _interopRequireDefault(require("../helpers/util/modulo"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # RangeSlider
                                                                                                                                                                                                                                                                                                                                              * A dual slider for number inputs.
                                                                                                                                                                                                                                                                                                                                              * @todo : probably a lot of refactoring that could happen between this and slider.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new RangeSlider(el, {
                                                                                                                                                                                                                                                                                                                                              *   // Optional. Slide along the x or y-axis?
                                                                                                                                                                                                                                                                                                                                              *   isX: true,
                                                                                                                                                                                                                                                                                                                                              *   onChange: function(inst, index, value){},
                                                                                                                                                                                                                                                                                                                                              * });
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/range-slider.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var RangeSlider = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(RangeSlider, _BaseComponent);
  var _super = _createSuper(RangeSlider);
  /**
   * RangeSlider constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function RangeSlider(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, RangeSlider);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    _this._updateDisabledClasses();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Start the slider moving.
   * @param {Number} index The index of the handle or input element.
   * @param {Number} position The position of the pointer.
   * @param {String} type Optional Which type of events to listen for.
   */
  (0, _createClass2.default)(RangeSlider, [{
    key: "start",
    value: function start(index, position, type) {
      // Noop if we're disabled or an invalid index was passed
      if (index < 0 || this.inputEls[index].getAttribute('disabled') !== null) {
        return this;
      }
      this._addMoveEventListeners(type || 'mouse');
      this._cacheSize();
      this.isActive = this.isActive || [];
      this.isActive[index] = true;
      this.currentIndex = index;
      this._updateActiveClasses(index);
      this._updateDisabledClasses();
      this._oldVal = (0, _values.default)(this)[index];
      this.move(position);
      return this;
    }

    /**
     * Move the value to a given position
     * @param {Number} position
     * @param {Boolean} force Force the move Optional
     */
  }, {
    key: "move",
    value: function move(position, force) {
      // Noop if an invalid index was passed we haven't yet started dragging
      if ((!position || !this.isActive || !this.isActive[this.currentIndex]) && !force) {
        return this;
      }

      // Treat positions beyond the boundaries as the boundaries
      if (this.isX) {
        if (position < this.offsetLeft) {
          // Too far left
          position = this.offsetLeft;
        } else if (position > this.offsetLeft + this.width) {
          // Too far right
          position = this.offsetLeft + this.width;
        }
      } else {
        if (position < this.offsetTop) {
          // Too far top
          position = this.offsetTop;
        } else if (position > this.offsetTop + this.height) {
          // Too far bottom
          position = this.offsetTop + this.height;
        }
      }

      // The percentage of the new position relative to slider-container width or height.
      var percentage = this.isX ? (position - this.offsetLeft) / (this.width - this.handleSize) : (position - this.offsetTop) / this.height;

      // The value of the input as a percentage of the value range.
      var calcValue = (percentage - this.handleSizePercentage / 2) * (this.highestMax - this.lowestMin) + this.lowestMin;
      this.setValue(this.currentIndex, calcValue);
      return this;
    }

    /**
     * Stop listening to movements.
     * @param {Number} index Optional The index of the handle or input element.
     * @param {String} type Optional Which type of events to listen for.
     */
  }, {
    key: "stop",
    value: function stop(index, type) {
      if (index !== null && index !== undefined && this.currentIndex !== index) {
        return this;
      }
      this.isActive[this.currentIndex] = false;
      this.lastIndex = this.currentIndex;
      if (this._oldVal !== (0, _values.default)(this)[this.currentIndex]) {
        (this.onChange || noop)(this.currentIndex, (0, _values.default)(this)[this.currentIndex], this);
      }
      this.currentIndex = null;
      this._updateActiveClasses(index);
      this._removeMoveEventListeners(type || 'mouse');
      return this;
    }

    /**
     * Set the value of the handle.
     * @param {Number} index The index of the input element.
     * @param {Number} value
     */
  }, {
    key: "setValue",
    value: function setValue(index, value) {
      // We don't have an input element at that index, so something went wrong.
      if (!this.inputEls[index]) {
        throw new Error('Cannot set value on a slider input element with an index of ' + index + '. That element does not exist.');
      }

      // Move in increments if we have a defined step size
      if (this.steps[index]) {
        value = value - (0, _modulo.default)(value, this.steps[index]);
      }
      value = Math.round(value * this.valuePrecision[index]) / this.valuePrecision[index];
      this.values = (0, _values.default)(this) || [];

      // Check bounds of the new value
      if (value > this.maxes[index]) {
        value = this.maxes[index];
      } else if (value < this.mins[index]) {
        value = this.mins[index];
      }
      if ((0, _values.default)(this)[index + 1] !== undefined && value >= (0, _values.default)(this)[index + 1]) {
        // If there is an input that comes after this, make sure we aren't going beyond it
        value = (0, _values.default)(this)[index + 1] - (this.steps[index] || 1);
      } else if ((0, _values.default)(this)[index - 1] !== undefined && value <= (0, _values.default)(this)[index - 1]) {
        // If there is an input that comes before this, make sure we aren't going below it
        value = (0, _values.default)(this)[index - 1] + (this.steps[index] || 1);
      }

      // If there is an onWillChange callback, run it. If it returns
      // false, then this new value should be considered invalid.
      if (typeof this.onWillChange === 'function') {
        var change = this.onWillChange(index, value, this);
        if (typeof change === 'number') {
          value = change;
        }
      }

      // Store value
      (0, _values.default)(this)[index] = value;

      // Update elements
      this.inputEls[index].value = (0, _values.default)(this)[index];
      this.handleEls[index].setAttribute('data-value', (0, _values.default)(this)[index]);
      this.handleEls[index].setAttribute('aria-valuenow', (0, _values.default)(this)[index]);
      this.handleEls[index].setAttribute('aria-valuetext', (0, _values.default)(this)[index]);

      // Set the percentage
      this.percentages = this.percentages || [];
      this.percentages[index] = ((0, _values.default)(this)[index] - this.lowestMin) / (this.highestMax - this.lowestMin);

      // Update the position of the handle
      this._updateHandlePosition(index);
      return this;
    }

    /**
     * Get the value.
     * @param {Number} index
     * @return {Number}
     */
  }, {
    key: "getValue",
    value: function getValue(index) {
      // We don't have an input element at that index, so something went wrong.
      if (!this.inputEls[index]) {
        throw new Error('Cannot get value from a slider input element with an index of ' + index + '. That element does not exist.');
      }
      return (0, _values.default)(this)[index];
    }

    /**
     * Clear the value.
     * @param {Number} index
     */
  }, {
    key: "clearValue",
    value: function clearValue(index) {
      return this.setValue(index, 0);
    }

    /**
     * Enable the input.
     * @param {Number} index
     */
  }, {
    key: "enable",
    value: function enable(index) {
      // We don't have an input element at that index, so something went wrong.
      if (!this.inputEls[index] || !this.handleEls[index]) {
        throw new Error('Cannot get value from a slider input element with an index of ' + index + '. That element does not exist.');
      }
      this.inputEls[index].removeAttribute('disabled');
      this.inputEls[index].removeAttribute('tabindex');
      this.handleEls[index].removeAttribute('disabled');
      this.handleEls[index].removeAttribute('tabindex');
      this._updateDisabledClasses();
      return this;
    }

    /**
     * Disable the input.
     * @param {Number} index
     */
  }, {
    key: "disable",
    value: function disable(index) {
      // We don't have an input element at that index, so something went wrong.
      if (!this.inputEls[index] || !this.handleEls[index]) {
        throw new Error('Cannot get value from a slider input element with an index of ' + index + '. That element does not exist.');
      }
      this.inputEls[index].setAttribute('disabled', '');
      this.inputEls[index].setAttribute('tabindex', '-1');
      this.handleEls[index].setAttribute('disabled', '');
      this.handleEls[index].setAttribute('tabindex', '-1');
      this._updateDisabledClasses();
      return this;
    }

    /**
     * Increment the value by the step size.
     * @param {Boolean} useMultiplier Optional Increment by a multiplied version of the step
     */
  }, {
    key: "increment",
    value: function increment(useMultiplier) {
      // If currentIndex is null we need to set it to the appropriate index
      if (this.currentIndex === null) {
        for (var i = 0; i < this.handleEls.length; i++) {
          if (document.activeElement === this.handleEls[i]) {
            this.currentIndex = i;
            break;
          }
        }
      }
      return this.setValue(this.currentIndex, (0, _values.default)(this)[this.currentIndex] + this.steps[this.currentIndex] * (useMultiplier ? 10 : 1));
    }

    /**
     * Decrement the value by the step size.
     * @param {Boolean} useMultiplier Optional Increment by a multiplied version of the step
     */
  }, {
    key: "decrement",
    value: function decrement(useMultiplier) {
      // If currentIndex is null we need to set it to the appropriate index
      if (this.currentIndex === null) {
        for (var i = 0; i < this.handleEls.length; i++) {
          if (document.activeElement === this.handleEls[i]) {
            this.currentIndex = i;
            break;
          }
        }
      }
      return this.setValue(this.currentIndex, (0, _values.default)(this)[this.currentIndex] - this.steps[this.currentIndex] * (useMultiplier ? 10 : 1));
    }

    /**
     * Remove the element from the DOM and prepare for garbage collection by dereferencing values.
     * @param {Boolean} leaveElement Leave the element intact.
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      this._removeMoveEventListeners('touch');
      this._removeMoveEventListeners('mouse');
      this._removeMoveEventListeners('keyboard');
      return (0, _get2.default)((0, _getPrototypeOf2.default)(RangeSlider.prototype), "remove", this).call(this, leaveElement);
    }

    /**
     * Update the component to use a new element or reparse from
     * the existing element.
     * @param {Element} el Optional
     */
  }, {
    key: "update",
    value: function update(el) {
      this._removeEventListeners();
      this._removeMoveEventListeners('touch');
      this._removeMoveEventListeners('mouse');
      this._removeMoveEventListeners('keyboard');
      this._cacheElements(el);
      this._addEventListeners();
      this._updateDisabledClasses();
      for (var i = 0; i < this.handleEls.length; i++) {
        this._updateHandlePosition(i);
      }
      return this;
    }

    /**
     * Store a reference to the whole slider, as well as the
     * input element. Also, get some default values from the input
     * element (min, max, steps).
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.controlsEl = this.el.querySelector('.spark-slider__controls');
      this.inputEls = this.el.querySelectorAll('input[type="number"]');
      this.handleEls = this.el.querySelectorAll('.spark-slider__handle');
      this.trackEl = this.el.querySelector('.spark-slider__track');
      this.trackFillEl = this.trackEl.querySelector('.spark-slider__track-fill');
      this.messageEl = this.el.querySelector('.spark-slider__message') || (0, _makeElement.default)('<span class="spark-slider__message"></span>');
      if (!this.inputEls || this.inputEls.length <= 1) {
        throw new Error('Tried to create a slider instance without two number inputs.');
      }
      if (!this.handleEls || this.handleEls.length <= 1) {
        throw new Error('Tried to create a slider instance without two handle buttons.');
      }
      var lowestMin = Infinity;
      var highestMax = -Infinity;
      var i = 0;
      var len = this.inputEls.length;
      var values = [];
      this.mins = [];
      this.maxes = [];
      this.steps = [];
      this.valuePrecision = [];

      // Cache the size of the element so that we can properly set values on handles.
      this._cacheSize();

      // Set the minimum and max values for each element. Also set any predefined value.
      for (; i < len; i++) {
        var parsedMin = parseFloat(this.inputEls[i].getAttribute('min'));

        // Ternary operator to prevent null when we have actual 0 value
        this.mins[i] = parsedMin === 0 ? parsedMin : parsedMin || null;
        var parsedMax = parseFloat(this.inputEls[i].getAttribute('max'));

        // Ternary operator to prevent null when we have actual 0 value
        this.maxes[i] = parsedMax === 0 ? parsedMax : parsedMax || null;
        this.steps[i] = parseFloat(this.inputEls[i].getAttribute('step')) || 1;

        // Default precision for Integers
        this.valuePrecision[i] = 1;

        // If the steps value is a Float instead of a Integer update the precision for the value
        if (this.inputEls[i].getAttribute('step') && this.inputEls[i].getAttribute('step').split('.')[1]) {
          this.valuePrecision[i] = Math.pow(10, this.inputEls[i].getAttribute('step').split('.')[1].length);
        }
        if (this.mins[i] < lowestMin) {
          lowestMin = this.mins[i];
        }
        if (this.maxes[i] > highestMax) {
          highestMax = this.maxes[i];
        }
      }
      this.lowestMin = lowestMin;
      this.highestMax = highestMax;
      i = 0;

      // If we have a default value, set it.
      for (; i < len; i++) {
        values[i] = parseFloat(this.inputEls[i].getAttribute('value'));

        // It's a number
        if (!isNaN(values[i])) {
          this.setValue(i, values[i]);
        } else {
          // Set as the minimum unless this is the last handle.
          if (i + 1 === len) {
            this.setValue(i, this.maxes[i] !== null ? this.maxes[i] : 0);
          } else {
            this.setValue(i, this.mins[i] !== null ? this.mins[i] : 0);
          }
        }
      }
    }

    /**
     * Save the element dimensions.
     */
  }, {
    key: "_cacheSize",
    value: function _cacheSize() {
      this.width = this.trackEl.offsetWidth;
      this.height = this.trackEl.offsetHeight;
      this.handleSize = this.isX ? this.handleEls[0].offsetWidth : this.handleEls[0].offsetHeight;
      this.handleSizePercentage = this.isX ? this.handleEls[0].offsetWidth / this.width : this.handleEls[0].offsetHeight / this.height;
      var offset = (0, _offset.default)(this.controlsEl);
      this.offsetLeft = offset.left;
      this.offsetTop = offset.top;
    }

    /**
     * Set the position of the handle.
     * @param {Number} index The index of the handle element to update.
     */
  }, {
    key: "_updateHandlePosition",
    value: function _updateHandlePosition(index) {
      // Track and Track-Fill elements
      var firstPercentage = this.percentages[0];
      var lastPercentage = this.percentages[this.percentages.length - 1];
      this.trackFillEl.setAttribute('style', 'width: ' + (lastPercentage - firstPercentage) * 100 + '%; left: ' + firstPercentage * 100 + '%;');

      // Handle position
      var handlePos = this.handleSize / 2 + ((0, _values.default)(this)[index] - this.lowestMin) * ((this.width - this.handleSize) / (this.highestMax - this.lowestMin));
      var handlePosPercentage = handlePos / this.width * 100;
      this.handleEls[index].setAttribute('style', 'left: ' + handlePosPercentage + '%;');
    }

    /**
     * Update the active class on the handle.
     * @param {Number} index The index of the handle element to update.
     */
  }, {
    key: "_updateActiveClasses",
    value: function _updateActiveClasses(index) {
      (0, _toggleClass.default)(this.handleEls, 'active', false);
      (0, _toggleClass.default)(this.handleEls[index], 'active', this.isActive[index]);
      if (this.isActive.indexOf(true) !== -1) {
        this.el.setAttribute('data-active-index', this.isActive.indexOf(true));
      } else {
        this.el.removeAttribute('data-active-index');
      }
    }

    /**
     * Update which handles are disabled.
     */
  }, {
    key: "_updateDisabledClasses",
    value: function _updateDisabledClasses() {
      var disabledCount = 0;
      for (var i = 0, len = this.inputEls.length; i < len; i++) {
        if (this.inputEls[i].getAttribute('disabled') !== null) {
          (0, _toggleClass.default)(this.handleEls[i], 'disabled', true);
          disabledCount++;
        } else {
          (0, _toggleClass.default)(this.handleEls[i], 'disabled', false);
        }
      }
      (0, _toggleClass.default)(this.el, 'all-disabled', disabledCount === this.handleEls.length);
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onTouchStartBound = this._onTouchStart.bind(this);
      this._onTouchMoveBound = this._onTouchMove.bind(this);
      this._onTouchEndBound = this._onTouchEnd.bind(this);
      this._onClickBound = this._onClick.bind(this);
      this._onMouseDownBound = this._onMouseDown.bind(this);
      this._onMouseMoveBound = this._onMouseMove.bind(this);
      this._onMouseUpBound = this._onMouseUp.bind(this);
      this._onFocusBound = this._onFocus.bind(this);
      this._onKeydownBound = this._onKeydown.bind(this);
      this._onBlurBound = this._onBlur.bind(this);
      this._onChangeBound = this._onChange.bind(this);
      this._onResizeBound = this._onResize.bind(this);
      this._onVisibleChildrenBound = this._onVisibleChildren.bind(this);
      this._onWindowClickBound = this._onWindowClick.bind(this);
    }

    /**
     * Add event listeners for touchstart and mouse click.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.controlsEl.addEventListener('touchstart', this._onTouchStartBound);
      this.controlsEl.addEventListener('mousedown', this._onMouseDownBound);
      for (var i = 0, len = this.inputEls.length; i < len; i++) {
        this.inputEls[i].addEventListener('change', this._onChangeBound);
      }
      for (var j = 0, len2 = this.handleEls.length; j < len2; j++) {
        this.handleEls[j].addEventListener('focus', this._onFocusBound);
        this.handleEls[j].addEventListener('click', this._onClickBound);
      }
      document.addEventListener('spark.visible-children', this._onVisibleChildrenBound, true);
      window.addEventListener('resize', this._onResizeBound);
      window.addEventListener('orientationchange', this._onResizeBound);
      window.addEventListener('click', this._onWindowClickBound);
    }

    /**
     * Remove event listeners for touchstart and mouse click.
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.controlsEl.removeEventListener('touchstart', this._onTouchStartBound);
      this.controlsEl.removeEventListener('mousedown', this._onMouseDownBound);
      document.removeEventListener('spark.visible-children', this._onVisibleChildrenBound);
      for (var i = 0, len = this.inputEls.length; i < len; i++) {
        this.inputEls[i].removeEventListener('change', this._onChangeBound);
      }
      for (var j = 0, len2 = this.handleEls.length; j < len2; j++) {
        this.handleEls[j].removeEventListener('focus', this._onFocusBound);
        this.handleEls[j].removeEventListener('click', this._onClickBound);
      }
      window.removeEventListener('resize', this._onResizeBound);
      window.removeEventListener('orientationchange', this._onResizeBound);
      window.removeEventListener('click', this._onWindowClickBound);
    }

    /**
     * Add event listeners for touchmove, touchend, mousemove and mouseup.
     * We add these to the window so that the user can move off of the element
     * but keep dragging the slider handle. Otherwise it's really hard to
     * use the slider unless it's massive.
     * @param {String} type Which type of listeners to add
     */
  }, {
    key: "_addMoveEventListeners",
    value: function _addMoveEventListeners(type) {
      // Only listen for events of the type we asked for.
      switch (type) {
        case 'mouse':
          window.addEventListener('mousemove', this._onMouseMoveBound);
          window.addEventListener('mouseout', this._onMouseOutBound);
          window.addEventListener('mouseup', this._onMouseUpBound);
          break;
        case 'touch':
          window.addEventListener('touchmove', this._onTouchMoveBound);
          window.addEventListener('touchend', this._onTouchEndBound);
          break;
        case 'keyboard':
          window.addEventListener('keydown', this._onKeydownBound);
          for (var i = 0, len = this.handleEls.length; i < len; i++) {
            this.handleEls[i].addEventListener('blur', this._onBlurBound);
          }
          break;
      }
    }

    /**
     * Remove event listeners for move events.
     * @param {String} type Which type of listeners to add
     */
  }, {
    key: "_removeMoveEventListeners",
    value: function _removeMoveEventListeners(type) {
      // Only unbind events of the type we asked for.
      switch (type) {
        case 'mouse':
          window.removeEventListener('mousemove', this._onMouseMoveBound);
          window.removeEventListener('mouseup', this._onMouseUpBound);
          break;
        case 'touch':
          window.removeEventListener('touchmove', this._onTouchMoveBound);
          window.removeEventListener('touchend', this._onTouchEndBound);
          break;
        case 'keyboard':
          window.removeEventListener('keydown', this._onKeydownBound);
          for (var i = 0, len = this.handleEls.length; i < len; i++) {
            this.handleEls[i].removeEventListener('blur', this._onBlurBound);
          }
          break;
      }
    }

    /**
     * When the touch starts, start the slider.
     * @param {Object} e
     */
  }, {
    key: "_onTouchStart",
    value: function _onTouchStart(e) {
      this.start((0, _getIndex.default)(this.handleEls, e.target), this.isX ? e.touches[0].pageX : e.touches[0].pageY, 'touch');
    }

    /**
     * When the window fires a touchmove event, adjust our value accordingly
     * @param {Object} e
     */
  }, {
    key: "_onTouchMove",
    value: function _onTouchMove(e) {
      if (!this.isActive[this.currentIndex]) {
        return;
      }
      e.preventDefault();
      this.move(this.isX ? e.touches[0].pageX : e.touches[0].pageY);
    }

    /**
     * When the window fires a touchend event, stop tracking touches
     * @param {Object} e
     */
  }, {
    key: "_onTouchEnd",
    value: function _onTouchEnd(e) {
      if (!this.isActive[this.currentIndex]) {
        return;
      }
      e.preventDefault();
      this.stop((0, _getIndex.default)(this.handleEls, e.target), 'touch');
    }

    /**
     * When the mouse presses down, start the slider.
     * @param {Object} e
     */
  }, {
    key: "_onMouseDown",
    value: function _onMouseDown(e) {
      this.start((0, _getIndex.default)(this.handleEls, e.target), this.isX ? e.pageX : e.pageY, 'mouse');
    }

    /**
     * When the window fires a mousemove event, adjust our value accordingly
     * @param {Object} e
     */
  }, {
    key: "_onMouseMove",
    value: function _onMouseMove(e) {
      if (!this.isActive[this.currentIndex]) {
        return;
      }
      e.preventDefault();
      this.move(this.isX ? e.pageX : e.pageY);
    }

    /**
     * When the window fires a mouseup event, stop tracking
     * @param {Object} e
     */
  }, {
    key: "_onMouseUp",
    value: function _onMouseUp() {
      if (!this.isActive[this.currentIndex]) {
        return;
      }
      this.stop(null, 'mouse');
    }

    /**
     * Handle the spark.visible-children event
     * @param {Object} e
     */
  }, {
    key: "_onVisibleChildren",
    value: function _onVisibleChildren(e) {
      if (e.target.contains(this.el)) {
        window.setTimeout(function () {
          this._onResize();
        }.bind(this), 0);
      }
    }

    /**
     * When the window resizes, cache size values for the slider.
     * @param {Object} e
     */
  }, {
    key: "_onResize",
    value: function _onResize() {
      this._cacheSize();
      this._updateDisabledClasses();
      for (var i = 0; i < this.handleEls.length; i++) {
        this._updateHandlePosition(i);
      }
    }

    /**
     * When the window is clicked, check if focus is still on one of the handles. If it is not,
     * then remove the window keydown listener which was added when one of the handles received
     * focus. Otherwise it gets stuck and causes console errors.
     */
  }, {
    key: "_onWindowClick",
    value: function _onWindowClick() {
      var handleActive = false;
      for (var i = 0; i < this.handleEls.length; i++) {
        if (document.activeElement === this.handleEls[i]) {
          handleActive = true;
        }
      }
      if (!handleActive) {
        window.removeEventListener('keydown', this._onKeydownBound);
      }
    }

    /**
     * When the element receives focus, start listening for keyboard events
     * @param {Object} e
     */
  }, {
    key: "_onFocus",
    value: function _onFocus(e) {
      this.start((0, _getIndex.default)(this.handleEls, e.target), null, 'keyboard');
    }

    /**
     * When a key is pressed, see if it's one of the Arrow, Page up, Page down, Home
     * or End keys move the handle accordingly. If the shift key is pressed in combination
     * with the arrow keys, we'll increment and decrement by bigger values.
     * @param {Object} e
     */
  }, {
    key: "_onKeydown",
    value: function _onKeydown(e) {
      if ((0, _getIndex.default)(this.inputEls, e.target) !== -1) {
        return;
      }
      if (e.keyCode === 39 || e.keyCode === 38) {
        // Right or Up arrow
        this.increment(e.shiftKey);
      } else if (e.keyCode === 37 || e.keyCode === 40) {
        // Left or down arrow
        this.decrement(e.shiftKey);
      } else if (e.keyCode === 33) {
        // Page Up
        this.increment(true);
      } else if (e.keyCode === 34) {
        // Page Down
        this.decrement(true);
      } else if (e.keyCode === 35) {
        // End
        this.setValue(this.max);
      } else if (e.keyCode === 36) {
        // Home
        this.setValue(this.min);
      }
    }

    /**
     * When the element loses focus, stop listening for keyboard events
     * @param {Object} e
     */
  }, {
    key: "_onBlur",
    value: function _onBlur(e) {
      this.stop((0, _getIndex.default)(this.handleEls, e.target), 'keyboard');
    }

    /**
     * When the input value changes, set our interal value if it's not already our value.
     * @param {Object} e
     */
  }, {
    key: "_onChange",
    value: function _onChange(e) {
      var index = (0, _getIndex.default)(this.inputEls, e.target);
      this._updateDisabledClasses();
      if (e.target.value !== (0, _values.default)(this)[index]) {
        this.setValue(index, e.target.value);
      }
      (this.onChange || noop)(index, (0, _values.default)(this)[index], this);
    }

    /**
     * Prevent click events on the button. This way we don't accidentally submit the form.
     * @param {Object} e
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      e.preventDefault();
    }
  }]);
  return RangeSlider;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
RangeSlider.prototype._whitelistedParams = ['isX', 'validate', 'onValidate', 'onChange', 'onWillChange'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
RangeSlider.prototype.defaults = {
  el: null,
  messageEl: null,
  controlsEl: null,
  inputEls: null,
  handleEls: null,
  trackEl: null,
  trackFillEl: null,
  isActive: null,
  isX: true,
  onValidate: null,
  onChange: null,
  onWillChange: null,
  position: 0,
  width: 0,
  height: 0,
  mins: null,
  maxes: null,
  steps: null,
  values: null,
  percentages: null,
  offsetLeft: 0,
  offsetTop: 0,
  handleSizePercentage: 0,
  currentIndex: null,
  lastIndex: null,
  _oldVal: null,
  _onTouchStartBound: null,
  _onTouchMoveBound: null,
  _onTouchEndBound: null,
  _onMouseDownBound: null,
  _onMouseMoveBound: null,
  _onMouseUpBound: null,
  _onMouseOutBound: null,
  _onFocusBound: null,
  _onKeydownBound: null,
  _onBlurBound: null,
  _onChangeBound: null,
  _onResizeBound: null,
  _onClickBound: null,
  _onWindowClickBound: null,
  _onVisibleChildrenBound: null
};
(0, _mixin.default)(RangeSlider.prototype, _messaging.default, _validation.default);
var _default = RangeSlider;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/make-element":62,"../helpers/dom/offset":63,"../helpers/dom/toggle-class":68,"../helpers/traversal/get-index":86,"../helpers/util/mixin":96,"../helpers/util/modulo":97,"../mixins/messaging":104,"../mixins/validation":105,"./base":3,"@babel/runtime-corejs3/core-js-stable/instance/values":119,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],33:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _scrollTo = _interopRequireDefault(require("../helpers/animation/scroll-to"));
var _offset = _interopRequireDefault(require("../helpers/dom/offset"));
var _debounce = _interopRequireDefault(require("../helpers/util/debounce"));
var _each = _interopRequireDefault(require("../helpers/util/each"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Scroll To Top
                                                                                                                                                                                                                                                                                                                                              * Provide a way to scroll back to the top of a component.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new ScrollToTop(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/scroll-to-top.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var canObserve = typeof MutationObserver !== 'undefined' ? true : false;
var ScrollToTop = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(ScrollToTop, _BaseComponent);
  var _super = _createSuper(ScrollToTop);
  /**
   * ScrollToTop constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function ScrollToTop(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, ScrollToTop);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    _this._cacheSizes();
    _this._clearRecomputeDebounced = (0, _debounce.default)(_this._clearRecompute.bind((0, _assertThisInitialized2.default)(_this)), 50);
    _this._recomputeDebounced = (0, _debounce.default)(_this._recompute.bind((0, _assertThisInitialized2.default)(_this)), 50);
    _this._checkScrollPosition();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  createjQueryPlugin('ScrollToTop',ScrollToTop);

  /**
   * Scroll to the top of the containing element.
   * @param {Function} callback
   */
  (0, _createClass2.default)(ScrollToTop, [{
    key: "scrollToTop",
    value: function scrollToTop(callback) {
      (0, _scrollTo.default)(this.scrollToEl || 0, {
        callback: callback || noop
      });
      return this;
    }

    /**
     * Update the component to use a new element or reparse from
     * the existing element.
     * @param {Element} el Optional
     */
  }, {
    key: "update",
    value: function update(el) {
      this._removeEventListeners();
      this._cacheElements(el);
      this._addEventListeners();
      this._cacheSizes();
      this._checkScrollPosition();
      return this;
    }

    /**
     * Store a reference to the element.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.containerEl = this.containerEl || el.parentNode;
    }

    /**
     * Cache element sizes.
     */
  }, {
    key: "_cacheSizes",
    value: function _cacheSizes() {
      var containerOffset = (0, _offset.default)(this.containerEl);
      var windowWidth = document.body.clientWidth;
      var windowHeight = window.innerHeight;
      var containerOffsetTop = containerOffset.top;
      var containerOffsetLeft = containerOffset.left;
      var containerOffsetRight = windowWidth - containerOffsetLeft - this.containerEl.offsetWidth;
      this._windowHeight = windowHeight;
      this._containerBottom = this.containerEl.offsetHeight + containerOffsetTop;
      this._visibleThreshold = containerOffsetTop + windowHeight * 1.5;

      // Reset button styles
      var isAtBottom = this._isAtBottom;
      this._isAtBottom = false;
      this._right = 0;
      this._updateBindings();

      // Default right position of the element plus the right edge of the container
      this._right = windowWidth - this.el.offsetLeft - this.el.offsetWidth + containerOffsetRight;
      this._isAtBottom = isAtBottom;
      this._updateBindings();
    }

    /**
     * Check the scroll position. If we're far enough from the top,
     * make visible. If the bottom of our container element is past the bottom
     * of the screen, make us fixed.
     */
  }, {
    key: "_checkScrollPosition",
    value: function _checkScrollPosition() {
      var isVisible = this._isVisible;
      var isAtBottom = this._isAtBottom;
      var scrollTop = typeof window.scrollY !== 'undefined' ? window.scrollY : window.pageYOffset;
      var bottomThreshold = scrollTop + this._windowHeight;
      this._isVisible = scrollTop + this._windowHeight >= this._visibleThreshold ? true : false;
      this._isAtBottom = this._containerBottom <= bottomThreshold ? true : false;
      if (this._isAtBottom !== isAtBottom || this._isVisible !== isVisible) {
        this._updateBindings();
      }
    }

    /**
     * Update bindings.
     */
  }, {
    key: "_updateBindings",
    value: function _updateBindings() {
      (0, _toggleClass.default)(this.el, 'visible', this._isVisible);
      (0, _toggleClass.default)(this.el, 'at-bottom', this._isAtBottom);
      this.el.style.right = this._isAtBottom || !this._right ? '' : this._right + 'px';
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onClickBound = this._onClick.bind(this);
      this._onScrollBound = this._onScroll.bind(this);
      this._onResizeBound = this._onResize.bind(this);
      this._onVisibleBound = this._onVisible.bind(this);
      this._onMutateBound = this._onMutate.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.el.addEventListener('click', this._onClickBound);
      window.addEventListener('scroll', this._onScrollBound);
      window.addEventListener('orientationchange', this._onScrollBound);
      document.addEventListener('spark.visible-children', this._onVisibleBound, true);
      if (canObserve) this._addMutationObserver();else window.addEventListener('resize', this._onResizeBound, false);
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.el.removeEventListener('click', this._onClickBound);
      window.removeEventListener('scroll', this._onScrollBound);
      window.removeEventListener('orientationchange', this._onScrollBound);
      document.removeEventListener('spark.visible-children', this._onVisibleBound, true);
      if (canObserve) this._removeMutationObserver();else window.removeEventListener('resize', this._onResizeBound);
    }

    /**
     * Setup a mutation observer to know when the DOM has changed so we can recache.
     */
  }, {
    key: "_addMutationObserver",
    value: function _addMutationObserver() {
      this._observer = new MutationObserver(this._onMutateBound);
      this._observer.observe(this.containerEl, {
        childList: true,
        attributes: true,
        characterData: true,
        subtree: true
      });
    }

    /**
     * Remove a mutation observer.
     */
  }, {
    key: "_removeMutationObserver",
    value: function _removeMutationObserver() {
      if (this._observer) this._observer.disconnect();
    }

    /**
     * Recompute the position.
     */
  }, {
    key: "_recompute",
    value: function _recompute() {
      this._cacheSizes();
      this._checkScrollPosition();
    }

    /**
     * Recompute styles, but only so often.
     */
  }, {
    key: "_recomputeThrottled",
    value: function _recomputeThrottled() {
      if (!this._recomputeRun) {
        this._recompute();
        this._recomputeRun = true;
      }
      this._clearRecomputeDebounced();
    }

    /**
     * Clear the recompute run state.
     */
  }, {
    key: "_clearRecompute",
    value: function _clearRecompute() {
      this._recomputeRun = false;
    }

    /**
     * When the window is scrolled, compute the position of the scroll-to-top.
     * @param {Object} e
     */
  }, {
    key: "_onScroll",
    value: function _onScroll() {
      this._recomputeThrottled();
      this._checkScrollPosition();
    }

    /**
     * When the window is resized, re-cache element sizes.
     * @param {Object} e
     */
  }, {
    key: "_onResize",
    value: function _onResize() {
      this._recomputeDebounced();
    }

    /**
     * When the button is clicked, scroll to the top.
     * @param {Object} e
     */
  }, {
    key: "_onClick",
    value: function _onClick() {
      this.scrollToTop();
    }

    /**
     * When a parent container shows its children and our element
     * is inside of it, resize
     * @param  {Object} e
     */
  }, {
    key: "_onVisible",
    value: function _onVisible(e) {
      if (e.target.contains(this.el)) {
        window.setTimeout(function () {
          this._cacheSizes();
          this._checkScrollPosition();
        }.bind(this), 0);
      }
    }

    /**
     * When the DOM changes, recache our values because we might be in the wrong spot.
     */
  }, {
    key: "_onMutate",
    value: function _onMutate(mutations) {
      (0, _each.default)(mutations, function (m) {
        if (m.target !== this.el) this._recomputeDebounced();
      }.bind(this));
    }
  }]);
  return ScrollToTop;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
ScrollToTop.prototype._whitelistedParams = ['containerEl', 'scrollToEl'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
ScrollToTop.prototype.defaults = {
  el: null,
  containerEl: null,
  scrollToEl: null,
  _isVisible: false,
  _isAtBottom: false,
  _containerBottom: 0,
  _visibleThreshold: 0,
  _windowHeight: 0,
  _right: 0,
  _recomputeRun: false,
  _observer: null,
  _onClickBound: null,
  _onScrollBound: null,
  _onVisibleBound: null,
  _onResizeBound: null,
  _onMutateBound: null
};
var _default = ScrollToTop;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/animation/scroll-to":54,"../helpers/dom/offset":63,"../helpers/dom/toggle-class":68,"../helpers/util/debounce":93,"../helpers/util/each":94,"./base":3,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/assertThisInitialized":143,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],34:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _mixin = _interopRequireDefault(require("../helpers/util/mixin"));
var _messaging = _interopRequireDefault(require("../mixins/messaging"));
var _validation = _interopRequireDefault(require("../mixins/validation"));
var _makeElement = _interopRequireDefault(require("../helpers/dom/make-element"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # SelectInput
                                                                                                                                                                                                                                                                                                                                              * A select input container.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new SelectInput(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/select-input.js
                                                                                                                                                                                                                                                                                                                                              */
var SelectInput = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(SelectInput, _BaseComponent);
  var _super = _createSuper(SelectInput);
  /**
   * SelectInput constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function SelectInput(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, SelectInput);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  createjQueryPlugin('SelectInput',SelectInput);

  /**
   * Get the value.
   * @return {String}
   */
  (0, _createClass2.default)(SelectInput, [{
    key: "getValue",
    value: function getValue() {
      return this.selectEl.value;
    }

    /**
     * Set the value.
     * @param {String|Number} val
     */
  }, {
    key: "setValue",
    value: function setValue(val) {
      // Cast to a string for comparison
      val = val + '';
      var i = 0;
      var len = this.selectEl.children.length;
      for (; i < len; i++) {
        if (this.selectEl.children[i].value === val) {
          this.selectEl.children[i].selected = true;
          this._updateClass();
          this.onChange.call(this, val, this);
          return this;
        }
      }
      return this;
    }

    /**
     * Clear the selected value.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      var i = 0;
      var len = this.selectEl.children.length;
      for (; i < len; i++) {
        if (this.selectEl.children[i].selected === true) {
          this.selectEl.children[i].selected = false;
          this._updateClass();
          this.onChange.call(this, '', this);
          return this;
        }
      }
      return this;
    }

    /**
     * Set the options.
     * @param {Array} opts
     */
  }, {
    key: "setOptions",
    value: function setOptions(opts) {
      var i = 0;
      var len = opts.length;
      var str = '';

      // Store the index of the currently selected option so we can set
      // it when we're all done.
      var curIndex = this.selectEl.selectedIndex;
      for (; i < len; i++) {
        str += '<option ' + (opts[i].value !== undefined ? 'value="' + (opts[i].value || '') + '"' : '') + '>' + (opts[i].text || '') + '</option>';
      }
      this.selectEl.innerHTML = str;
      this.selectEl.selectedIndex = Math.min(len - 1, curIndex);
      return this;
    }

    /**
     * Set the value of the label.
     * @param {String} text
     */
  }, {
    key: "setLabel",
    value: function setLabel(text) {
      if (!this.labelEl) return this;
      this.labelEl.innerHTML = text;
      return this;
    }

    /**
     * Disable entry into the input.
     */
  }, {
    key: "disable",
    value: function disable() {
      this.selectEl.setAttribute('disabled', '');
      return this;
    }

    /**
     * Enable entry into the input.
     */
  }, {
    key: "enable",
    value: function enable() {
      this.selectEl.removeAttribute('disabled');
      return this;
    }

    /**
     * Store a reference to the needed elements.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.selectEl = this.el.querySelector('select');
      this.labelEl = this.el.querySelector('.spark-label');
      this.messageEl = this.el.querySelector('.spark-select__message') || (0, _makeElement.default)('<span class="spark-select__message"></span>');
      if (!this.selectEl) {
        throw new Error('A <select> element must be present!', this.el);
      }
      this._updateClass();
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onFocusBound = this._onFocus.bind(this);
      this._onBlurBound = this._onBlur.bind(this);
      this._onChangeBound = this._onChange.bind(this);
      this._onKeydownBound = this._onKeydown.bind(this);
      this._onClickBound = this._onClick.bind(this);
    }

    /**
     * Add event listeners for focus, blur and input.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.selectEl.addEventListener('focus', this._onFocusBound);
      this.selectEl.addEventListener('blur', this._onBlurBound);
      this.selectEl.addEventListener('change', this._onChangeBound);
      this.selectEl.addEventListener('keydown', this._onKeydownBound);
      this.selectEl.addEventListener('click', this._onClickBound);
    }

    /**
     * Remove event listeners for focus, blur and input.
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.selectEl.removeEventListener('focus', this._onFocusBound);
      this.selectEl.removeEventListener('blur', this._onBlurBound);
      this.selectEl.removeEventListener('change', this._onChangeBound);
      this.selectEl.removeEventListener('keydown', this._onKeydownBound);
      this.selectEl.removeEventListener('click', this._onClickBound);
    }

    /**
     * Update the active class.
     */
  }, {
    key: "_updateClass",
    value: function _updateClass() {
      this.hasValue = this.selectEl.value ? true : false;
      (0, _toggleClass.default)(this.el, 'has-value', this.hasValue);
      (0, _toggleClass.default)(this.el, 'active', this.isActive);
    }

    /**
     * When the input element gains focus.
     * @param {Object} e
     */
  }, {
    key: "_onFocus",
    value: function _onFocus() {
      this.isActive = true;
      this._updateClass();
      var value = this.getValue();
      this.onFocus.call(this, value, this);
    }

    /**
     * When the input element loses focus.
     * @param {Object} e
     */
  }, {
    key: "_onBlur",
    value: function _onBlur() {
      this.isActive = false;
      this._updateClass();
      var value = this.getValue();
      this.onBlur.call(this, value, this);
    }

    /**
     * When the value is about to change, run the validation, set the characters count
     * and resize if we're a textarea.
     * @param {Object} e
     */
  }, {
    key: "_onChange",
    value: function _onChange() {
      this._updateClass();
      var value = this.getValue();
      if (value !== this.previousValue) {
        this.previousValue = value;
        this.onChange.call(this, value, this);
      }
    }

    /**
     * When a key is pressed
     * @param {Event} e
     */
  }, {
    key: "_onKeydown",
    value: function _onKeydown(e) {
      var value = this.getValue();
      this.onKeydown.call(this, e, value, this);
    }

    /**
     * When the Select is clicked
     * @param {Event} e
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      var value = this.getValue();
      this.onClick.call(this, e, value, this);
    }
  }]);
  return SelectInput;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
SelectInput.prototype._whitelistedParams = ['validate', 'onValidate', 'onChange', 'onFocus', 'onBlur', 'onKeydown', 'onClick'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
SelectInput.prototype.defaults = {
  el: null,
  messageEl: null,
  selectEl: null,
  labelEl: null,
  hasValue: false,
  isActive: false,
  onChange: function onChange() {},
  onFocus: function onFocus() {},
  onBlur: function onBlur() {},
  onKeydown: function onKeydown() {},
  onClick: function onClick() {},
  previousValue: null,
  _onFocusBound: null,
  _onBlurBound: null,
  _onChangeBound: null,
  _onKeydownBound: null
};
(0, _mixin.default)(SelectInput.prototype, _messaging.default, _validation.default);
var _default = SelectInput;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/make-element":62,"../helpers/dom/toggle-class":68,"../helpers/util/mixin":96,"../mixins/messaging":104,"../mixins/validation":105,"./base":3,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],35:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/includes"));
var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));
var _from = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/from"));
var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _mixin = _interopRequireDefault(require("../helpers/util/mixin"));
var _events = _interopRequireDefault(require("../mixins/events"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Side Fixed Dock
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Spark.SideFixedDock(el, {sideFixedPanel: Spark.SideFixedPanel});
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/side-fixed-dock.js
                                                                                                                                                                                                                                                                                                                                              * @since 3.4.0
                                                                                                                                                                                                                                                                                                                                              */
var SideFixedDock = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(SideFixedDock, _BaseComponent);
  var _super = _createSuper(SideFixedDock);
  /**
   * SideFixedDock constructor
   * @param {Element} el base DOM element
   * @param {Object} params
   * @constructor
   */
  function SideFixedDock(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, SideFixedDock);
    _this = _super.call(this, el, params);
    if (params.sideFixedPanel) _this.sideFixedPanel = params.sideFixedPanel;
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    return _this;
  }

  /**
   * Sets up references
   * @param  {Element} el base DOM element
   * @private
   */
  (0, _createClass2.default)(SideFixedDock, [{
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     * @private
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onClickBound = this._onClick.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     * @private
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.el.addEventListener('click', this._onClickBound, true);
    }

    /**
     * Remove event listeners for DOM events..
     * @private
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.el.removeEventListener('click', this._onClickBound, true);
    }

    /**
     * On Click, toggle panel if target was button
     * @param {Object} e
     * @private
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      var _context;
      var self = this;
      if (e.target.classList.contains('spark-side-fixed-dock--toggle') && (0, _includes.default)(_context = this.panels).call(_context, e.target.getAttribute('aria-controls'))) {
        if (e.target.getAttribute('aria-expanded') === 'true') {
          this.sideFixedPanel.close().then(function () {
            e.target.setAttribute('aria-expanded', false);
          }).catch(function () {});
        } else {
          this.clearSelected();
          if (this.panels.some(function (id) {
            return id === e.target.getAttribute('aria-controls');
          }) && this.condensed) {
            var panel = this.sideFixedPanel.el.querySelector('#'.concat(e.target.getAttribute('aria-controls')));
            this.condensedPanel.el.appendChild(panel);
            panel.hidden = false;
            this.condensedPanel.open().then(function () {
              var closePanelButton = panel.querySelector('.spark-panel--fixed__close');
              if (closePanelButton) closePanelButton.focus();
              e.target.setAttribute('aria-expanded', true);
            }).catch(function () {});
          } else {
            this.panels.forEach(function (id) {
              self.sideFixedPanel.el.querySelector('#'.concat(id)).hidden = e.target.getAttribute('aria-controls') === id ? false : true;
            });
            this.sideFixedPanel.open().then(function () {
              var closePanelButton = document.getElementById(e.target.getAttribute('aria-controls')).querySelector('.spark-panel--fixed__close');
              if (closePanelButton) closePanelButton.focus();
              e.target.setAttribute('aria-expanded', true);
            }).catch(function () {});
          }
        }
      }
    }

    /**
     * Clear the active state of all dock buttons
     */
  }, {
    key: "clearSelected",
    value: function clearSelected() {
      this.el.querySelectorAll('.spark-btn--icon').forEach(function (btn) {
        return btn.setAttribute('aria-expanded', false);
      });
    }

    /**
     * Returns whether or not dock is currently condensed
     */
  }, {
    key: "condensed",
    get: function get() {
      return !!this.el.classList.contains('spark-panel-dock--condensed');
    }

    /**
     * Getter for Panels
     * @return {Arrays} all associated valid panels
     */
  }, {
    key: "panels",
    get: function get() {
      var _context2;
      var panels = this.sideFixedPanel.el.querySelectorAll('.spark-panel__container__panel__content');
      var panelNames = panels.length ? (0, _map.default)(_context2 = (0, _from.default)(panels)).call(_context2, function (panel) {
        return panel.id;
      }) : [];
      return (0, _filter.default)(panelNames).call(panelNames, function (name) {
        return name !== '';
      });
    }

    /**
     * Getter for width of dock
     * @return {Number} width in pixels
     */
  }, {
    key: "width",
    get: function get() {
      return this.el ? this.el.scrollWidth : 0;
    }

    /**
     * Shrink dock for smaller displays
     * @public
     */
  }, {
    key: "condense",
    value: function condense() {
      if (this.sideFixedPanel.active) {
        var self = this;
        var panel = this.sideFixedPanel.el.querySelector('.spark-panel__container__panel__content:not([hidden])');
        this.condensedPanel.el.appendChild(panel);
        this.condensedPanel.open().then(function () {
          self.el.classList.add('spark-panel-dock--condensed');
          var closeButton = self.condensedPanel.el.querySelector('.spark-panel--fixed__close');
          if (closeButton) closeButton.focus();
        });
      } else {
        this.el.classList.add('spark-panel-dock--condensed');
      }
      this.el.classList.add('spark-panel-dock--condensed');
    }

    /**
     * Enlarge dock
     * @public
     */
  }, {
    key: "expand",
    value: function expand() {
      if (this.condensedPanel.active) {
        var self = this;
        var activeItem = this.el.querySelector('[aria-expanded="true"]');
        this.condensedPanel.close().then(function () {
          self.el.classList.remove('spark-panel-dock--condensed');
          if (activeItem) activeItem.focus();
          self.clearSelected();
        });
      } else {
        this.el.classList.remove('spark-panel-dock--condensed');
      }
    }
  }]);
  return SideFixedDock;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
SideFixedDock.prototype._whitelistedParams = ['sideFixedPanel', 'condensedPanel'];
(0, _mixin.default)(SideFixedDock.prototype, _events.default);
var _default = SideFixedDock;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/util/mixin":96,"../mixins/events":103,"./base":3,"@babel/runtime-corejs3/core-js-stable/array/from":107,"@babel/runtime-corejs3/core-js-stable/instance/filter":110,"@babel/runtime-corejs3/core-js-stable/instance/includes":112,"@babel/runtime-corejs3/core-js-stable/instance/map":113,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],36:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));
var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/includes"));
var _isInteger = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/number/is-integer"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _sideFixedDock = _interopRequireDefault(require("./side-fixed-dock"));
var _underlay = _interopRequireDefault(require("./underlay"));
var _breakpoint = require("../helpers/dom/breakpoint");
var _getParent = _interopRequireDefault(require("../helpers/traversal/get-parent"));
var _mixin = _interopRequireDefault(require("../helpers/util/mixin"));
var _events = _interopRequireDefault(require("../mixins/events"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Side Fixed Panel
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Spark.SideFixedPanel();
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/side-fixed-panel.js
                                                                                                                                                                                                                                                                                                                                              * @since 3.4.0
                                                                                                                                                                                                                                                                                                                                              */
/**
 * Side Fixed Panel
 * @class creates a Side Fixed Panel
 * @extends {BaseComponent}
 */
var SideFixedPanel = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(SideFixedPanel, _BaseComponent);
  var _super = _createSuper(SideFixedPanel);
  /**
   * SideFixedPanel constructor.
   * @param {Element} el base DOM element
   * @param {Object} params
   * @constructor
   */
  function SideFixedPanel(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, SideFixedPanel);
    _this = _super.call(this, el, params);
    if (params.position) _this.position = params.position;
    if (params.toggleEl) _this._toggleEl = params.toggleEl;
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    return _this;
  }

  /**
   * Sets up references
   * @param  {Element} el base DOM element
   * @private
   */
  (0, _createClass2.default)(SideFixedPanel, [{
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.closeButton = this.el.querySelector('.spark-panel--fixed__close');
      this.underlay = new _underlay.default({
        disabled: false,
        display: false,
        style: 'dark'
      });
      var parentEl = (0, _getParent.default)(this.el, 'body') || document.body;
      var dock = parentEl.querySelector('.spark-panel-dock[data-position="' + this.position + '"], .spark-panel-dock--condensed[data-position="' + this.position + '"]');
      if (dock && dock.parentNode.querySelector('.spark-panel--fixed') !== this.el) dock = undefined;
      var condensedPanelEl = undefined;

      /// If Dock markup was found, or this is a push variation, generate a secondary SFP that's cover for when at small screen sizes
      if (dock || this.push) {
        var _context;
        condensedPanelEl = document.createElement('aside');
        condensedPanelEl.classList.add('spark-panel--fixed');
        condensedPanelEl.classList.add('spark-panel--fixed--condensed');
        condensedPanelEl.setAttribute('aria-expanded', false);
        condensedPanelEl.setAttribute('tabindex', '-1');
        condensedPanelEl.dataset.position = this.position;
        condensedPanelEl.dataset.placement = 'cover';
        condensedPanelEl.id = (0, _concat.default)(_context = this.el.id).call(_context, '--alt');
      }
      var self = this;
      if (dock) {
        // If docked, intiate the generated SFP on the Dock
        document.body.appendChild(condensedPanelEl);
        this.dock = new _sideFixedDock.default(dock, {
          sideFixedPanel: this,
          condensedPanel: new SideFixedPanel(condensedPanelEl, {
            _parentPanel: this,
            // On close, return contents back to self
            onClose: function onClose() {
              var panel = self.dock.condensedPanel.el.firstElementChild;
              panel.hidden = true;
              self.display = '';
              self.el.appendChild(panel);
              self.dock.clearSelected();
            }
          })
        });
        this._onResize();
      } else if (this.push) {
        // If stanadard push, initiate the generated SFP on self
        document.body.appendChild(condensedPanelEl);
        this.condensedPanel = new SideFixedPanel(condensedPanelEl, {
          _parentPanel: this,
          // on Close, return contents back to self
          onClose: function onClose() {
            var panel = self.condensedPanel.el.firstElementChild;
            self.display = '';
            self.el.appendChild(panel);
          }
        });
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     * @private
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onUnderlayDismissBound = this._onUnderlayDismiss.bind(this);
      this._onDismissBound = this._onDismiss.bind(this);
      this._onClickBound = this._onClick.bind(this);
      this._onTransitionEndBound = this._onTransitionEnd.bind(this);
      this._onResizeBound = this._onResize.bind(this);
      this._onKeyDownBound = this._onKeyDown.bind(this);
      this._onOpenBound = this._onOpen.bind(this);
      this._onCloseBound = this._onClose.bind(this);
      this._onToggleBound = this._onToggle.bind(this);
      this._toggleBound = this.toggle.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     * @private
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.on('dismiss', this._onDismissBound);
      this.on('toggle', this._onToggleBound);
      this.el.addEventListener('click', this._onClickBound, true);
      this.el.addEventListener('transitionend', this._onTransitionEndBound, true);
      this.el.addEventListener('keydown', this._onKeyDownBound, true);
      this.underlay.on('dismiss', this._onUnderlayDismissBound);
      window.addEventListener('resize', this._onResizeBound, true);
      if (this.toggleEl) this.toggleEl.addEventListener('click', this._toggleBound, true);
    }

    /**
     * Remove event listeners for DOM events..
     * @private
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.off('dismiss', this._onDismissBound);
      this.off('toggle', this._onToggleBound);
      this.el.removeEventListener('click', this._onClickBound, true);
      this.el.removeEventListener('transitionend', this._onTransitionEndBound, true);
      this.el.removeEventListener('keydown', this._onKeyDownBound, true);
      this.underlay.off('dismiss', this._onUnderlayDismissBound);
      window.removeEventListener('resize', this._onResizeBound, true);
      if (this.toggleEl) this.toggleEl.removeEventListener('click', this._toggleBound, true);
    }

    /**
     * On Resize, adjust Panel's position, and possibly width depending on new screen size
     * @private
     */
  }, {
    key: "_onResize",
    value: function _onResize() {
      var _this2 = this;
      this.mediaWidth = window.innerWidth;
      if (this.dock && this.mediaWidth <= this.condensedBreakpoint && !this.dock.condensed) {
        this.dock.condense();
      } else if (this.dock && this.mediaWidth > this.condensedBreakpoint && this.dock.condensed) {
        if (this.dock.condensedPanel.active) {
          var self = this;
          var panelId = this.dock.condensedPanel.el.firstElementChild.id;
          var dockItem = this.dock.el.querySelector('[aria-controls=' + panelId + ']');
          this.dock.condensedPanel.close().then(function () {
            self.dock.expand();
            dockItem.focus();
            dockItem.click();
          });
        } else {
          this.dock.expand();
        }
      } else if (this.dock && this.mediaWidth > this.condensedBreakpoint && !this.dock.condensed) {
        if (this.cover && this.active) {
          this.close();
        }
      }
      if (this.cover) {
        this.currentBreakpoint = (0, _breakpoint.get)(this.mediaWidth);
        if (this.currentBreakpoint === this.mobileBreakpoint || this.mediaWidth <= this.mobileBreakpoint) {
          this.el.style.minWidth = '100%';
          this.el.setAttribute('data-display-fullwidth', '');
          if (this.position === 'right') {
            this.el.style.left = '100%';
            this.el.style.right = 'auto';
            this.translateX = -this.width;
          } else if (this.position === 'left') {
            this.el.style.left = 'auto';
            this.el.style.right = '100%';
            this.translateX = this.width;
          }
        } else {
          this.el.style.minWidth = '';
          this.el.removeAttribute('data-display-fullwidth');
          if (this.active && this.position === 'right') {
            this.translateX = -this.width;
          } else if (this.active && this.position === 'left') {
            this.translateX = this.width;
          }
        }
      }
      if (this.push && this.mediaWidth <= this.condensedBreakpoint && this.active) {
        var _self = this;
        this.close().then(function () {
          _this2.open().catch(function () {
            _self.display = 'open';
          });
        }).catch(function () {
          _self.display = '';
        });
      } else if (this.cover && this.active && this._parentPanel) {
        if (this.mediaWidth > this._parentPanel.condensedBreakpoint) {
          var _self2 = this;
          _self2.close().then(function () {
            _self2._parentPanel.open().catch(function () {
              _self2._parentPanel.display = 'open';
            });
          }).catch(function () {
            _self2.display = '';
          });
        }
      }
    }

    /**
     * On Key Down (ENTER|ESC), close panel / On Key Down (TAB), ensure focus stays or goes where necessary
     * @param {Event} e
     * @private
     */
  }, {
    key: "_onKeyDown",
    value: function _onKeyDown(e) {
      var TAB_KEY_CODE = 9;
      var ENTER_KEY_CODE = 13;
      var ESC_KEY_CODE = 27;
      switch (e.keyCode) {
        case ENTER_KEY_CODE:
          if (e.target === this.closeButton || e.target.classList.contains('spark-panel--fixed__close')) this.close();
          break;
        case ESC_KEY_CODE:
          this.close();
          break;
        case TAB_KEY_CODE:
          {
            if (!this.underlay.active) {
              return;
            }
            var focusable = this.el.querySelectorAll('a[href]:not([tabindex^="-"]):not([disabled]), area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex="0"]');
            if (focusable.length > 0) {
              var focusableElements = (0, _slice.default)(Array.prototype).call(focusable);
              if (focusableElements.length === 1) {
                e.preventDefault();
              } else if (e.shiftKey && document.activeElement === focusableElements[0]) {
                e.preventDefault();
                focusableElements[focusableElements.length - 1].focus();
              } else if (!e.shiftKey && document.activeElement === focusableElements[focusableElements.length - 1]) {
                e.preventDefault();
                focusableElements[0].focus();
              }
            }
            break;
          }
        default:
          return;
      }
    }

    /**
     * If an active underlay associated with this panel is dismissed,
     * then also dismiss the panel
     * @private
     */
  }, {
    key: "_onUnderlayDismiss",
    value: function _onUnderlayDismiss() {
      this.trigger('dismiss');
    }

    /**
     * On Dismiss, close Panel
     * @param {Object} e
     * @private
     */
  }, {
    key: "_onDismiss",
    value: function _onDismiss(e) {
      this.close();
      this.onDismiss.call(this, e);
    }

    /**
     * On Toggle, trigger callbacks
     * @param {Object} e
     * @private
     */
  }, {
    key: "_onToggle",
    value: function _onToggle(e) {
      this.onToggle.call(this, e);
    }

    /**
     * On Click, dismiss panel if target was a `.spark-panel--fixed__close` class close button
     * @param {Object} e
     * @private
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      if (e.target === this.closeButton || e.target.classList.contains('spark-panel--fixed__close')) this._onDismiss(e);
    }

    /**
     * On Transition End, the panel has either finished opening or closing,
     * so pending the current value of `[data-display]`, trigger the proper event ("open" or "close")
     * @private
     */
  }, {
    key: "_onTransitionEnd",
    value: function _onTransitionEnd() {
      // If `[data-display]` currently reads "show",
      // then the panel just finished "opening", so trigger an "open" event
      if (this.display === 'show') this._onOpenBound();

      // If `[data-display]' currently reads "hide",
      // then the panel just finished "closing", so trigger a "close" event
      if (this.display === 'hide') this._onCloseBound();
    }

    /**
     * On Open, the panel has just finished it's animation "open",
     * so retrieve stored `resolve` method in order to close pending promise,
     * update the DOM and focus state, then run `onOpen()` callback
     * @private
     */
  }, {
    key: "_onOpen",
    value: function _onOpen(e) {
      // Change `[data-display]` to "open", to reflect that the panel has finished transitioning and is now open
      this.display = 'open';

      // Since the panel is now "open", make sure the proper `aria` attributes reflect that
      this.el.setAttribute('aria-expanded', true);

      // Verify a `resolve` method exists to be called, before blindly calling on it
      if (typeof this._resolve === 'function') {
        // Resolve the currently pending promise
        this._resolve();

        // Clear the currently stored `resolve` method, so it's not used again
        this._resolve = undefined;
      }
      this.trigger('open');

      // If panel has a close button inside (`.spark-panel--fixed__close`), focus on it
      if (this.closeButton) this.closeButton.focus();

      // Run `onOpen()` callback, while passing on the "onOpen" event object
      this.onOpen.call(this, e);
    }

    /**
     * On Close, the panel has just finished it's animation "closed",
     * so retrieve stored `resolve` method in order to close pending promise,
     * update the DOM and focus state, then run `onClose()` callback
     * @private
     */
  }, {
    key: "_onClose",
    value: function _onClose(e) {
      // Change `[data-display]` to "", to reflect that the panel has finished transitioning and is now closed
      this.display = '';

      // Since the panel is now "closed", make sure the proper `aria` attributes reflect that
      this.el.setAttribute('aria-expanded', false);

      // Verify a `resolve` method exists to be called, before blindly calling on it
      if (typeof this._resolve === 'function') {
        // Resolve the currently pending promise
        this._resolve();

        // Clear the currently stored `resolve` method, so it's not used again
        this._resolve = undefined;
      }

      // If panel is a "cover" type, and not "docked", then all it's value's can be reset
      if (this.cover) {
        if (!this.el.classList.contains('spark-panel--docked') && !this.dock) {
          // Make sure panel is hidden, so that as we reset it's position values,
          // it doesn't accidently cause any bugs
          this.el.style.display = 'none';

          // Now that the panel is hidden, any `transform: translateX()` values,
          // used to transition the panel open/closed may be reset
          this.translateX = 0;

          // Values for CSS position properties `left` and `right` can also be reset
          this.el.style.left = '';
          this.el.style.right = '';

          // Now that positions have been reset, panel should be off screen,
          // and we can clear any values `transform` or `display` from this.el's `style` attribute
          this.el.style.transform = '';
          this.el.style.display = '';
        }
      }

      // If this panel is "docked"
      if (this.dock) {
        // Determine which side fixed dock item was used to open it
        var dockItem = this.dock.el.querySelector('[aria-expanded="true"]');

        // Then return focus to that dock item, now that the panel is closed again
        if (dockItem) dockItem.focus();

        // Also update the dock's DOM, so that no dock items show "open panel" states,
        // and `aria` attributes are correct
        this.dock.clearSelected();
      }
      this.trigger('close');

      // If an element was provided as a toggle, now that the panel is closed,
      // update the toggle's DOM so `aria` attributes are correct, then focus on it
      if (this.toggleEl) {
        this.toggleEl.setAttribute('aria-expanded', false);
        this.toggleEl.focus();
      }

      // Run `onClose()` callback, while passing on the "onClose" event object
      this.onClose.call(this, e);
    }

    /**
     * Position setter
     * @param {String} value
     * @public
     */
  }, {
    key: "position",
    get:
    /**
     * Position getter
     * @return {String} returns current position
     * @public
     */
    function get() {
      return this.el.dataset.position;
    }

    /**
     * Returns whether or not panel is a cover variant
     * @return {Boolean}
     * @public
     */,
    set: function set() {
      var _context2;
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'right';
      value = value.toLowerCase();
      if (this.el && (0, _includes.default)(_context2 = ['right', 'left']).call(_context2, value)) {
        if (this.display === 'open' || this.display === 'show') {
          if (value === 'right') {
            this.el.style.left = 'auto';
            this.el.style.right = '0px';
          } else if (value === 'left') {
            this.el.style.left = '0px';
            this.el.style.right = 'auto';
          }
        } else {
          if (value === 'right') {
            this.el.style.left = '100%';
            this.el.style.right = 'auto';
          } else if (value === 'left') {
            this.el.style.left = 'auto';
            this.el.style.right = '100%';
          }
        }
        this.el.dataset.position = value;
        if (this.display === 'open' || this.display === 'show') {
          this.open().catch(function () {});
        }
      }
    }
  }, {
    key: "cover",
    get: function get() {
      return this.el.dataset.placement === 'cover';
    }

    /**
     * Returns whether or not panel is a push variant
     * @return {Boolean}
     * @public
     */
  }, {
    key: "push",
    get: function get() {
      return this.el.dataset.placement === 'push';
    }

    /**
     * `[data-display]` setter, accepts values of 'show', 'open', 'hide', or ''
     * @param {String} value
     * @public
     */
  }, {
    key: "display",
    get:
    /**
     * Returns the current value of `[data-display]`
     * @return {String}
     * @public
     */
    function get() {
      return this.el ? this.el.dataset.display : undefined;
    }

    /**
     * Setter for adjusting current translateX value
     * @param  {Number} px Pixels
     * @private
     */,
    set: function set(value) {
      var supportedDisplays = ['', 'open', 'show', 'hide'];
      if ((0, _includes.default)(supportedDisplays).call(supportedDisplays, value)) {
        this.el.dataset.display = value;
      } else if (typeof value === 'boolean') {
        this.el.dataset.display = value ? 'show' : 'hide';
      } else if (value === undefined || value === null) {
        this.el.dataset.display = '';
      }
    }
  }, {
    key: "translateX",
    set: function set(px) {
      if (!(0, _isInteger.default)(px) || px === 0) {
        this.el.style.transform = 'translateX(0)';
      } else {
        this.el.style.transform = 'translateX('.concat(px, 'px)');
      }
    }

    /**
     * Getter that returns the current width of the panel
     * @return {Number} px
     * @private
     */
  }, {
    key: "width",
    get: function get() {
      return this.el ? Math.round(this.el.scrollWidth) : 0;
    }

    /**
     * Returns whether or not panel is open or closed
     * @return {Boolean}
     * @public
     */
  }, {
    key: "active",
    get: function get() {
      if (this.condensedPanel && this.condensedPanel.display !== undefined && this.condensedPanel.display !== '') {
        return true;
      } else if (this.display !== undefined && this.display !== '') {
        return true;
      } else {
        return false;
      }
    }

    /**
     * Return Toggle Element if one exists
     * @return {Element}
     */
  }, {
    key: "toggleEl",
    get: function get() {
      return this._toggleEl ? this._toggleEl : undefined;
    }

    /**
     * Designate an element to be used for toggling panel's open/close state
     * @param  {Element}
     */,
    set: function set(el) {
      if (el && el.nodeType === 1) {
        if (this._toggleEl) this._toggleEl.removeEventListener('click', this._toggleBound, true);
        this._toggleEl = el;
        if (!el.hasAttribute('aria-expanded')) el.setAttribute('aria-expanded', this.active);
        if (!el.hasAttribute('aria-label')) el.setAttribute('aria-label', 'Expand or Collapse Panel');
        el.addEventListener('click', this._toggleBound, true);
        this.on('close', this._focusToggleBound);
      } else {
        if (this._toggleEl) this._toggleEl.removeEventListener('click', this._toggleBound, true);
        this._toggleEl = undefined;
      }
    }

    /**
     * Toggle the panel's open/closed state
     * @public
     */
  }, {
    key: "toggle",
    value: function toggle() {
      var self = this;
      var toggle = this.toggleEl;
      switch (this.display) {
        case 'show':
        case 'open':
          this.close().then(function () {
            if (toggle) {
              toggle.setAttribute('aria-expanded', false);
              toggle.focus();
            }
            self.trigger('toggle');
          }).catch(function () {});
          break;
        case 'hide':
        default:
          this.open().then(function () {
            if (toggle) {
              toggle.setAttribute('aria-expanded', true);
            }
            self.trigger('toggle');
          }).catch(function () {});
          break;
      }
    }

    /**
     * Open Panel
     * @param  {Object} options
     * @return {Promise}
     * @public
     */
  }, {
    key: "open",
    value: function open() {
      var _this3 = this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // Store reference to self for use within promise
      var self = this;

      // Make sure the panel's scroll is reset to the top before opening it anew
      if (this.scrollTop) this.el.scrollTop = 0;

      // If panel is a "cover" type but not docked, it may explicitly have `display: none;` set,
      // if it's been opened and closed before, so if so, clear current value for `display`
      if (this.cover && !this.el.classList.contains('spark-panel--docked') && !this.dock) this.el.style.display = '';

      // Resolves on the complete end of the transition event triggered by adjusting `transform: translateX()`
      // [data-display] values control transitions, 'open' and '' are anchors and transitionless,
      // while 'show' and 'hide' will move between 'open' & '', and trigger transition events
      return new _promise.default(function (resolve) {
        // Store a reference to `resolve` outside of the method, in case we need to resolve the promise from a different method
        self._resolve = resolve;

        // If SFP is type "cover" and is in the process of showing ('show'), or already showing ('open')
        if (self.cover && self.display === 'show' || self.display === 'open') {
          // If `position` was passed in as option param, that position value is different from the current position value,
          // and this is not a "docked" variation of SFP
          if (options.position && options.position !== self.position && !self.dock) {
            // Clear any currently stored references to promise resolve methods
            self._resolve = undefined;

            // Close SFP
            self.close().then(function () {
              // Then...
              // Store a reference to _this_ promises `resolve`, and update the position to the value passed in
              self._resolve = resolve;
              self.position = options.position;

              // Check to see if `options.underlay: true|false` was provided
              if (options.underlay === true || options.underlay === undefined) {
                // If underlay not disabled, configure it for use with SFP, then show it
                self.underlay.configure({
                  disabled: false,
                  style: 'dark'
                }).then(self.underlay.show);
              }

              // Make sure SFP has been hidden with a `[data-display]` value of '',
              // so that setting 'show' will trigger an animated opening transition,
              // then set to 'show' to trigger that transition
              self.display = '';
              self.display = 'show';

              // Depending on the current `position` value,
              // properly set CSS `left` or `right` position properties,
              // so that the SFP will be pushed entirely off screen, but resting right on the edge

              if (self.position === 'right') {
                // If the position is "right"

                // Set `left` to `100%` (viewport width units),
                // then use width of SFP to set new `transform: translateX()` value,
                // in order to trigger animated transition
                self.el.style.left = '100%';
                self.translateX = -self.width;
              } else if (self.position === 'left') {
                // If the position is "left"

                // Set `right` to `100%` (viewport width units),
                // then use width of SFP to set new `transform: translateX()` value,
                // in order to trigger animated transition
                self.el.style.right = '100%';
                self.translateX = self.width;
              }
            });

            // Otherwise, `position` either wasn't provided, or wasn't changed,
            // so there's no need to first close SFP
          } else {
            // SFP's current `[data-display]` is still either 'show' or 'open' however,
            // so it's either already in the process of opening, or just already open,
            // so clear any outside reference to `resolve`, and just `resolve` immediatley
            self._resolve = undefined;
            resolve();
          }
          return;

          // Else, SFP is either hidden (`[data-display]` is set to `''`),
          // or it's in the proccess of hiding (`[data-display]` is set to `'hide'`),
          // If it's also a "cover" type
        } else if (self.cover) {
          // Check to see if a `position` param was provided, and if one was,
          // use it to update SFP's current `position` value before doing anything to start opening panel
          if (options.position) self.position = options.position;

          // Check to see if underlay was disabled or not,
          // and verify that this "cover" SFP is not also a "docked" "cover" SFP
          if (options.underlay === true || options.underlay === undefined && !self.el.classList.contains('spark-panel--docked')) {
            // If underlay not disabled, and SFP isn't "docked",
            // configure underlay for use with SFP, then show it
            self.underlay.configure({
              disabled: false,
              style: 'dark'
            }).then(self.underlay.show);
          }

          // If not a "docked" "cover" SFP
          if (!self.dock) {
            // Clear any existing values for CSS position properties `left` & `right`
            self.el.style.left = '';
            self.el.style.right = '';

            // If SFP's current is set to `right`
            if (self.position === 'right') {
              // Set `transform: translateX()` to the current width of the SFP,
              // in order to trigger an animated transition where the entire SFP slides onto the screen
              // (Also, make it a negative value, so that it slides from right -> left)
              self.translateX = -self.width;
            } else if (self.position === 'left') {
              // Set `transform: translateX()` to the current width of the SFP,
              // in order to trigger an animated transition where the entire SFP slides onto the screen
              // (Using a positive value, so that it slides from left -> right)
              self.translateX = self.width;
            }
          }

          // If "cover" SFP _is_ "docked", then CSS position values `left` and `right` need to be updated,
          // but the current `width`` of the `dock` needs to be factored in so that as the panel slides onto
          // the screen, instead of sliding to the edge of the screen, it slides to the inner edge of the dock
          if (self.dock) {
            // If current `position` is "right"
            if (self.position === 'right') {
              // Use CSS position value `left` with `calc()`, `100%` (viewport width units),
              // and the current `dock` `width`, to position SFP directly below it's dock, on the inner edge
              self.el.style.left = 'calc(100% - ' + self.dock.width + 'px)';

              // Make sure any previous values set to CSS position `right` are cleared,
              // for our `left` adjustments to work properly
              self.el.style.right = '';

              // Trigger the transition on screen by adjusting the `transform: translateX()` value,
              // to the `width`` of the SFP (With a negative value, so that it slides from right -> left)
              self.translateX = -self.width;

              // Else, if the current `position` is "left"
            } else if (self.position === 'left') {
              // Make sure any previous values set to CSS position `left` are cleared,
              // for our `right` adjustments to work properly
              self.el.style.left = '';

              // Use CSS position value `right` with `calc()`, `100%` (viewport width units),
              // and the current `dock` `width`, to position SFP directly below it's dock, on the inner edge
              self.el.style.right = 'calc(100% - ' + self.dock.width + 'px)';

              // Trigger the transition on screen by adjusting the `transform: translateX()` value,
              // to the `width`` of the SFP (Using a positive value, so that it slides from left -> right)
              self.translateX = self.width;
            }
          }

          // Explicitly set the `[data-display]` value to "show", so that after the transition has ended,
          // the `onTransitionEnd` callback will be able to determine whether or not,
          // the panel just finished "opening" or "closing", so that it may clean up properly
          self.display = 'show';
        }

        // If SFP is "push" type, the only thing we have to adjust in order to trigger an animated transition,
        // is to change the value of `[data-display]`
        //
        // If `[data-display]` is currently "show" or "open", then the panel is either already open,
        // or in the process of opening
        if (self.push && self.display === 'show' || self.display === 'open') {
          if (window.innerWidth <= _this3.condensedBreakpoint && _this3.condensedPanel) {
            self.close().then(function () {
              self.condensedPanel.el.appendChild(self.el.firstElementChild);
              self.condensedPanel.open({
                underlay: false
              }).then(function () {
                if (self.condensedPanel.el.querySelector('.spark-panel--fixed__close')) {
                  self.condensedPanel.el.querySelector('.spark-panel--fixed__close').focus();
                }
                if (typeof self._resolve === 'function') {
                  self._resolve();
                  self._resolve = undefined;
                }
              }).catch(function () {
                self.display = '';
                self.condensedPanel.display = 'open';
              });
            }).catch(function () {
              self.display = '';
              self._onClose();
            });
          } else {
            // So snap the panel closed, in order to get to a state which we can "open" the panel _again_
            self.display = '';

            // Then set `[data-display]` to "show", in order to animate the panel open again
            self.display = 'show';
          }

          // Else, if still  a "push" type but not already open or opening
        } else if (self.push) {
          if (window.innerWidth <= _this3.condensedBreakpoint && _this3.condensedPanel) {
            self.condensedPanel.el.appendChild(self.el.firstElementChild);
            self.condensedPanel.open({
              underlay: false
            }).then(function () {
              if (self.condensedPanel.el.querySelector('.spark-panel--fixed__close')) {
                self.condensedPanel.el.querySelector('.spark-panel--fixed__close').focus();
              }
              self._resolve();
              self._resolve = undefined;
            });
          } else {
            // Then trigger the panel's animated "open" transition, by changing `[data-display]` from '' or 'hide' to 'show'
            self.display = 'show';
          }
        }
      });
    }

    /**
     * Close Panel
     * @return {Promise}
     * @public
     */
  }, {
    key: "close",
    value: function close() {
      var self = this;
      if (this.cover && !this.el.classList.contains('spark-panel--docked') && !this.dock) this.el.style[this.position] = '-'.concat(this.width, 'px');

      // Resolves on the complete end of the transition event triggered by adjusting `transform: translateX()`
      // [data-display] values control transitions, 'open' and '' are anchors and transitionless,
      // while 'show' and 'hide' will move between 'open' & '', and trigger transition events
      return new _promise.default(function (resolve) {
        // If "cover" type, but no current value for `[data-display]`,
        // then display is '', and the panel is already closed
        if (self.cover && !self.display) {
          // So `resolve()` promise immediately, and `return` out of `close()` function
          resolve();
          return;
        }

        // If we're still in the method, store an external reference to this promise's `resolve` method
        self._resolve = resolve;

        // If panel has an underlay, hide it
        if (self.underlay.active) self.underlay.hide();

        // If "cover" type and "docked"
        if (self.cover && self.dock) {
          // Clear value for `transform: translateX()`, triggering a transition
          self.translateX = 0;

          // Else, if "cover" type but not "docked"
        } else if (self.cover) {
          // Clear CSS position values for `left` and `right`,
          // so that we don't have clear them below
          self.el.style.left = '';
          self.el.style.right = '';

          // If the current `position` is "right"
          if (self.position === 'right') {
            // Then the CSS position `left` property needs to be set to `100%` (viewport width units),
            // so that when the panel transitions, it ends up off screen to the right
            self.el.style.left = '100%';

            // Now that `left` and `right` are properly set, set `transform: translateX()`,
            // (which should currently be set either to a positive or negative value, equal to the width of the panel in px),
            // to trigger the animated "closing" transition
            self.translateX = 0;
          } else if (self.position === 'left') {
            // Then the CSS position `right` property needs to be set to `100%` (viewport width units),
            // so that when the panel transitions, it ends up off screen to the left
            self.el.style.right = '100%';

            // Now that `left` and `right` are properly set, set `transform: translateX()`,
            // (which should currently be set either to a positive or negative value, equal to the width of the panel in px),
            // to trigger the animated "closing" transition
            self.translateX = 0;
          }
        }

        // Change `[data-display]` value to "hide",
        // so that `onTransitionEnd()` will be able to determine that the panel just finished "closing",
        // and to trigger the animated closing transition if panel is a "push" type
        self.display = 'hide';
      });
    }

    /**
     * Update the component to use a new element or reparse from
     * the existing element.
     * @param {Element} el Optional
     * @param {Object} params Optional
     * @public
     */
  }, {
    key: "update",
    value: function update(el) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this._removeEventListeners();
      this._cacheElements.call(this, el || this.el, params);
      this._addEventListeners();
      if (params.position) this.position = params.position;
      return this;
    }
  }]);
  return SideFixedPanel;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
SideFixedPanel.prototype._whitelistedParams = ['_parentPanel', 'condensedBreakpoint', 'mobileBreakpoint', 'scrollTop', 'onDismiss', 'onToggle', 'onOpen', 'onClose'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
SideFixedPanel.prototype.defaults = {
  _parentPanel: null,
  el: null,
  scrollTop: true,
  mobileBreakpoint: 'xs',
  condensedBreakpoint: '823',
  onDismiss: function onDismiss() {},
  onToggle: function onToggle() {},
  onOpen: function onOpen() {},
  onClose: function onClose() {}
};
(0, _mixin.default)(SideFixedPanel.prototype, _events.default);
var _default = SideFixedPanel;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/breakpoint":60,"../helpers/traversal/get-parent":87,"../helpers/util/mixin":96,"../mixins/events":103,"./base":3,"./side-fixed-dock":35,"./underlay":51,"@babel/runtime-corejs3/core-js-stable/instance/concat":108,"@babel/runtime-corejs3/core-js-stable/instance/includes":112,"@babel/runtime-corejs3/core-js-stable/instance/slice":115,"@babel/runtime-corejs3/core-js-stable/number/is-integer":120,"@babel/runtime-corejs3/core-js-stable/promise":124,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],37:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _offset = _interopRequireDefault(require("../helpers/dom/offset"));
var _hasParent = _interopRequireDefault(require("../helpers/traversal/has-parent"));
var _messaging = _interopRequireDefault(require("../mixins/messaging"));
var _mixin = _interopRequireDefault(require("../helpers/util/mixin"));
var _validation = _interopRequireDefault(require("../mixins/validation"));
var _makeElement = _interopRequireDefault(require("../helpers/dom/make-element"));
var _modulo = _interopRequireDefault(require("../helpers/util/modulo"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Slider
                                                                                                                                                                                                                                                                                                                                              * A slider for number inputs.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Slider(el, {
                                                                                                                                                                                                                                                                                                                                              *   // Optional. Slide along the x or y-axis?
                                                                                                                                                                                                                                                                                                                                              *   isX: true,
                                                                                                                                                                                                                                                                                                                                              *   // onChange callback
                                                                                                                                                                                                                                                                                                                                              *   onChange: function(inst, val){},
                                                                                                                                                                                                                                                                                                                                              * });
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/slider.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var Slider = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(Slider, _BaseComponent);
  var _super = _createSuper(Slider);
  /**
   * Slider constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function Slider(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Slider);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Start the slider moving.
   * @param {Number} position The position of the pointer.
   * @param {String} type Optional Which type of events to listen for.
   */
  (0, _createClass2.default)(Slider, [{
    key: "start",
    value: function start(position, type) {
      if (this.inputEl.getAttribute('disabled') !== null) {
        return this;
      }
      this._addMoveEventListeners(type || 'mouse');
      this._cacheSize();
      this.isActive = true;
      this._updateActiveClasses();
      this._oldVal = this.value;
      this.move(position);
      return this;
    }

    /**
     * Move the value to a given position
     * @param {Number} position
     * @param {Boolean} force Force the move Optional
     */
  }, {
    key: "move",
    value: function move(position, force) {
      // Noop if we haven't yet started dragging
      if ((!position || !this.isActive) && !force) {
        return this;
      }

      // Treat positions beyond the boundaries as the boundaries
      if (this.isX) {
        if (position < this.offsetLeft) {
          // Too far left
          position = this.offsetLeft;
        } else if (position > this.offsetLeft + this.width) {
          // Too far right
          position = this.offsetLeft + this.width;
        }
      } else {
        if (position < this.offsetTop) {
          // Too far top
          position = this.offsetTop;
        } else if (position > this.offsetTop + this.height) {
          // Too far bottom
          position = this.offsetTop + this.height;
        }
      }

      // The percentage of the new position relative to slider-container width or height.
      var percentage = this.isX ? (position - this.offsetLeft) / (this.width - this.handleSize) : (position - this.offsetTop) / this.height;
      percentage = Math.round(percentage * this.percentagePrecision) / this.percentagePrecision;

      // The value of the input as a percentage of the value range.
      var calcValue = (percentage - this.handleSizePercentage / 2) * (this.max - this.min) + this.min;
      return this.setValue(calcValue);
    }

    /**
     * Stop listening to movements.
     * @param {String} type Optional Which type of events to listen for.
     */
  }, {
    key: "stop",
    value: function stop(type) {
      this.isActive = false;
      if (this._oldVal !== this.value) {
        (this.onChange || noop)(this.value, this);
      }
      this._updateActiveClasses();
      this._removeMoveEventListeners(type || 'mouse');
      return this;
    }

    /**
     * Set the value of the handle.
     * @param {Number} value
     */
  }, {
    key: "setValue",
    value: function setValue(value) {
      // Move in increments if we have a defined step size
      if (this.step) {
        value = value - (0, _modulo.default)(value, this.step);
      }
      value = Math.round(value * this.valuePrecision) / this.valuePrecision;

      // Check bounds of the new value
      if (value > this.max) {
        value = this.max;
      } else if (value < this.min) {
        value = this.min;
      }

      // If there is an onWillChange callback, run it. If it returns
      // false, then this new value should be considered invalid.
      if (typeof this.onWillChange === 'function') {
        var change = this.onWillChange(value, this);
        if (typeof change === 'number') {
          value = change;
        }
      }

      // Store value
      this.value = value;

      // Update elements
      this.inputEl.value = this.value;
      this.handleEl.setAttribute('data-value', this._truncateValueText(this.value));
      this.handleEl.setAttribute('aria-valuenow', this._truncateValueText(this.value));
      this.handleEl.setAttribute('aria-valuetext', this._truncateValueText(this.value));

      // Set the percentage
      this.percentage = (this.value - this.min) / (this.max - this.min);

      // Update the position of the handle
      this._updateHandlePosition();
      return this;
    }

    /**
     * Get the value.
     * @return {Number}
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return this.value;
    }

    /**
     * Clear the value.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      return this.setValue(0);
    }

    /**
     * Set/reset error state
     * @param {Boolean} true: set error state, false: reset
     */
  }, {
    key: "setErrorState",
    value: function setErrorState(opt) {
      if (opt) {
        this.el.setAttribute('data-error', '');
      } else {
        this.el.removeAttribute('data-error');
      }
    }

    /**
     * Enable the input.
     */
  }, {
    key: "enable",
    value: function enable() {
      this.inputEl.removeAttribute('disabled');
      this.inputEl.removeAttribute('tabindex');
      this.handleEl.removeAttribute('disabled');
      this.handleEl.removeAttribute('tabindex');
      return this;
    }

    /**
     * Disable the input.
     */
  }, {
    key: "disable",
    value: function disable() {
      this.inputEl.setAttribute('disabled', '');
      this.inputEl.setAttribute('tabindex', '-1');
      this.handleEl.setAttribute('disabled', '');
      this.handleEl.setAttribute('tabindex', '-1');
      return this;
    }

    /**
     * Increment the value by the step size.
     * @param {Boolean} useMultiplier Optional Increment by a multiplied version of the step
     */
  }, {
    key: "increment",
    value: function increment(useMultiplier) {
      return this.setValue(this.value + this.step * (useMultiplier ? 10 : 1));
    }

    /**
     * Decrement the value by the step size.
     * @param {Boolean} useMultiplier Optional Increment by a multiplied version of the step
     */
  }, {
    key: "decrement",
    value: function decrement(useMultiplier) {
      return this.setValue(this.value - this.step * (useMultiplier ? 10 : 1));
    }

    /**
     * Remove the element from the DOM and prepare for garbage collection by dereferencing values.
     * @param {Boolean} leaveElement Leave the element intact.
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      this._removeMoveEventListeners('touch');
      this._removeMoveEventListeners('mouse');
      this._removeMoveEventListeners('keyboard');
      return (0, _get2.default)((0, _getPrototypeOf2.default)(Slider.prototype), "remove", this).call(this, leaveElement);
    }

    /**
     * Update the component to use a new element or reparse from
     * the existing element.
     * @param {Element} el Optional
     */
  }, {
    key: "update",
    value: function update(el) {
      this._removeEventListeners();
      this._removeMoveEventListeners('touch');
      this._removeMoveEventListeners('mouse');
      this._removeMoveEventListeners('keyboard');
      this._cacheElements(el);
      this._addEventListeners();
      this._updateHandlePosition();
      return this;
    }

    /**
     * Store a reference to the whole slider, as well as the
     * input element. Also, get some default values from the input
     * element (min, max, steps).
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.controlsEl = this.el.querySelector('.spark-slider__controls');
      this.inputEl = this.el.querySelector('input[type="number"]');
      this.handleEl = this.el.querySelector('.spark-slider__handle');
      this.trackEl = this.el.querySelector('.spark-slider__track');
      this.trackFillEl = this.trackEl.querySelector('.spark-slider__track-fill');
      this.messageEl = this.el.querySelector('.spark-slider__message') || (0, _makeElement.default)('<span class="spark-slider__message"></span>');
      if (!this.inputEl) {
        throw new Error('Tried to create a slider instance without a number input.');
      }
      if (!this.handleEl) {
        throw new Error('Tried to create a slider instance without a handle button.');
      }
      this.min = parseFloat(this.inputEl.getAttribute('min')) || this.min;
      this.max = parseFloat(this.inputEl.getAttribute('max')) || this.max;
      this.step = parseFloat(this.inputEl.getAttribute('step')) || this.step;

      // Default precision for Integers
      this.valuePrecision = 1;

      // If the steps value is a Float instead of a Integer update the precision for the value
      if (this.inputEl.getAttribute('step') && this.inputEl.getAttribute('step').split('.')[1]) {
        this.valuePrecision = Math.pow(10, this.inputEl.getAttribute('step').split('.')[1].length);
      }

      // Need a more precise percentage if the value is more precise.
      this.percentagePrecision = this.valuePrecision > 100 ? this.valuePrecision : 100;

      // If we have a default value, set it after we cache the size of the element.
      // We have to do that first so we know the bounds of the slider.
      var value = parseFloat(this.inputEl.getAttribute('value')) || parseFloat(this.inputEl.getAttribute('min'));
      if (!isNaN(value)) {
        this._cacheSize();
        this.setValue(value);
      }
    }

    /**
     * Save the element dimensions.
     */
  }, {
    key: "_cacheSize",
    value: function _cacheSize() {
      this.width = this.trackEl.offsetWidth;
      this.height = this.trackEl.offsetHeight;
      this.handleSize = this.isX ? this.handleEl.offsetWidth : this.handleEl.offsetHeight;
      this.handleSizePercentage = this.isX ? this.handleEl.offsetWidth / this.width : this.handleEl.offsetHeight / this.height;
      var offset = (0, _offset.default)(this.controlsEl);
      this.offsetLeft = offset.left;
      this.offsetTop = offset.top;
    }

    /**
     * Set the position of the handle.
     */
  }, {
    key: "_updateHandlePosition",
    value: function _updateHandlePosition() {
      // Track and Track-Fill elements
      var trackPercentage = Math.min(this.percentage, 1) * 100;
      this.trackEl.setAttribute('data-percentage', trackPercentage);
      this.trackFillEl.setAttribute('style', 'width: ' + trackPercentage + '%;');

      // Handle position
      var handlePos = this.handleSize / 2 + (this.value - this.min) * ((this.width - this.handleSize) / (this.max - this.min));
      var handlePosPercentage = handlePos / this.width * 100;
      this.handleEl.setAttribute('style', 'left: ' + handlePosPercentage + '%;');
    }

    /**
     * Update the active class on the handle.
     */
  }, {
    key: "_updateActiveClasses",
    value: function _updateActiveClasses() {
      (0, _toggleClass.default)(this.handleEl, 'active', this.isActive);
      (0, _toggleClass.default)(this.el, 'active', this.isActive);
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onTouchStartBound = this._onTouchStart.bind(this);
      this._onTouchMoveBound = this._onTouchMove.bind(this);
      this._onTouchEndBound = this._onTouchEnd.bind(this);
      this._onClickBound = this._onClick.bind(this);
      this._onMouseDownBound = this._onMouseDown.bind(this);
      this._onMouseMoveBound = this._onMouseMove.bind(this);
      this._onMouseUpBound = this._onMouseUp.bind(this);
      this._onMouseOutBound = this._onMouseOut.bind(this);
      this._onFocusBound = this._onFocus.bind(this);
      this._onKeydownBound = this._onKeydown.bind(this);
      this._onBlurBound = this._onBlur.bind(this);
      this._onChangeBound = this._onChange.bind(this);
      this._onResizeBound = this._onResize.bind(this);
      this._onVisibleChildrenBound = this._onVisibleChildren.bind(this);
    }

    /**
     * Add event listeners for touchstart and mouse click.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.controlsEl.addEventListener('touchstart', this._onTouchStartBound);
      this.controlsEl.addEventListener('mousedown', this._onMouseDownBound);
      this.inputEl.addEventListener('change', this._onChangeBound);
      this.handleEl.addEventListener('focus', this._onFocusBound);
      this.handleEl.addEventListener('click', this._onClickBound);
      window.addEventListener('resize', this._onResizeBound);
      window.addEventListener('orientationchange', this._onResizeBound);
      document.addEventListener('spark.visible-children', this._onVisibleChildrenBound, true);
    }

    /**
     * Remove event listeners for touchstart and mouse click.
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.controlsEl.removeEventListener('touchstart', this._onTouchStartBound);
      this.controlsEl.removeEventListener('mousedown', this._onMouseDownBound);
      this.inputEl.removeEventListener('change', this._onChangeBound);
      this.handleEl.removeEventListener('focus', this._onFocusBound);
      this.handleEl.removeEventListener('click', this._onClickBound);
      window.removeEventListener('resize', this._onResizeBound);
      window.removeEventListener('orientationchange', this._onResizeBound);
      document.removeEventListener('spark.visible-children', this._onVisibleChildrenBound);
    }

    /**
     * Add event listeners for touchmove, touchend, mousemove and mouseup.
     * We add these to the window so that the user can move off of the element
     * but keep dragging the slider handle. Otherwise it's really hard to
     * use the slider unless it's massive.
     * @param {String} type Which type of listeners to add
     */
  }, {
    key: "_addMoveEventListeners",
    value: function _addMoveEventListeners(type) {
      // Only listen for events of the type we asked for.
      switch (type) {
        case 'mouse':
          window.addEventListener('mousemove', this._onMouseMoveBound);
          window.addEventListener('mouseout', this._onMouseOutBound);
          window.addEventListener('mouseup', this._onMouseUpBound);
          break;
        case 'touch':
          window.addEventListener('touchmove', this._onTouchMoveBound);
          window.addEventListener('touchend', this._onTouchEndBound);
          break;
        case 'keyboard':
          window.addEventListener('keydown', this._onKeydownBound);
          this.handleEl.addEventListener('blur', this._onBlurBound);
          break;
      }
    }

    /**
     * Remove event listeners for move events.
     * @param {String} type Which type of listeners to remove
     */
  }, {
    key: "_removeMoveEventListeners",
    value: function _removeMoveEventListeners(type) {
      // Only unbind events of the type we asked for.
      switch (type) {
        case 'mouse':
          window.removeEventListener('mousemove', this._onMouseMoveBound);
          window.removeEventListener('mouseup', this._onMouseUpBound);
          break;
        case 'touch':
          window.removeEventListener('touchmove', this._onTouchMoveBound);
          window.removeEventListener('touchend', this._onTouchEndBound);
          break;
        case 'keyboard':
          window.removeEventListener('keydown', this._onKeydownBound);
          this.handleEl.removeEventListener('blur', this._onBlurBound);
          break;
      }
    }

    /**
     * Truncate value text to fit.
     * @param {String} value
     * @return {String}
     */
  }, {
    key: "_truncateValueText",
    value: function _truncateValueText(value, precision, characters) {
      if (value.length < 5) {
        return value;
      }
      var isNegative = value < 0 ? true : false;
      value = Math.abs(value);
      precision = precision || this.truncatePrecision;
      characters = characters || this.truncateCharacters;
      var i = characters.length - 1;
      precision = Math.pow(10, precision);
      for (i; i >= 0; i--) {
        var size = Math.pow(10, (i + 1) * 3);
        if (size <= value) {
          value = value * precision / size / precision;

          // @todo: what is this doing? i can't remember how we would ever
          // end up inside this condition.
          if (value === 1000 && i < characters.length - 1) {
            value = 1;
            i++;
          }
          value += characters[i];
          break;
        }
      }
      return (isNegative ? '-' : '') + value;
    }

    /**
     * When the touch starts, start the slider.
     * @param {Object} e
     */
  }, {
    key: "_onTouchStart",
    value: function _onTouchStart(e) {
      if (this.inputEl.getAttribute('disabled') !== null) {
        return;
      }
      e.preventDefault();
      this.start(this.isX ? e.touches[0].pageX : e.touches[0].pageY, 'touch');
    }

    /**
     * When the window fires a touchmove event, adjust our value accordingly
     * @param {Object} e
     */
  }, {
    key: "_onTouchMove",
    value: function _onTouchMove(e) {
      if (!this.isActive) {
        return;
      }
      e.preventDefault();
      this.move(this.isX ? e.touches[0].pageX : e.touches[0].pageY);
    }

    /**
     * When the window fires a touchend event, stop tracking touches
     * @param {Object} e
     */
  }, {
    key: "_onTouchEnd",
    value: function _onTouchEnd(e) {
      if (!this.isActive) {
        return;
      }
      e.preventDefault();
      this.stop('touch');
    }

    /**
     * When the mouse presses down, start the slider.
     * @param {Object} e
     */
  }, {
    key: "_onMouseDown",
    value: function _onMouseDown(e) {
      if (this.inputEl.getAttribute('disabled') !== null) {
        return;
      }
      this.start(this.isX ? e.pageX : e.pageY, 'mouse');
    }

    /**
     * When the window fires a mousemove event, adjust our value accordingly
     * @param {Object} e
     */
  }, {
    key: "_onMouseMove",
    value: function _onMouseMove(e) {
      if (!this.isActive) {
        return;
      }
      e.preventDefault();
      this.move(this.isX ? e.pageX : e.pageY);
    }

    /**
     * When the window fires a mouseup event, stop tracking
     * @param {Object} e
     */
  }, {
    key: "_onMouseUp",
    value: function _onMouseUp() {
      if (!this.isActive) {
        return;
      }
      this.stop('mouse');
    }

    /**
     * When the window fires a mouseout event, stop tracking if it was the html element.
     * @param {Object} e
     */
  }, {
    key: "_onMouseOut",
    value: function _onMouseOut() {

      // @todo: make this work
      // if (e.relatedTarget === doc.body.parentNode) {
      //   this.stop('mouse');
      // }
    }

    /**
     * Handle the spark.visible-children event
     * @param {Object} e
     */
  }, {
    key: "_onVisibleChildren",
    value: function _onVisibleChildren(e) {
      if (e.target.contains(this.el)) {
        window.setTimeout(function () {
          this._onResize();
        }.bind(this), 0);
      }
    }

    /**
     * When the window resizes, cache size values for the slider.
     * @param {Object} e
     */
  }, {
    key: "_onResize",
    value: function _onResize() {
      this._cacheSize();
      this._updateHandlePosition();
    }

    /**
     * When the element receives focus, start listening for keyboard events
     * @param {Object} e
     */
  }, {
    key: "_onFocus",
    value: function _onFocus() {
      this.start(null, 'keyboard');
    }

    /**
     * When a key is pressed, see if it's one of the Arrow, Page up, Page down, Home
     * or End keys move the handle accordingly. If the shift key is pressed in combination
     * with the arrow keys, we'll increment and decrement by bigger values.
     * @param {Object} e
     */
  }, {
    key: "_onKeydown",
    value: function _onKeydown(e) {
      if (e.keyCode === 39 || e.keyCode === 38) {
        // Right or Up arrow
        this.increment(e.shiftKey);
      } else if (e.keyCode === 37 || e.keyCode === 40) {
        // Left or down arrow
        this.decrement(e.shiftKey);
      } else if (e.keyCode === 33) {
        // Page Up
        this.increment(true);
      } else if (e.keyCode === 34) {
        // Page Down
        this.decrement(true);
      } else if (e.keyCode === 35) {
        // End
        this.setValue(this.max);
      } else if (e.keyCode === 36) {
        // Home
        this.setValue(this.min);
      }
    }

    /**
     * When the element loses focus, stop listening for keyboard events
     * @param {Object} e
     */
  }, {
    key: "_onBlur",
    value: function _onBlur() {
      this.stop('keyboard');
    }

    /**
     * When the input value changes, set our internal value if it's not already our value.
     * @param {Object} e
     */
  }, {
    key: "_onChange",
    value: function _onChange(e) {
      if (e.target.value !== this.value) {
        this.setValue(e.target.value);
      }
      (this.onChange || noop)(this.value, this);
    }

    /**
     * Prevent click events on the button. This way we don't accidentally submit the form.
     * @param {Object} e
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      e.preventDefault();
    }

    /**
     * When the window is clicked and the element isn't part of the slider, trigger a blur.
     * @param {Object} e
     */
  }, {
    key: "_onWindowClick",
    value: function _onWindowClick(e) {
      if ((0, _hasParent.default)(e.target, this.el)) {
        this._onBlur();
      }
    }
  }]);
  return Slider;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
Slider.prototype._whitelistedParams = ['isX', 'validate', 'onValidate', 'onChange', 'onWillChange'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
Slider.prototype.defaults = {
  el: null,
  messageEl: null,
  controlsEl: null,
  inputEl: null,
  handleEl: null,
  trackEl: null,
  trackFillEl: null,
  isActive: false,
  isX: true,
  onValidate: null,
  onChange: null,
  onWillChange: null,
  position: 0,
  width: 0,
  height: 0,
  min: 0,
  max: 0,
  step: 1,
  value: 0,
  percentage: 0,
  offsetLeft: 0,
  offsetTop: 0,
  handleSizePercentage: 0,
  truncatePrecision: 0,
  truncateCharacters: ['k', 'm', 'b', 't'],
  _oldVal: null,
  _onTouchStartBound: null,
  _onTouchMoveBound: null,
  _onTouchEndBound: null,
  _onMouseDownBound: null,
  _onMouseMoveBound: null,
  _onMouseUpBound: null,
  _onMouseOutBound: null,
  _onFocusBound: null,
  _onKeydownBound: null,
  _onBlurBound: null,
  _onChangeBound: null,
  _onResizeBound: null,
  _onClickBound: null,
  _onVisibleChildrenBound: null
};
(0, _mixin.default)(Slider.prototype, _messaging.default, _validation.default);
var _default = Slider;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/make-element":62,"../helpers/dom/offset":63,"../helpers/dom/toggle-class":68,"../helpers/traversal/has-parent":91,"../helpers/util/mixin":96,"../helpers/util/modulo":97,"../mixins/messaging":104,"../mixins/validation":105,"./base":3,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],38:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));
var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/toConsumableArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _getParent = _interopRequireDefault(require("../helpers/traversal/get-parent"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Step Indicator
                                                                                                                                                                                                                                                                                                                                              * Set of indicators represent different steps
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new StepIndicator(el, params);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/step-indicator.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var StepIndicator = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(StepIndicator, _BaseComponent);
  var _super = _createSuper(StepIndicator);
  /**
   * StepIndicator constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function StepIndicator(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, StepIndicator);
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    _this._calculateStyle();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Update the component to use a new element or reparse from
   * the existing element.
   * @param {Element} el Optional
   * @return {Object} this
   */
  (0, _createClass2.default)(StepIndicator, [{
    key: "update",
    value: function update(el) {
      this._removeEventListeners();
      this._cacheElements(el || this.el);
      this._parseParams();
      this._addEventListeners();
      this._calculateStyle();
      return this;
    }

    /**
     * Store a reference to the element.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.containerEl = this.containerEl || el.parentNode;
      this._body = this.el.querySelector('.spark-step-indicator__body');
      this._list = this.el.querySelector('.spark-step-indicator__list');
      this._items = this._list.querySelectorAll('.spark-step-indicator__item');
      this._checkPadding();
      this.parseFocusableElements();
    }

    /**
     * Parse parameters from the element.
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      this.type = this.type !== null ? this.type : this.el.attributes['data-type'] && this.el.attributes['data-type'].value;

      // Create workaround for Firefox behavior: https://bugzilla.mozilla.org/show_bug.cgi?id=1069739
      if (this.type === 'dropdown' || this.type === 'standard-dropdown') {
        this._list.setAttribute('tabindex', '-1');
      }
      if (this.el.attributes['data-dropdownlabel'] && this.el.attributes['data-dropdownlabel'].value) {
        this.dropdownLabel = this.el.attributes['data-dropdownlabel'].value;
      }
      if (this.el.attributes['data-stepprogressionlabel'] && this.el.attributes['data-stepprogressionlabel'].value) {
        this.stepProgressionLabel = this.el.attributes['data-stepprogressionlabel'].value;
      }
      if (this.el.attributes['data-currentlabel'] && this.el.attributes['data-currentlabel'].value) {
        this.currentLabel = this.el.attributes['data-currentlabel'].value;
      }
      if (this.el.attributes['data-completedlabel'] && this.el.attributes['data-completedlabel'].value) {
        this.completedLabel = this.el.attributes['data-completedlabel'].value;
      }
    }

    /**
     * Get all the elements within the Modal that can be focused on
     */
  }, {
    key: "parseFocusableElements",
    value: function parseFocusableElements() {
      var stepIndicatorFocusableEls = this._list.querySelectorAll('a[href]:not([tabindex="-1"]), button:not([disabled]), [tabindex="0"]');
      if (stepIndicatorFocusableEls.length > 0) {
        this.focusableElements = (0, _slice.default)(Array.prototype).call(stepIndicatorFocusableEls);
        this.firstStepIndicatorFocusableEl = this.focusableElements[0];
        this.lastStepIndicatorFocusableEl = this.focusableElements[this.focusableElements.length - 1];
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onResizeBound = this._onResize.bind(this);
      this._onVisibleBound = this._onVisible.bind(this);
      this._toggleDropdownBound = this._toggleDropdown.bind(this);
      this._onKeydownBound = this._onKeydown.bind(this);
      this._onKeyupBound = this._onKeyup.bind(this);
      if (typeof this.onStepClick === 'function') {
        var _context;
        this.bindStepClickCallback((0, _map.default)(_context = (0, _toConsumableArray2.default)(new Array(this._items.length))).call(_context, function (item, index) {
          return index;
        }), this.onStepClick);
      }
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      window.addEventListener('resize', this._onResizeBound);
      document.addEventListener('spark.visible-children', this._onVisibleBound, true);
      this.el.addEventListener('keydown', this._onKeydownBound);
      this.el.addEventListener('keyup', this._onKeyupBound);
      document.addEventListener('spark.step-indicator', this._toggleDropdownBound, true);
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      window.removeEventListener('resize', this._onResizeBound);
      document.removeEventListener('spark.visible-children', this._onVisibleBound, true);
      document.removeEventListener('click', this._toggleDropdownBound);
      this.el.removeEventListener('keydown', this._onKeydownBound);
      document.removeEventListener('spark.step-indicator', this._toggleDropdownBound, true);
      if (typeof this.onStepClick === 'function') {
        var _context2;
        this.removeStepClickCallback((0, _map.default)(_context2 = (0, _toConsumableArray2.default)(new Array(this._items.length))).call(_context2, function (item, index) {
          return index;
        }), this.onStepClick);
      }
    }

    /**
     * Change selected step state into incomplete
     * @param {Int} index of selected step
     */
  }, {
    key: "_resetStepState",
    value: function _resetStepState(stepIndex) {
      if (stepIndex < 0 || stepIndex >= this._items.length) {
        return;
      }
      var stepIcon = this._items[stepIndex].querySelector('.spark-step-indicator__icon');
      (0, _removeClass.default)(this._items[stepIndex], ['spark-step-indicator__item--completed', 'spark-step-indicator__item--current', 'spark-step-indicator__item--disabled']);
      this._items[stepIndex].removeAttribute('tabindex');
      stepIcon.setAttribute('aria-hidden', true);
      stepIcon.removeAttribute('aria-label');
    }

    /**
     * Set selected step state: completed/current/disabled/incomplete
     * For current step, will remove current step from other steps
     * @param {Int} index of selected step
     * @param {String} state to be set
     * @return {Object} this
     */
  }, {
    key: "setStepState",
    value: function setStepState(stepIndex, state) {
      if (stepIndex < 0 || stepIndex >= this._items.length) {
        return this;
      }
      var stepIcon = this._items[stepIndex].querySelector('.spark-step-indicator__icon');
      var currentStep, currentIcon;
      switch (state) {
        case 'completed':
          this._resetStepState(stepIndex);
          (0, _addClass.default)(this._items[stepIndex], 'spark-step-indicator__item--completed');
          stepIcon.removeAttribute('aria-hidden');
          stepIcon.setAttribute('aria-label', this.completedLabel);
          break;
        case 'current':
          currentStep = this._list.querySelector('.spark-step-indicator__item--current');
          currentIcon = currentStep.querySelector('.spark-step-indicator__icon');
          (0, _removeClass.default)(currentStep, 'spark-step-indicator__item--current');
          if ((0, _hasClass.default)(currentStep, 'spark-step-indicator__item--completed')) {
            currentIcon.setAttribute('aria-label', this.completedLabel);
          } else {
            currentIcon.setAttribute('aria-hidden', true);
            currentIcon.removeAttribute('aria-label');
          }
          (0, _addClass.default)(this._items[stepIndex], 'spark-step-indicator__item--current');
          stepIcon.removeAttribute('aria-hidden');
          if ((0, _hasClass.default)(this._items[stepIndex], 'spark-step-indicator__item--completed')) {
            stepIcon.setAttribute('aria-label', this.completedLabel + ', ' + this.currentLabel);
          } else {
            stepIcon.setAttribute('aria-label', this.currentLabel);
          }
          break;
        case 'disabled':
          this._resetStepState(stepIndex);
          (0, _addClass.default)(this._items[stepIndex], 'spark-step-indicator__item--disabled');
          this._items[stepIndex].setAttribute('tabindex', '-1');
          break;
        case 'incomplete':
          (0, _removeClass.default)(this._items[stepIndex], ['spark-step-indicator__item--completed', 'spark-step-indicator__item--disabled']);
          this._items[stepIndex].removeAttribute('tabindex');
          break;
      }
      this._calculateStyle();
      return this;
    }

    /**
     * When the Enter key is pressed toggle the dropdown or update the selection if in dropdown mode
     * When the Tab key is pressed, cycle through the list options
     * @param {Object} Reference of DOM obj
     * @param {Object} Event of click
     */
  }, {
    key: "_onKeydown",
    value: function _onKeydown(e) {
      if (!(0, _getParent.default)(e.target, '.spark-step-indicator__list', this.el) && !(0, _getParent.default)(e.target, '.spark-step-indicator__body--dropdown', this.el)) {
        return;
      }
      var code = e.keyCode || e.which;

      // Enter Key
      if (code === 13) {
        if ((0, _hasClass.default)(e.target, 'spark-step-indicator__item--dropdown__header')) {
          e.preventDefault();
          this._toggleDropdown(e);
        }
      }

      // Tab Key
      if (code === 9) {
        if (this._dropdownExpand) {
          if (this.focusableElements.length === 1) {
            e.preventDefault();
          }
          if (e.shiftKey) {
            this._onBackwardTab(e);
          } else {
            this._onForwardTab(e);
          }
        }
      }
    }

    /**
     * When the ESC key is pressed, close the Step Indicator dropdown list if it is open.
     * @param {Object} e
     */
  }, {
    key: "_onKeyup",
    value: function _onKeyup(e) {
      // ESC Key
      if (e.keyCode === 27 && this._dropdownExpand) {
        this._toggleDropdown(e);
      }
    }

    /**
     * When tabbing backwards, localize traversal to Step Indicator dropdown list elements only
     * @param {Object} e
     */
  }, {
    key: "_onBackwardTab",
    value: function _onBackwardTab(e) {
      if (document.activeElement === this.firstStepIndicatorFocusableEl) {
        e.preventDefault();
        this.lastStepIndicatorFocusableEl.focus();
      }
    }

    /**
     * When tabbing forwards, localize traversal to Step Indicator dropdown list elements only
     * @param {Object} e
     */
  }, {
    key: "_onForwardTab",
    value: function _onForwardTab(e) {
      if (document.activeElement === this.lastStepIndicatorFocusableEl) {
        e.preventDefault();
        this.firstStepIndicatorFocusableEl.focus();
      }
    }

    /**
     * Provide a method to bind click callback function to certain step.
     * @param {Array} a set of step indices represent the target of callback
     * @param {Function} callback function
     * @return {Object} this
     */
  }, {
    key: "bindStepClickCallback",
    value: function bindStepClickCallback(indexArr, callback) {
      callback = callback || noop;
      for (var i = 0; i < indexArr.length; i++) {
        this._items[indexArr[i]].addEventListener('click', callback.bind(this._items[indexArr[i]], indexArr[i], this));
      }
      return this;
    }

    /**
     * Remove click callback from steps
     * @param {Array} a set of step indices represent the target of callback
     * @param {Function} callback function
     * @return {Object} this
     *
     */
  }, {
    key: "removeStepClickCallback",
    value: function removeStepClickCallback(indexArr, callback) {
      callback = callback || noop;
      for (var i = 0; i < indexArr.length; i++) {
        this._items[indexArr[i]].removeEventListener('click', callback);
      }
      return this;
    }

    /**
     * Work for _calculateStyle.
     * Comparing the width of list and total items, including padding
     * @return {Boolean}
     */
  }, {
    key: "_isOverWidth",
    value: function _isOverWidth() {
      var listWidth = this._list.offsetWidth;
      var itemTotalWidth = this._listPaddingTotal;
      for (var i = 0; i < this._items.length; i++) {
        itemTotalWidth += this._items[i].offsetWidth;
      }
      if (listWidth < itemTotalWidth) {
        return true;
      }
      return false;
    }

    /**
     * Calcuate different style based settings
     */
  }, {
    key: "_calculateStyle",
    value: function _calculateStyle() {
      // Remove special DOM and Class of dropdown variation
      this._switchFromDropdown();
      switch (this.type) {
        case 'standard-dropdown':
          this._calculateRespStyle();
          break;
        case 'large':
          this._calculateLargeStyle();
          break;
        case 'condensed':
          this._calculateCondensedStyle();
          break;
        case 'dropdown':
          this._calculateDropdownStyle();
          break;
        default:
          this._calculateStandardStyle();
      }

      // Work for IE11, detect IE11 via userAgent
      // userAgent: Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv 11.0) like Gecko
      var isIE11 = !!(navigator.userAgent.match(/Trident/) && navigator.userAgent.match(/rv[ :]11/));
      if (isIE11) {
        this._addItemWidth();
      }
    }

    /**
     * For IE11 ONLY, Add width: 100% to work around IE11 bug
     * IE11 will have incorrect position with flex-grow max-width and justify-content when items hit max-width
     * Sometimes after calculating, even itemTotalWidth is less 1px than listWidth,
     * it also means items are fit in the list, not hit the max-width
     * So add 2px to list width when comparing to avoid this.
     */
  }, {
    key: "_addItemWidth",
    value: function _addItemWidth() {
      if (!(0, _hasClass.default)(this._list, 'spark-step-indicator__list--condensed') && !(0, _hasClass.default)(this._body, 'spark-step-indicator__body--dropdown')) {
        var listWidth = this._list.offsetWidth;
        var itemTotalWidth = this._listPaddingTotal;
        for (var i = 0; i < this._items.length; i++) {
          itemTotalWidth += this._items[i].offsetWidth;
        }
        if (listWidth - itemTotalWidth > 2) {
          this._switchWidthForIe11(0, true);
        } else {
          this._switchWidthForIe11(0, false);
        }
      } else {
        this._switchWidthForIe11(0, false);
      }
    }

    /**
     * Switch spark-step-indicator__item style width: 100% to work around IE11 bug
     * @param {Number} start index of step
     * @param {Boolean} whether add width: 100%
     */
  }, {
    key: "_switchWidthForIe11",
    value: function _switchWidthForIe11(index, val) {
      for (var i = index; i < this._items.length; i++) {
        this._items[i].style.width = val ? '100%' : '';
      }
    }

    /**
     * Fix on large variation
     * Calculate node and list length remove connect line of each end
     * Sometimes after calculating, even itemTotalWidth is bigger 1px than listWidth,
     * it also means items are fit in the list, not over width.
     * So add 2px to list width when comparing to avoid this.
     * Dependency of _calculateCondensedStyle() and _calculateStandardStyle()
     *
     */
  }, {
    key: "_calculateLargeStyle",
    value: function _calculateLargeStyle() {
      this._list.style['flex-wrap'] = 'wrap';
      var listWidth = this._list.offsetWidth;
      var itemTotalWidth = this._listPaddingTotal;
      for (var i = 0; i < this._items.length; i++) {
        (0, _removeClass.default)(this._items[i], 'noline');
        itemTotalWidth += this._items[i].offsetWidth;
        if (listWidth < itemTotalWidth && i > 0) {
          (0, _addClass.default)(this._items[i - 1], 'noline');
          itemTotalWidth = this._items[i].offsetWidth + this._listPaddingTotal;
        }
      }
    }

    /**
     * Fix on condensed variation
     * Same as fix large variation except CSS class
     */
  }, {
    key: "_calculateCondensedStyle",
    value: function _calculateCondensedStyle() {
      (0, _addClass.default)(this._list, 'spark-step-indicator__list--condensed');
      this._calculateLargeStyle();
    }

    /**
     * Fix on dropdown variation
     */
  }, {
    key: "_calculateDropdownStyle",
    value: function _calculateDropdownStyle() {
      this._switchToDropdown();
    }

    /**
     * Change only between large and condensed variation
     * no dropdown variation
     */
  }, {
    key: "_calculateStandardStyle",
    value: function _calculateStandardStyle() {
      this._list.style.visibility = 'hidden';
      for (var i = 0; i < this._items.length; i++) {
        (0, _removeClass.default)(this._items[i], 'noline');
      }
      (0, _removeClass.default)(this._list, 'spark-step-indicator__list--condensed');
      if (this._isOverWidth()) {
        (0, _addClass.default)(this._list, 'spark-step-indicator__list--condensed');
        this._calculateLargeStyle();
      }
      this._list.style.visibility = 'visible';
    }

    /**
     * Make list invisible and change it into large variation at first.
     * Switch variation from top to bottom to find the fit one
     */
  }, {
    key: "_calculateRespStyle",
    value: function _calculateRespStyle() {
      this._list.style.visibility = 'hidden';
      (0, _removeClass.default)(this._list, 'spark-step-indicator__list--condensed');
      if (this._isOverWidth()) {
        (0, _addClass.default)(this._list, 'spark-step-indicator__list--condensed');
        if (this._isOverWidth()) {
          (0, _removeClass.default)(this._list, 'spark-step-indicator__list--condensed');
          this._switchToDropdown();
        }
      }
      this._list.style.visibility = 'visible';
    }

    /**
     * Create header element for dropdown variation
     * Try to find the current step of indicator and show it on the header
     * if not found, show the first step
     * @return {Object} header element of dropdown variation
     */
  }, {
    key: "_createDropdownHeader",
    value: function _createDropdownHeader() {
      var el = document.createElement('a');
      var currentStep = this._list.querySelector('.spark-step-indicator__item--current');

      // Can not find current step
      if (!currentStep) {
        currentStep = this._items[0];
      }

      // Set ARIA roles and attributes
      el.setAttribute('role', 'button');
      el.setAttribute('aria-expanded', 'false');
      var listID = this._list.getAttribute('id') !== null && this._list.getAttribute('id') !== '' ? this._list.getAttribute('id') : '';
      el.setAttribute('aria-controls', listID);
      el.innerHTML = currentStep.innerHTML;
      el.innerHTML += '<span class="spark-step-indicator__notice">' + this.dropdownLabel + '</span>';

      // Create label element like '2 of 7'
      var stepNotice = document.createElement('span');
      var current = Array.prototype.indexOf.call(this._items, currentStep) + 1;
      var total = this._items.length;
      stepNotice.innerHTML = this.stepProgressionLabel.replace('{current}', current).replace('{total}', total);
      stepNotice.className = 'spark-step-indicator__label--dropdown';
      el.appendChild(stepNotice);
      el.className = currentStep.className;
      el.setAttribute('tabindex', '0');
      (0, _addClass.default)(el, 'spark-step-indicator__item--dropdown__header');
      this._dropdownHeader = el;
    }

    /**
     * Some extra event binder and DOM of dropdown variation need to be set
     */
  }, {
    key: "_switchToDropdown",
    value: function _switchToDropdown() {
      (0, _addClass.default)(this._body, 'spark-step-indicator__body--dropdown');
      this._createDropdownHeader();
      this._list.parentNode.insertBefore(this._dropdownHeader, this._list);
      document.removeEventListener('click', this._toggleDropdownBound);
      document.addEventListener('click', this._toggleDropdownBound);
      (0, _addClass.default)(this._list, 'collapse');
      for (var i = 0; i < this._items.length; i++) {
        if (!(0, _hasClass.default)(this._items[i], 'spark-step-indicator__item--disabled')) {
          this._items[i].setAttribute('tabindex', '-1');
        }
      }
    }

    /**
     * Remove extra event and DOM when switch variation from dropdown
     */
  }, {
    key: "_switchFromDropdown",
    value: function _switchFromDropdown() {
      (0, _removeClass.default)(this._body, 'spark-step-indicator__body--dropdown');
      var header = this._list.parentNode.querySelector('.spark-step-indicator__item--dropdown__header');
      document.removeEventListener('click', this._toggleDropdownBound);
      if (header) {
        this._list.parentNode.removeChild(header);
      }
      (0, _removeClass.default)(this._list, 'collapse');
      for (var i = 0; i < this._items.length; i++) {
        if (!(0, _hasClass.default)(this._items[i], 'spark-step-indicator__item--disabled')) {
          this._items[i].removeAttribute('tabindex');
        }
      }
    }

    /**
     * Allow programmatic toggling of Dropdown version of Step Indicator.
     * This becomes desirable particularly in the case of single page applications
     */
  }, {
    key: "toggle",
    value: function toggle() {
      if (this._dropdownHeader) {
        var e = document.createEvent('Event');
        e.initEvent('spark.step-indicator', true, true);
        this._dropdownHeader.dispatchEvent(e);
      }
    }

    /**
     * Toggle collapse/expand state of step list in dropdown variation
     * If there is a scroll in dropdown variation, scroll to 'current' node
     * @param {Object} Reference of DOM obj
     * @param {Object} Event of click
     */
  }, {
    key: "_toggleDropdown",
    value: function _toggleDropdown(e) {
      var target = e.target || e.srcElement;
      if (this._dropdownHeader.contains(target)) {
        if (!this._dropdownExpand) {
          (0, _removeClass.default)(this._list, 'collapse');
          (0, _addClass.default)(this._dropdownHeader, 'expand');
          this._dropdownExpand = true;
          this._dropdownHeader.setAttribute('aria-expanded', 'true');
          for (var i = 0; i < this._items.length; i++) {
            if (!(0, _hasClass.default)(this._items[i], 'spark-step-indicator__item--disabled')) {
              this._items[i].removeAttribute('tabindex');
            }
          }
        } else {
          (0, _addClass.default)(this._list, 'collapse');
          (0, _removeClass.default)(this._dropdownHeader, 'expand');
          this._dropdownExpand = false;
          this._dropdownHeader.setAttribute('aria-expanded', 'false');
          for (var _i = 0; _i < this._items.length; _i++) {
            if (!(0, _hasClass.default)(this._items[_i], 'spark-step-indicator__item--disabled')) {
              this._items[_i].setAttribute('tabindex', '-1');
            }
          }
        }
      } else {
        (0, _addClass.default)(this._list, 'collapse');
        (0, _removeClass.default)(this._dropdownHeader, 'expand');
        this._dropdownExpand = false;
        this._dropdownHeader.setAttribute('aria-expanded', 'false');
        for (var _i2 = 0; _i2 < this._items.length; _i2++) {
          if (!(0, _hasClass.default)(this._items[_i2], 'spark-step-indicator__item--disabled')) {
            this._items[_i2].setAttribute('tabindex', '-1');
          }
        }

        // If we clicked on an item in the list and the list is collapsed, focus should be set on the dropdownheader
        if (this._list.contains(target) && (0, _getParent.default)(e.target, '.spark-step-indicator__item:not(.spark-step-indicator__item--disabled)')) {
          if (!(0, _hasClass.default)(document.activeElement, 'spark-step-indicator__item--dropdown__header')) {
            this._dropdownHeader.focus();
          }
        }
      }
      if (this._list.offsetHeight > 0) {
        var scrollMove = 0;
        for (var _i3 = 0; _i3 < this._items.length; _i3++) {
          if ((0, _hasClass.default)(this._items[_i3], 'spark-step-indicator__item--current')) {
            this._list.scrollTop = scrollMove;
            break;
          }
          scrollMove += this._items[_i3].offsetHeight;
        }
      }
    }

    /**
     * When the window is resized, base on params make some reponsive change.
     */
  }, {
    key: "_onResize",
    value: function _onResize() {
      this._checkPadding();
      this._calculateStyle();
    }

    /**
     * Padding is applied to condensed step indicators but not large step indicators.
     * Therefore as large indicators transition to condensed ones and vice versa, verify
     * the padding values in order to properly calculate positioning of divider line classes
     */
  }, {
    key: "_checkPadding",
    value: function _checkPadding() {
      // Cache list left + right padding for width calculating
      var listStyles = getComputedStyle(this._list);
      var listPaddingLeft = parseInt(listStyles.getPropertyValue('padding-left'), 10);
      var listPaddingRight = parseInt(listStyles.getPropertyValue('padding-right'), 10);
      this._listPaddingTotal = listPaddingLeft + listPaddingRight;
    }

    /**
     * When a parent container shows its children and our element
     * is inside of it, resize
     * @param  {Object} e
     */
  }, {
    key: "_onVisible",
    value: function _onVisible(e) {
      if (e.target.contains(this.el)) {
        window.setTimeout(function () {
          this._calculateStyle();
        }.bind(this), 0);
      }
    }
  }]);
  return StepIndicator;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
StepIndicator.prototype._whitelistedParams = ['type', 'dropdownLabel', 'stepProgressionLabel', 'currentLabel', 'completedLabel', 'onStepClick'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
StepIndicator.prototype.defaults = {
  el: null,
  containerEl: null,
  dropdownLabel: 'Select a Step',
  type: null,
  stepProgressionLabel: '{current} of {total}',
  completedLabel: 'Completed',
  currentLabel: 'Current',
  onStepClick: null,
  focusableElements: null,
  _body: null,
  _list: null,
  _listPaddingTotal: 0,
  _dropdownExpand: false,
  _dropdownHeader: null,
  _items: null,
  _onResizeBound: null,
  _onVisibleBound: null
};
var _default = StepIndicator;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/add-class":59,"../helpers/dom/has-class":61,"../helpers/dom/remove-class":67,"../helpers/traversal/get-parent":87,"./base":3,"@babel/runtime-corejs3/core-js-stable/instance/map":113,"@babel/runtime-corejs3/core-js-stable/instance/slice":115,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155,"@babel/runtime-corejs3/helpers/toConsumableArray":159}],39:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _from = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/from"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _expand = _interopRequireDefault(require("./expand"));
var _setCaret = _interopRequireDefault(require("../helpers/form/set-caret"));
var _formData = require("../helpers/form/form-data");
var _each = _interopRequireDefault(require("../helpers/util/each"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _getParent = _interopRequireDefault(require("../helpers/traversal/get-parent"));
var _getIndex = _interopRequireDefault(require("../helpers/traversal/get-index"));
var _getSiblingBefore = _interopRequireDefault(require("../helpers/traversal/get-sibling-before"));
var _getSiblingAfter = _interopRequireDefault(require("../helpers/traversal/get-sibling-after"));
var _matches = _interopRequireDefault(require("../helpers/traversal/matches"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Table
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Table(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/table.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var Table = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(Table, _BaseComponent);
  var _super = _createSuper(Table);
  /**
   * Table constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function Table(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Table);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    _this._initRows();
    if (_this.isSpreadsheet || _this.isEditRows) {
      _this._deactivateAllInputs();
    }
    if (_this.isResizable) {
      _this._initResize();
    }
    _this._disableRowsColumnsCells();
    _this._initExpands();
    _this._initRowToPanel();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Disable the form field in a table cell.
   * @param {Element} el
   */
  (0, _createClass2.default)(Table, [{
    key: "disableCell",
    value: function disableCell(el) {
      el.disabled = true;
      (0, _addClass.default)((0, _getParent.default)(el, 'td'), 'spark-table__disabled-cell');
      return this;
    }

    /**
     * Enable the form field in a table cell.
     * @param {Element} el
     */
  }, {
    key: "enableCell",
    value: function enableCell(el) {
      el.disabled = false;
      (0, _removeClass.default)((0, _getParent.default)(el, 'td'), 'spark-table__disabled-cell');
      return this;
    }

    /**
     * Disable a row and all the cells inside of it.
     * @param {Element} el
     */
  }, {
    key: "disableRow",
    value: function disableRow(el) {
      (0, _addClass.default)(el, 'spark-table__disabled-row');
      (0, _each.default)(el.querySelectorAll('input, button, a'), function (i) {
        i.disabled = true;
      });
      return this;
    }

    /**
     * Enable a row and all the cells inside of it.
     * @param {Element} el
     */
  }, {
    key: "enableRow",
    value: function enableRow(el) {
      (0, _removeClass.default)(el, 'spark-table__disabled-row');
      (0, _each.default)(el.querySelectorAll('input, button, a'), function (i) {
        i.disabled = false;
      });
      return this;
    }

    /**
     * Disable a column and all the cells inside of it.
     * @param {Element} el
     */
  }, {
    key: "disableColumn",
    value: function disableColumn(el) {
      var index = (0, _getIndex.default)(el.parentNode.children, el);
      (0, _each.default)(this.tableEl.querySelectorAll('tbody tr'), function (row) {
        this.disableCell(row.children[index].querySelector('input'));
      }.bind(this));
      (0, _addClass.default)(el, 'spark-table__disabled-column');
      return this;
    }

    /**
     * Enable a column and all the cells inside of it.
     * @param {Element} el
     */
  }, {
    key: "enableColumn",
    value: function enableColumn(el) {
      var index = (0, _getIndex.default)(el.parentNode.children, el);
      (0, _each.default)(this.tableEl.querySelectorAll('tbody tr'), function (row) {
        this.enableCell(row.children[index].querySelector('input'));
      }.bind(this));
      (0, _removeClass.default)(el, 'spark-table__disabled-column');
      return this;
    }

    /**
     * Remove the table anc cleanup.
     * @param {Boolean} leaveElement Leave the element intact.
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      (0, _each.default)(this._expands, function (e) {
        e.remove(leaveElement);
      });
      return (0, _get2.default)((0, _getPrototypeOf2.default)(Table.prototype), "remove", this).call(this, leaveElement);
    }

    /**
     * Activate a row.
     * @param {Number|Element} row
     */
  }, {
    key: "activateRow",
    value: function activateRow(row) {
      row = typeof row === 'number' ? this.tableEl.querySelectorAll('tbody tr')[row] : row;
      if (row) this._makeRowActive(row);
      return this;
    }

    /**
     * Activate multiple rows.
     * @param {Array} rows
     */
  }, {
    key: "activateRows",
    value: function activateRows(rows) {
      (0, _each.default)(rows, this.activateRow.bind(this));
      return this;
    }

    /**
     * Deactivate a row.
     * @param {Number|Element} row
     */
  }, {
    key: "deactivateRow",
    value: function deactivateRow(row) {
      row = typeof row === 'number' ? this.tableEl.querySelectorAll('tbody tr')[row] : row;
      if (row) this._makeRowInActive(row);
      return this;
    }

    /**
     * Deactivate multiple rows.
     * @param {Array} rows
     */
  }, {
    key: "deactivateRows",
    value: function deactivateRows(rows) {
      (0, _each.default)(rows, this.deactivateRow.bind(this));
      return this;
    }

    /**
     * Get an array of currently active rows.
     * @return {Array}
     */
  }, {
    key: "getActiveRows",
    value: function getActiveRows() {
      var arr = [];
      (0, _each.default)(this.el.querySelectorAll('tbody tr.active'), function (tr) {
        arr.push(tr);
      });
      return arr;
    }

    /**
     * Update the component to use a new element or reparse from
     * the existing element.
     * @param {Element} el Optional
     */
  }, {
    key: "update",
    value: function update(el) {
      this._removeEventListeners();
      this._cacheElements(el || this.el);
      this._parseParams();
      this._addEventListeners();
      this._initRows();
      if (this.isSpreadsheet || this.isEditRows) {
        this._deactivateAllInputs();
      }
      if (this.isResizable) {
        this._initResize();
      }
      this._disableRowsColumnsCells();
      this._initExpands();
      this._initRowToPanel();
      return this;
    }

    /**
     * Store a reference to the tabs list, each tab and each panel.
     * Set which tab is active, or use the first.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.tableEl = el.querySelector('table');
    }

    /**
     * Parse parameters from the elements.
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      if (!this.tableEl) {
        return;
      }
      this.isSpreadsheet = this.isSpreadsheet !== null ? this.isSpreadsheet : (0, _hasClass.default)(this.el, 'spark-table--spreadsheet') ? true : false;
      this.isEditRows = this.isEditRows !== null ? this.isEditRows : (0, _hasClass.default)(this.el, 'spark-table--edit-rows') ? true : false;
      this.isResizable = this.isResizable !== null ? this.isResizable : (0, _hasClass.default)(this.el, 'spark-table--resizable') ? true : false;
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onClickBound = this._onClick.bind(this);
      this._onChangeBound = this._onChange.bind(this);
      this._onFocusBound = this._onFocus.bind(this);
      this._onBlurBound = this._onBlur.bind(this);
      this._onTouchstartBound = this._onTouchstart.bind(this);
      this._onTouchendBound = this._onTouchend.bind(this);
      this._onKeydownBound = this._onKeydown.bind(this);
      this._onMouseDownBound = this._onMouseDown.bind(this);
      this._onMouseMoveBound = this._onMouseMove.bind(this);
      this._onMouseUpBound = this._onMouseUp.bind(this);
      this._onAnimationEndBound = this._onAnimationEnd.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.el.addEventListener('click', this._onClickBound, false);
      this.el.addEventListener('change', this._onChangeBound, false);
      this.el.addEventListener('focus', this._onFocusBound, true);
      this.el.addEventListener('blur', this._onBlurBound, true);
      this.el.addEventListener('animationend', this._onAnimationEndBound, true);
      this.el.addEventListener('webkitAnimationEnd', this._onAnimationEndBound, true);
      if (this.isSpreadsheet) {
        this.el.addEventListener('touchstart', this._onTouchstartBound, false);
        this.el.addEventListener('touchend', this._onTouchendBound, false);
        this.el.addEventListener('keydown', this._onKeydownBound, false);
      }
      if (this.isResizable) {
        this.tableEl.addEventListener('mousedown', this._onMouseDownBound, false);
      }
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.el.removeEventListener('click', this._onClickBound);
      this.el.removeEventListener('change', this._onChangeBound);
      this.el.removeEventListener('focus', this._onFocusBound);
      this.el.removeEventListener('blur', this._onBlurBound);
      this.el.removeEventListener('animationend', this._onAnimationEndBound);
      this.el.removeEventListener('webkitAnimationEnd', this._onAnimationEndBound);
      this.el.removeEventListener('touchstart', this._onTouchstartBound);
      this.el.removeEventListener('touchend', this._onTouchendBound);
      this.el.removeEventListener('keydown', this._onKeydownBound);
      this.tableEl.removeEventListener('mousedown', this._onMouseDownBound);
      this._removeResizeListeners();
    }

    /**
     * Add listeners for mousemove and mouseup events.
     */
  }, {
    key: "_addResizeListeners",
    value: function _addResizeListeners() {
      window.addEventListener('mousemove', this._onMouseMoveBound, false);
      window.addEventListener('mouseup', this._onMouseUpBound, false);
    }

    /**
     * Remove listeners for mosuemove and mouseup.
     */
  }, {
    key: "_removeResizeListeners",
    value: function _removeResizeListeners() {
      window.removeEventListener('mousemove', this._onMouseMoveBound);
      window.removeEventListener('mouseup', this._onMouseUpBound);
    }

    /**
     * Toggle the active state on a row.
     * @param {Object} row
     */
  }, {
    key: "_toggleRowActive",
    value: function _toggleRowActive(row) {
      if ((0, _hasClass.default)(row, 'active')) {
        this._makeRowInActive(row);
        this._uncheckSelectAll();
      } else {
        this._makeRowActive(row);
      }
    }

    /**
     * Make a row active
     * @param {Element} row
     */
  }, {
    key: "_makeRowActive",
    value: function _makeRowActive(row) {
      if ((0, _hasClass.default)(row, 'spark-table__drawer')) {
        return;
      }
      (0, _addClass.default)(row, 'active');
      (row.querySelector('.spark-table__checkbox input[type="checkbox"]:not([disabled])') || {}).checked = true;
    }

    /**
     * Make a row active
     * @param  {Element} row
     */
  }, {
    key: "_makeRowInActive",
    value: function _makeRowInActive(row) {
      (0, _removeClass.default)(row, 'active');
      (row.querySelector('.spark-table__checkbox input[type="checkbox"]:not([disabled])') || {}).checked = false;
    }

    /**
     * Toggle active on each row.
     * @param {NodeList} rows
     * @param {Boolean} active
     */
  }, {
    key: "_toggleRowsActive",
    value: function _toggleRowsActive(rows, active) {
      var func = active ? '_makeRowActive' : '_makeRowInActive';
      var i = 0;
      var len = rows.length;
      for (; i < len; i++) {
        this[func](rows[i]);
      }
    }

    /**
     * Toggle whether everything should be selected. Find the checkbox input inside of the
     * given element and invert its state.
     * @param {Element} el
     */
  }, {
    key: "_toggleSelectAll",
    value: function _toggleSelectAll(el) {
      var checkbox = el.querySelector('.spark-table__select-all input[type="checkbox"]');
      if (!checkbox) {
        return;
      }
      this._toggleRowsActive(this.el.querySelectorAll('tbody tr'), !checkbox.checked);
      checkbox.checked = !checkbox.checked;
    }

    /**
     * Uncheck the select all checkboxes.
     */
  }, {
    key: "_uncheckSelectAll",
    value: function _uncheckSelectAll() {
      var checkboxes = this.el.querySelectorAll('.spark-table__select-all input[type="checkbox"]');
      var i = 0;
      var len = checkboxes.length;
      for (; i < len; i++) {
        checkboxes[i].checked = false;
      }
    }

    /**
     * Deactivate editing in all input fields.
     */
  }, {
    key: "_deactivateAllInputs",
    value: function _deactivateAllInputs() {
      if (!this.tableEl) {
        return;
      }
      this._deactivateInputs(this.tableEl);
    }

    /**
     * Deactivate all the inputs inside an element
     * @param {Element} el
     */
  }, {
    key: "_deactivateInputs",
    value: function _deactivateInputs(el) {
      var inputs = el.querySelectorAll('input:not([type="checkbox"])');
      var i = 0;
      var len = inputs.length;
      for (; i < len; i++) {
        this._deactivateInput(inputs[i]);
      }
    }

    /**
     * Make an input field readonly.
     * @param {Element} input
     */
  }, {
    key: "_deactivateInput",
    value: function _deactivateInput(input) {
      input.setAttribute('readonly', '');
      (0, _removeClass.default)(input.parentNode, 'editing');
    }

    /**
     * Activate all the inputs inside an element
     * @param {Element} el
     */
  }, {
    key: "_activateInputs",
    value: function _activateInputs(el) {
      var inputs = el.querySelectorAll('input:not([type="checkbox"])');
      var i = 0;
      var len = inputs.length;
      for (; i < len; i++) {
        this._activateInput(inputs[i]);
        if (i === 0) {
          inputs[i].focus();
        }
      }
    }

    /**
     * Make an input field readable.
     * @param {Element} input
     */
  }, {
    key: "_activateInput",
    value: function _activateInput(input) {
      // Create a temporary input to allow keyboard to show in iOS
      if (input.type !== 'checkbox' && input.type !== 'radio') {
        var inputDimensions = input.getBoundingClientRect();
        var tempInput = document.createElement('input');
        tempInput.style.border = 0;
        tempInput.style.height = inputDimensions.height + 'px';
        tempInput.style.left = inputDimensions.x + 'px';
        tempInput.style.opacity = 0.01;
        tempInput.style.padding = '1.25rem 1rem';
        tempInput.style.position = 'absolute';
        tempInput.style.top = inputDimensions.y + 'px';
        tempInput.value = input.value;
        tempInput.style.width = inputDimensions.width + 'px';
        document.body.appendChild(tempInput);

        // Focus on the temporary input to bring up the keyboard in iOS
        tempInput.focus();
        setTimeout(function () {
          input.removeAttribute('readonly');
          input.focus();
          document.body.removeChild(tempInput);
        }, 10);
      }
      (0, _addClass.default)(input.parentNode, 'editing');
      if (input.type !== 'checkbox' && input.type !== 'radio') {
        (0, _setCaret.default)(input, -1);
      }
    }

    /**
     * Activate an input, unless it's already enabled in which case
     * the focus should move down a row.
     * @param {Element} input
     */
  }, {
    key: "_activateInputOrFocusDown",
    value: function _activateInputOrFocusDown(input) {
      if (input.getAttribute('readonly') === '') {
        // Currently readonly
        this._activateInput(input);
        return;
      }
      this._focusDown(input, true);
    }

    /**
     * Find all the rows, columns and cells that should be disabled.
     */
  }, {
    key: "_disableRowsColumnsCells",
    value: function _disableRowsColumnsCells() {
      (0, _each.default)(this.tableEl.querySelectorAll('td input[disabled]'), this.disableCell.bind(this));
      (0, _each.default)(this.tableEl.querySelectorAll('.spark-table__disabled-row'), this.disableRow.bind(this));
      (0, _each.default)(this.tableEl.querySelectorAll('.spark-table__disabled-column'), this.disableColumn.bind(this));
    }

    /**
     * Move our focus up a row from the given element.
     * @param {Element} input
     * @param {Boolean} force Force the move even if the element is active.
     */
  }, {
    key: "_focusUp",
    value: function _focusUp(input, force) {
      return this._focusUpDown(input, 'up', force);
    }

    /**
     * Move our focus down a row from the given element.
     * @param {Element} input
     * @param {Boolean} force Force the move even if the element is active.
     */
  }, {
    key: "_focusDown",
    value: function _focusDown(input, force) {
      return this._focusUpDown(input, 'down', force);
    }

    /**
     * Focus on a row up or down from the given element.
     * @param {Element} input
     * @param {String} direction up|down
     * @param {Boolean} force Force the move even if the element is active.
     */
  }, {
    key: "_focusUpDown",
    value: function _focusUpDown(input, direction, force) {
      if (!force && input.getAttribute('readonly') === null) {
        // If we're not being told to force and the item is not read only
        return;
      }
      this._deactivateInput(input);
      var td = (0, _getParent.default)(input, 'td', this.el);
      if (!td) {
        return;
      }
      var index = (0, _getIndex.default)(td.parentNode.children, td);
      var nextRow = (direction === 'up' ? _getSiblingBefore.default : _getSiblingAfter.default)(td.parentNode, 'tr');
      if (!nextRow) {
        return;
      }
      var newTd = nextRow.children[index];
      if (!newTd) {
        return;
      }
      var newInput = newTd.querySelector('input:not([type="checkbox"]), select');
      if (newInput) {
        if (newInput.disabled) {
          this._focusUpDown(newInput, direction, force);
        } else {
          newInput.focus();
        }
      }
    }

    /**
     * Move our focus left a cell from the given element.
     * @param {Element} input
     * @param {Boolean} force Force the move even if the element is active.
     */
  }, {
    key: "_focusLeft",
    value: function _focusLeft(input, force) {
      return this._focusLeftRight(input, 'left', force);
    }

    /**
     * Move our focus right a cell from the given element.
     * @param {Element} input
     * @param {Boolean} force Force the move even if the element is active.
     */
  }, {
    key: "_focusRight",
    value: function _focusRight(input, force) {
      return this._focusLeftRight(input, 'right', force);
    }

    /**
     * Focus on a cell left or down from the given element.
     * @param {Element} input
     * @param {String} direction up|down
     * @param {Boolean} force Force the move even if the element is active.
     */
  }, {
    key: "_focusLeftRight",
    value: function _focusLeftRight(input, direction, force) {
      if (!force && input.getAttribute('readonly') === null) {
        // If we're not being told to force and the item is not read only
        return;
      }
      this._deactivateInput(input);
      var td = (0, _getParent.default)(input, 'td', this.el);
      if (!td) {
        return;
      }
      var newTd = (direction === 'left' ? _getSiblingBefore.default : _getSiblingAfter.default)(td, 'td');
      if (!newTd) {
        return;
      }
      var newInput = newTd.querySelector('input:not([type="checkbox"]), select');
      if (newInput) {
        if (newInput.disabled) {
          this._focusLeftRight(newInput, direction, force);
        } else {
          newInput.focus();
        }
      }
    }

    /**
     * Check for two click events on the same element in short succession.
     * @param {Element} el
     */
  }, {
    key: "_checkDoubleClick",
    value: function _checkDoubleClick(el) {
      var now = Date.now();
      var lastTime = this._lastClickTime;
      var lastEl = this._lastClickEl;
      this._lastClickTime = now;
      this._lastClickEl = el;
      if (el === lastEl && now - 500 < lastTime) {
        return true;
      }
      return false;
    }

    /**
     * Unset the last clicked element.
     */
  }, {
    key: "_clearClicked",
    value: function _clearClicked() {
      this._lastClickEl = null;
    }

    /**
     * Enable editing on a row.
     * @param {Element} row
     */
  }, {
    key: "_editRow",
    value: function _editRow(row) {
      if (!row) {
        return;
      }
      this._editingCount++;
      this._activateInputs(row);
      (0, _formData.store)(row);
      (0, _addClass.default)(row, 'editing');
      this._updateBindings();
    }

    /**
     * Cancel editing a row.
     * @param {Element} row
     */
  }, {
    key: "_cancelRow",
    value: function _cancelRow(row) {
      if (!row) {
        return;
      }
      this._editingCount--;
      this._deactivateInputs(row);
      (0, _formData.restore)(row);
      (0, _removeClass.default)(row, 'editing');
      this._updateBindings();
    }

    /**
     * Save a row.
     * @param {Element} row
     */
  }, {
    key: "_saveRow",
    value: function _saveRow(row) {
      if (!row) {
        return;
      }
      this._editingCount--;
      this._deactivateInputs(row);
      (0, _formData.clear)(row);
      (0, _removeClass.default)(row, 'editing');
      this._updateBindings();
      (this.onRowSave || noop)((0, _getIndex.default)(row.parentNode.children, row), row);
    }

    /**
     * Delete a row.
     * @param {Element} row
     */
  }, {
    key: "_deleteRow",
    value: function _deleteRow(row) {
      if (!row) {
        return;
      }
      (this.onRowDelete || noop)((0, _getIndex.default)(row.parentNode.children, row), row);
      row.parentNode.removeChild(row);
    }

    /**
     * Confirm the deletion of a row.
     * @param {Element} row
     */
  }, {
    key: "_confirmDelete",
    value: function _confirmDelete(row) {
      if (!this.confirmDelete || typeof this.confirmDelete !== 'function') {
        this._deleteRow(row);
      } else {
        this.confirmDelete(row, this._deleteRow);
      }
    }

    /**
     * Toggle the Expanded/Collapsed state of a drawer
     * @param {Element} handle
     */
  }, {
    key: "_toggleDrawer",
    value: function _toggleDrawer(handle) {
      var udid = handle.dataset.drawerHandle;
      var drawer = this.tableEl.querySelector('[data-drawer="' + udid + '"]');
      var handleRow = (0, _getParent.default)(handle, 'tr', this.tableEl);
      var expanded = JSON.parse(handle.getAttribute('aria-expanded'));
      if (drawer && expanded) {
        if (typeof this.onBeforeDrawerCollapse === 'function') {
          this.onBeforeDrawerCollapse(udid, this);
        }
        (0, _removeClass.default)(handleRow, 'spark-table__handle-row--expanded');
        (0, _removeClass.default)(handleRow, 'spark-table__handle-row--expand');
        (0, _addClass.default)(handleRow, 'spark-table__handle-row--collapse');
        (0, _removeClass.default)(drawer, 'spark-table__drawer--expanded');
        (0, _removeClass.default)(drawer, 'spark-table__drawer--expand');
        (0, _addClass.default)(drawer, 'spark-table__drawer--collapse');
        if (typeof this.onDrawerCollapse === 'function') {
          this.onDrawerCollapse(udid, this);
        }
        handle.setAttribute('aria-expanded', false);
      } else if (drawer) {
        if (typeof this.onBeforeDrawerExpand === 'function') {
          this.onBeforeDrawerExpand(udid, this);
        }
        (0, _removeClass.default)(handleRow, 'spark-table__handle-row--collapsed');
        (0, _removeClass.default)(handleRow, 'spark-table__handle-row--collapse');
        (0, _addClass.default)(handleRow, 'spark-table__handle-row--expand');
        (0, _removeClass.default)(drawer, 'spark-table__drawer--collapsed');
        (0, _removeClass.default)(drawer, 'spark-table__drawer--collapse');
        (0, _addClass.default)(drawer, 'spark-table__drawer--expand');
        if (typeof this.onDrawerExpand === 'function') {
          this.onDrawerExpand(udid, this);
        }
        handle.setAttribute('aria-expanded', true);
      }
    }

    /**
     * Update data bindings.
     */
  }, {
    key: "_updateBindings",
    value: function _updateBindings() {
      (0, _toggleClass.default)(this.el, 'editing', this._editingCount);
    }

    /**
     * Add handles to the header that can be grabbed for resizing.
     */
  }, {
    key: "_initResize",
    value: function _initResize() {
      this._resizeEls = [];
      var ths = this.tableEl.querySelectorAll('thead th');
      (0, _each.default)(ths, function (th) {
        th.innerHTML = '<span class="spark-table__resize spark-table__resize--left"></span>' + th.innerHTML + '<span class="spark-table__resize spark-table__resize--right"></span>';
        this._resizeEls.push(th);
      }.bind(this));
    }

    /**
     * Initialize rows active states.
     */
  }, {
    key: "_initRows",
    value: function _initRows() {
      (0, _each.default)(this.tableEl.querySelectorAll('td.spark-table__checkbox input:checked'), function (c) {
        this._makeRowActive((0, _getParent.default)(c, 'tr'));
      }.bind(this));
    }

    /**
     * Set the size of each column as a percentage so it can be adjusted
     * while cells are resized.
     * @param {String} unit Optional
     * @param {Boolean} force Optional
     */
  }, {
    key: "_sizeColumns",
    value: function _sizeColumns(unit, force) {
      unit = unit || '%';
      if (this._sizeColumnsRun && !force) {
        return;
      }
      var width = this.tableEl.offsetWidth;
      (0, _each.default)(this.tableEl.querySelectorAll('thead th'), function (th) {
        if (unit === '%') th.style.width = Math.round(th.offsetWidth / width * 100000) / 100000 * 100 + '%';else th.style.width = th.offsetWidth + 'px';
      }.bind(this));
      this._sizeColumnsRun = true;
    }

    /**
     * Initialize expand/collapse rows.
     */
  }, {
    key: "_initExpands",
    value: function _initExpands() {
      var expands = this.tableEl.querySelectorAll('.spark-table-expand');
      this._expands = [];
      (0, _each.default)(expands, function (e) {
        this._expands.push(new _expand.default(e, {
          onBeforeExpand: this._onBeforeExpand.bind(this)
        }));
      }.bind(this));
    }

    /**
     * Before an expand is called, size all the columns so that
     * the expand does cause width changes.
     */
  }, {
    key: "_onBeforeExpand",
    value: function _onBeforeExpand() {
      this._sizeColumns();
    }

    /**
     * When animations end determine the proper action to take.
     * @param  {Object} e
     */
  }, {
    key: "_onAnimationEnd",
    value: function _onAnimationEnd(e) {
      var target = e.target || e.srcElement;
      if ((0, _matches.default)(target, '.spark-table__drawer__content')) {
        var drawer = target.parentElement.parentElement;
        var handleRow = (0, _getSiblingBefore.default)(drawer, 'tr');
        var expanding = (0, _hasClass.default)(drawer, 'spark-table__drawer--expand');
        if (drawer && expanding) {
          (0, _addClass.default)(handleRow, 'spark-table__handle-row--expanded');
          (0, _removeClass.default)(handleRow, 'spark-table__handle-row--expand');
          (0, _addClass.default)(drawer, 'spark-table__drawer--expanded');
          (0, _removeClass.default)(drawer, 'spark-table__drawer--expand');
          if (typeof this.onAfterDrawerExpand === 'function') {
            this.onAfterDrawerExpand(drawer.dataset.drawer, this);
          }
        } else if (drawer) {
          (0, _addClass.default)(handleRow, 'spark-table__handle-row--collapsed');
          (0, _removeClass.default)(handleRow, 'spark-table__handle-row--collapse');
          (0, _addClass.default)(drawer, 'spark-table__drawer--collapsed');
          (0, _removeClass.default)(drawer, 'spark-table__drawer--collapse');
          if (typeof this.onAfterDrawerCollapse === 'function') {
            this.onAfterDrawerCollapse(drawer.dataset.drawer, this);
          }
        }
      }
    }

    /**
     * When we are clicked determine the proper action to take.
     * @param  {Object} e
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      var target = e.target || e.srcElement;
      var row;
      var selectAll;
      var actionTaken = false;
      var clearClicked = true;
      if ((selectAll = (0, _getParent.default)(target, '.spark-table__select-all', this.el)) && !(0, _matches.default)(target, 'input[type="checkbox"]')) {
        // Select all rows checkbox

        this._toggleSelectAll(selectAll);
        actionTaken = true;
      } else if ((0, _matches.default)(target, 'input:not([type="checkbox"]):not([type="file"]), select')) {
        // Editable field

        if (!target.disabled) {
          // Listen for double clicks on a spreadsheet

          if (this.isSpreadsheet) {
            clearClicked = false;
            if (this._checkDoubleClick(target)) {
              clearClicked = true;
              this._activateInput(target);
            }
          }
          actionTaken = true;
        }
      } else if ((0, _matches.default)(target, '.spark-table__edit-row')) {
        // Edit button

        this._editRow((0, _getParent.default)(target, 'tr', this.el));
        actionTaken = true;
      } else if ((0, _matches.default)(target, '.spark-table__delete-row')) {
        // Delete button

        this._confirmDelete((0, _getParent.default)(target, 'tr', this.el));
        actionTaken = true;
      } else if ((0, _matches.default)(target, '.spark-table__edit-row-save')) {
        // Save button

        this._saveRow((0, _getParent.default)(target, 'tr', this.el));
        actionTaken = true;
      } else if ((0, _matches.default)(target, '.spark-table__edit-row-cancel')) {
        // Cancel button

        this._cancelRow((0, _getParent.default)(target, 'tr', this.el));
        actionTaken = true;
      } else if ((0, _matches.default)(target, 'button[data-drawer-handle]')) {
        // Expand or Collapse a Drawer

        this._toggleDrawer(target);
        actionTaken = true;
      } else if (!(0, _getParent.default)(target, 'button, a, .spark-toggle-switch', this.el) && !(0, _matches.default)(target, '.spark-table__checkbox input[type="checkbox"], select') && (row = (0, _getParent.default)(target, 'tbody tr', this.el))) {
        // Determine if the target is a checkbox and whether it is in the Select All column
        if ((0, _matches.default)(target, '.spark-checkbox, .spark-checkbox__box, .spark-checkbox__input')) {
          var cell = (0, _getParent.default)(target, 'td', this.el);
          var cellIndex = (0, _from.default)(row.children).indexOf(cell);
          var tableHeaderCells = this.el.querySelector('thead tr').children;

          // Check if the corresponding <th> has the .select-all class
          if ((0, _hasClass.default)(tableHeaderCells[cellIndex], 'spark-table__select-all')) {
            if (!(row.querySelector('.spark-table__checkbox input[type="checkbox"]') || {}).disabled && !row.hasAttribute('data-drawer')) {
              this._toggleRowActive(row);
              actionTaken = true;
            }
          }
        } else {
          if (!(row.querySelector('.spark-table__checkbox input[type="checkbox"]') || {}).disabled && !row.hasAttribute('data-drawer')) {
            this._toggleRowActive(row);
            actionTaken = true;
          }
        }
      }
      if (clearClicked) {
        this._clearClicked();
      }
      if (actionTaken) {
        e.preventDefault();
      }
    }

    /**
     * When the change event fires on our element.
     * @param {Object} e
     */
  }, {
    key: "_onChange",
    value: function _onChange(e) {
      var target = e.target || e.srcElement;
      var row;
      var selectAll;

      // Select all rows checkbox. We have to invert the checked value here because it
      // get toggled back in the select all call.
      if (selectAll = (0, _getParent.default)(target, '.spark-table__select-all', this.el)) {
        target.checked = !target.checked;
        this._toggleSelectAll(selectAll);
      } else if ((0, _matches.default)(target, '.spark-table__checkbox input[type="checkbox"]') && (row = (0, _getParent.default)(target, 'tbody tr', this.el))) {
        // Checkbox for a row
        this._toggleRowActive(row);
      }
    }

    /**
     * If this is a spreadsheet, whenever a field gains focus, highlight its parent.
     * @param {Object} e
     */
  }, {
    key: "_onFocus",
    value: function _onFocus(e) {
      var target = e.target || e.srcElement;
      if (!this.isSpreadsheet || !(0, _matches.default)(target, 'input:not([type="checkbox"]), select')) {
        return;
      }
      var td = (0, _getParent.default)(target, 'td', this.el);
      (0, _addClass.default)(td, 'focus');
    }

    /**
     * If this is a spreadsheet, whenever a field gains focus, highlight its parent.
     * @param {Object} e
     */
  }, {
    key: "_onBlur",
    value: function _onBlur(e) {
      if (!this.isSpreadsheet) {
        return;
      }
      var target = e.target || e.srcElement;
      var td = (0, _getParent.default)(target, 'td', this.el);
      (0, _removeClass.default)(td, 'focus');
      this._deactivateInput(target);
    }

    /**
     * When a key is pressed, if this is a spreadsheet then we should detect
     * enter or arrow keys.
     * @param {Object} e
     */
  }, {
    key: "_onKeydown",
    value: function _onKeydown(e) {
      var target = e.target || e.srcElement;
      if (!this.isSpreadsheet || !(0, _matches.default)(target, 'input:not([type="checkbox"]), select')) {
        return;
      }
      var code = e.keyCode || e.which;
      switch (code) {
        case this._keyCodes.ENTER:
          this._activateInputOrFocusDown(target);
          break;
        case this._keyCodes.ESCAPE:
          this._deactivateInput(target);
          break;
        case this._keyCodes.DOWN:
          this._focusDown(target);
          break;
        case this._keyCodes.UP:
          this._focusUp(target);
          break;
        case this._keyCodes.LEFT:
          this._focusLeft(target);
          break;
        case this._keyCodes.RIGHT:
          this._focusRight(target);
          break;
      }
    }

    /**
     * Listen for a touch and hold on an input.
     * @param {Object} e
     */
  }, {
    key: "_onTouchstart",
    value: function _onTouchstart(e) {
      var target = e.target || e.srcElement;
      if (!this.isSpreadsheet || !(0, _matches.default)(target, 'input:not([type="checkbox"])')) {
        return;
      }
      this._touchStartEl = target;
      this._touchStartTime = Date.now();
      this._touchStartTimer = setTimeout(this._onTouchHold.bind(this), 1000);
    }

    /**
     * Listen for the end of a touch to cancel the hold timer.
     * @param {Object} e
     */
  }, {
    key: "_onTouchend",
    value: function _onTouchend(e) {
      var target = e.target || e.srcElement;
      if (!this._touchStartEl || target !== this._touchStartEl) {
        return;
      }
      this._touchStartEl = null;
      this._touchStartTime = null;
      clearTimeout(this._touchStartTimer);
    }

    /**
     * When the user has held on an input for the defined amount of time.
     */
  }, {
    key: "_onTouchHold",
    value: function _onTouchHold() {
      this._activateInput(this._touchStartEl);
      this._touchStartEl = null;
      this._touchStartTime = null;
      clearTimeout(this._touchStartTimer);
    }

    /**
     * When the mouse is depressed.
     * @param {Object} e
     */
  }, {
    key: "_onMouseDown",
    value: function _onMouseDown(e) {
      var target = e.target || e.srcElement;
      if (!this.isResizable || !(0, _matches.default)(target, '.spark-table__resize')) {
        return;
      }
      e.preventDefault();
      this._lastScreenX = e.screenX;
      this._sizeColumns('px', true);
      this._resizingEl = target.parentNode;
      var index = this._resizeEls.indexOf(this._resizingEl);
      if ((0, _hasClass.default)(target, 'spark-table__resize--left')) {
        this._resizingEl = this._resizeEls[index - 1];
      }
      if (!this._resizingEl) {
        return;
      }
      this._addResizeListeners();
    }

    /**
     * When the mouse moves after being depressed, resize the columns.
     * @param {Object} e
     */
  }, {
    key: "_onMouseMove",
    value: function _onMouseMove(e) {
      var x = e.screenX;
      var d = x - this._lastScreenX;
      if (!d) {
        // No delta change
        return;
      }
      e.preventDefault();
      var w = this._resizingEl.offsetWidth;
      var tW = this.tableEl.offsetWidth;
      var newW = w + d;
      var newTW = tW + d;
      this._resizingEl.style.width = newW + 'px';
      this.tableEl.style.width = newTW + 'px';
      if (this._resizingEl.offsetWidth === w || this.tableEl.offsetWidth < this.tableEl.parentNode.offsetWidth) {
        // Size was not affected because we're too small
        this._resizingEl.style.width = w + 'px';
        this.tableEl.style.width = tW + 'px';
      }
      this._lastScreenX = x;
    }

    /**
     * When the mouse is released, stop tracking mouse move events and
     * convert table sizes to percentages.
     * @param {Object} e
     */
  }, {
    key: "_onMouseUp",
    value: function _onMouseUp() {
      this._sizeColumns('%', true);
      this.tableEl.style.width = this.tableEl.offsetWidth / this.tableEl.parentNode.offsetWidth * 100 + '%';
      this._removeResizeListeners();
    }

    /**
     * Initialize Row-to-Panel Tables
     */
  }, {
    key: "_initRowToPanel",
    value: function _initRowToPanel() {
      // Set data-attributes to allow styling of Row-to-Panel on smaller viewports
      if (this.tableEl.hasAttribute('data-panel-breakpoint') && (0, _hasClass.default)(this.el, 'spark-table--row-to-panel')) {
        var panelBreakpoint = this.tableEl.getAttribute('data-panel-breakpoint');
        var tableScrollEl = this.el.querySelector('.spark-table__scroll');
        tableScrollEl.setAttribute('data-panel-breakpoint-' + panelBreakpoint, '');
      }
    }
  }]);
  return Table;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
Table.prototype._whitelistedParams = ['isSpreadsheet', 'isEditRows', 'isResizable', 'confirmDelete', 'onRowSave', 'onRowDelete', 'onBeforeDrawerExpand', 'onBeforeDrawerCollapse', 'onDrawerExpand', 'onDrawerCollapse', 'onAfterDrawerExpand', 'onAfterDrawerCollapse'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
Table.prototype.defaults = {
  el: null,
  tableEl: null,
  isSpreadsheet: null,
  isEditRows: null,
  isResizable: null,
  onRowSave: null,
  onRowDelete: null,
  confirmDelete: null,
  onBeforeDrawerExpand: null,
  onBeforeDrawerCollapse: null,
  onDrawerExpand: null,
  onDrawerCollapse: null,
  onAfterDrawerExpand: null,
  onAfterDrawerCollapse: null,
  _expands: null,
  _keyCodes: {
    ENTER: 13,
    UP: 38,
    DOWN: 40,
    LEFT: 37,
    RIGHT: 39,
    ESCAPE: 27
  },
  _editingCount: 0,
  _lastClickTime: 0,
  _lastClickEl: null,
  _lastScreenX: 0,
  _touchStartTime: 0,
  _touchStartEl: null,
  _resizeEls: null,
  _resizingEl: null,
  _sizeColumnsRun: false,
  _onClickBound: null,
  _onChangeBound: null,
  _onFocusBound: null,
  _onBlurBound: null,
  _onAnimationEndBound: null,
  _onKeydownBound: null,
  _onTouchstartBound: null,
  _onTouchendBound: null,
  _onMouseDownBound: null,
  _onMouseMoveBound: null,
  _onMouseUpBound: null
};
var _default = Table;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/add-class":59,"../helpers/dom/has-class":61,"../helpers/dom/remove-class":67,"../helpers/dom/toggle-class":68,"../helpers/form/form-data":71,"../helpers/form/set-caret":72,"../helpers/traversal/get-index":86,"../helpers/traversal/get-parent":87,"../helpers/traversal/get-sibling-after":89,"../helpers/traversal/get-sibling-before":90,"../helpers/traversal/matches":92,"../helpers/util/each":94,"./base":3,"./expand":11,"@babel/runtime-corejs3/core-js-stable/array/from":107,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],40:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _transform = _interopRequireDefault(require("../helpers/css/transform"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _getParent = _interopRequireDefault(require("../helpers/traversal/get-parent"));
var _getIndex = _interopRequireDefault(require("../helpers/traversal/get-index"));
var _hasParent = _interopRequireDefault(require("../helpers/traversal/has-parent"));
var _getChildren = _interopRequireDefault(require("../helpers/traversal/get-children"));
var _breakpoint = require("../helpers/dom/breakpoint");
var _passiveEvents = _interopRequireDefault(require("../helpers/util/passive-events"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Tabs
                                                                                                                                                                                                                                                                                                                                              * Tabbed navigation
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Tabs(el, {
                                                                                                                                                                                                                                                                                                                                              *   // Optional. Alternate breakpoint values.
                                                                                                                                                                                                                                                                                                                                              *   breakpoints: {
                                                                                                                                                                                                                                                                                                                                              *    xs: {
                                                                                                                                                                                                                                                                                                                                              *      min: 0,
                                                                                                                                                                                                                                                                                                                                              *      max: 639
                                                                                                                                                                                                                                                                                                                                              *    }
                                                                                                                                                                                                                                                                                                                                              *    // ...
                                                                                                                                                                                                                                                                                                                                              *  }
                                                                                                                                                                                                                                                                                                                                              * });
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/tabs.js
                                                                                                                                                                                                                                                                                                                                              */
var Tabs = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(Tabs, _BaseComponent);
  var _super = _createSuper(Tabs);
  /**
   * Tabs constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function Tabs(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Tabs);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    _this._determineSize();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Set the active item.
   * @param {String|Number|Object} el
   */
  (0, _createClass2.default)(Tabs, [{
    key: "setActive",
    value: function setActive(el) {
      var panel;

      // Get the scrolling containers dimensions and coordinates particularly if we are still initializing
      if (!this.scrollRect) {
        this.scrollRect = this.tabListScrollEl.getBoundingClientRect();
      }

      // If we're passed a string instead of an element or number,
      // get the panel with that id.
      if (typeof el === 'string') {
        panel = this._findPanelByName(el);

        // If we've found a panel, find the corresponding tab.
        if (panel) {
          el = this._findTabByPanel(panel);
        }
      }

      // If we're passed a number instead of an element,
      // get that item from the tabEls NodeList
      if (typeof el === 'number') {
        el = this.tabEls.item(el);
      }

      // If we couldn't find the element or it's already active, stop.
      if (!el || (0, _typeof2.default)(el) !== 'object' || el === this.activeTabEl) {
        return false;
      }

      // Remove the active class from the currently active tab
      if (this.activeTabEl) {
        (0, _toggleClass.default)(this.activeTabEl, 'active', false);

        // Remove the aria-selected attribute from the old tab
        this.activeTabEl.querySelector('a').removeAttribute('aria-selected');
        this.previousTabEl = this.activeTabEl;
      }

      // Add the active class and store.
      (0, _toggleClass.default)(el, 'active', true);

      // Add the aria-selected attribute to the new tab
      el.querySelector('a').setAttribute('aria-selected', 'true');
      this.activeTabEl = el;

      // Get dimensions and coordinates of the active tab
      var elRect = el.getBoundingClientRect();

      // If the active tab is not in full view, determine how to bring it into full view
      if (!(elRect.left >= this.scrollRect.left && this.scrollRect.right >= elRect.right)) {
        if (elRect.left < this.scrollRect.left) {
          this.focus(el, 'left');
        }
        if (this.scrollRect.right < elRect.right) {
          this.focus(el, 'right');
        }
      }

      // If we don't already have a panel, find the panel that corresponds to this tab.
      if (!panel) {
        panel = this._findPanelByTab(el);
      }

      // Set the new panel to be active.
      (0, _toggleClass.default)(panel, 'active', true);

      // Set aria-hidden attribute to false for this panel
      panel.setAttribute('aria-hidden', 'false');

      // Remove the active class from the currently active panel.
      if (this.activePanelEl) {
        (0, _toggleClass.default)(this.activePanelEl, 'active', false);

        // Set aria-hidden attribute to true for this panel
        this.activePanelEl.setAttribute('aria-hidden', 'true');
      }

      // Store the new active panel
      this.activePanelEl = panel;

      // Set the hash
      if (this.useHash) {
        window.location.hash = this.activePanelEl.getAttribute('id') || '';
      }
      var e = document.createEvent('Event');
      e.initEvent('spark.visible-children', true, true);
      this.activePanelEl.dispatchEvent(e);
      return this;
    }

    /**
     * Start the drag
     * @param {Object} params
     */
  }, {
    key: "start",
    value: function start(params) {
      params = params || {};

      // Start dragging
      this.isDragging = true;

      // Stash the element and its position
      this.lastX = params.lastX;
      this.lastY = params.lastY;

      // Stash the min and max values
      this._determineMinMax();

      // Add listeners to the body so we can drag this thing anywhere and still get events
      this._addMoveEventListeners(params.type || 'mouse');
      return this;
    }

    /**
     * Stop the drag
     * @param {Object} params
     */
  }, {
    key: "stop",
    value: function stop(params) {
      params = params || {};

      // Make sure we're in bounds
      this._checkX();

      // Stop dragging
      this.isDragging = false;
      this.scrollDistance = 0;

      // Reset the scroll direction
      this.scrollDirection = '';

      // Unbind event listeners on the body
      this._removeMoveEventListeners(params.type);
      return this;
    }

    /**
     * Move the drag point
     * @param {Object} params
     */
  }, {
    key: "move",
    value: function move(params) {
      // Make sure we're currently dragging
      if (!this.isDragging && !params.scroll && !params.force) {
        return this;
      }

      // If we're beyond the bounds, add some resistance to the scroll.
      if (!params.force && (this.x + params.x > this.maxX || this.x + params.x < this.minX)) {
        this.x += params.x / 4;
      } else {
        this.x += params.x;
      }
      this.scrollDistance += Math.abs(params.x);
      if (params.scroll) {
        this._checkX();
      }
      this._updatePosition();
      return this;
    }

    /**
     * Focus on a specific element by bringing it to the middle of the scroller.
     * @param {Element} el
     * @param {String} align Which side to align with.
     */
  }, {
    key: "focus",
    value: function focus(el, align) {
      var elRect = el.getBoundingClientRect();
      align = align || 'left';
      this._getPageDirection();
      if (this.pageDirection === 'rtl') {
        this.x = align === 'left' ? -(this.scrollRect.left - elRect.left - this.x) : elRect.right - this.scrollRect.right;
      } else {
        this.x = align === 'left' ? this.scrollRect.left - elRect.left : -(elRect.right - this.scrollRect.right - this.x);
      }
      this._checkX();
      this._updatePosition();
      return this;
    }

    /**
     * Remove the element from the DOM and prepare for garbage collection by dereferencing values.
     * @param {Boolean} leaveElement Leave the element intact.
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      this._removeMoveEventListeners('touch');
      this._removeMoveEventListeners('mouse');
      this._removeMoveEventListeners('keyboard');
      return (0, _get2.default)((0, _getPrototypeOf2.default)(Tabs.prototype), "remove", this).call(this, leaveElement);
    }

    /**
     * Update the elements used.
     * @param {Element} el Optional
     */
  }, {
    key: "update",
    value: function update(el) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(Tabs.prototype), "update", this).call(this, el);

      // Run on the next frame so sizes have updated
      setTimeout(function () {
        this._determineSize();
        this.focus(this.activeTabEl);
      }.bind(this), 0);
      return this;
    }

    /**
     * Find a panel element by name.
     * @param {String} name
     * @return {Object|Null}
     */
  }, {
    key: "_findPanelByName",
    value: function _findPanelByName(name) {
      name = name.replace('#', '');
      var i = 0;
      var len = this.panelEls.length;
      var found = null;
      var el;
      for (; i < len && !found; i++) {
        if (this.panelEls[i].getAttribute('id') === name) {
          el = this.panelEls[i];
          found = true;
        }
      }
      return found && el;
    }

    /**
     * Find a panel given its corresponding tab. Try to match based on the
     * id attribute, but fall back to matching based on index.
     * @param {Object} tab
     * @return {Object|Null}
     */
  }, {
    key: "_findPanelByTab",
    value: function _findPanelByTab(tab) {
      var anchorChild = tab.querySelector('a');
      var id = anchorChild && anchorChild.getAttribute('href');
      var index = (0, _getIndex.default)(tab.parentNode.children, tab);
      var i = 0;
      var len = this.panelEls.length;
      var foundById = null;
      var idMatch = null;
      var indexMatch = null;
      if (id) {
        id.replace('#', '');
      }
      for (; i < len && !foundById; i++) {
        if (id && this.panelEls[i].getAttribute('id') === id) {
          foundById = true;
          idMatch = this.panelEls[i];
        } else if (i === index) {
          indexMatch = this.panelEls[i];
        }
      }
      return foundById && idMatch || indexMatch;
    }

    /**
     * Find a tab given its corresponding panel. Try to match based on the
     * [href] attribute, but fall back to matching based on index.
     * @param {Object} panel
     * @return {Object|Null}
     */
  }, {
    key: "_findTabByPanel",
    value: function _findTabByPanel(panel) {
      var id = panel.getAttribute('id');
      var index = (0, _getIndex.default)(panel.parentNode.children, panel);
      var i = 0;
      var len = this.tabEls.length;
      var foundById = null;
      var idMatch = null;
      var indexMatch = null;
      for (; i < len && !foundById; i++) {
        if (id && (this.tabEls.item(i).querySelector('a').getAttribute('href') === '#' + id || this.tabEls.item(i).getAttribute('href') === '#' + id)) {
          foundById = true;
          idMatch = this.tabEls.item(i);
        } else if (i === index) {
          indexMatch = this.tabEls.item(i);
        }
      }
      return foundById && idMatch || indexMatch;
    }

    /**
     * Find the tab which an element lives inside.
     * @param {Element} el
     * @return {Object}
     */
  }, {
    key: "_findTabByChildElement",
    value: function _findTabByChildElement(el) {
      var i = 0;
      var len = this.tabEls.length;
      var found;
      var tab;
      for (; i < len && !found; i++) {
        // There is a chance that the element passed IS a tab. Or maybe a tab is its parent.
        if (this.tabEls.item(i) === el || (0, _hasParent.default)(el, this.tabEls.item(i))) {
          found = true;
          tab = this.tabEls.item(i);
        }
      }
      return found && tab;
    }

    /**
     * Store a reference to the tabs list, each tab and each panel.
     * Set which tab is active, or use the first.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.tabListEl = this.el.querySelector('.spark-tabs__list');
      this.tabListScrollEl = this.tabListEl.parentNode;
      this.tabEls = this.tabListEl.querySelectorAll('.spark-tabs__tab');
      this.panelEls = (0, _getChildren.default)(this.el.querySelector('.spark-tabs__panels'), '[role="tabpanel"]');
      this.navEl = this.el.querySelector('.spark-tabs__nav');
      this.leftEl = this.navEl.querySelector('.spark-tabs__btn--left');
      this.rightEl = this.navEl.querySelector('.spark-tabs__btn--right');

      // Make sure we have the elements we need
      if (!this.tabListEl || !this.tabEls.length || !this.panelEls.length) {
        throw new Error('Tab element missing either a .spark-tabs__list, or elements with .spark-tabs__tab and .spark-tabs__panel!', this.el);
      }

      // Determine size early incase the initial active tab is one that would be out of view
      this._determineSize();

      // If there is a hash set, use that to try and set the active panel
      var hashSet = window.location.hash && this.setActive(window.location.hash);

      // If we weren't able to set with a hash, find the tab marked active or default to the first tab
      if (!hashSet) {
        this.setActive(this.tabListEl.querySelector('.spark-tabs__tab.active') || 0);
      }
    }

    /**
     * Get and store the page's direction, whether left-to-right or right-to-left
     */
  }, {
    key: "_getPageDirection",
    value: function _getPageDirection() {
      this.pageDirection = window.getComputedStyle(this.el, "").getPropertyValue('direction');
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onResizeBound = this._onResize.bind(this);
      this._onTabListClickBound = this._onTabListClick.bind(this);
      this._onClickBound = this._onClick.bind(this);
      this._onTouchStartBound = this._onTouchStart.bind(this);
      this._onTouchMoveBound = this._onTouchMove.bind(this);
      this._onTouchEndBound = this._onTouchEnd.bind(this);
      this._onMouseDownBound = this._onMouseDown.bind(this);
      this._onMouseMoveBound = this._onMouseMove.bind(this);
      this._onMouseUpBound = this._onMouseUp.bind(this);
      this._onScrollBound = this._onScroll.bind(this);
      this._onFocusBound = this._onFocus.bind(this);
      this._onBlurBound = this._onBlur.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      var passiveEvents = (0, _passiveEvents.default)();
      window.addEventListener('resize', this._onResizeBound);
      window.addEventListener('orientationchange', this._onResizeBound);
      this.tabListEl.addEventListener('click', this._onTabListClickBound);
      this.tabListEl.addEventListener('touchstart', this._onTouchStartBound, passiveEvents ? {
        passive: false
      } : false);
      this.tabListEl.addEventListener('mousedown', this._onMouseDownBound);
      this.tabListEl.addEventListener('mousewheel', this._onScrollBound, passiveEvents ? {
        passive: false
      } : false);
      this.tabListEl.addEventListener('DOMMouseScroll', this._onScrollBound);
      this.tabListEl.addEventListener('focus', this._onFocusBound, true);
      this.tabListEl.addEventListener('blur', this._onBlurBound, true);
      if (this.leftEl) {
        this.leftEl.addEventListener('click', this._onClickBound);
      }
      if (this.rightEl) {
        this.rightEl.addEventListener('click', this._onClickBound);
      }
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      window.removeEventListener('resize', this._onResizeBound);
      window.removeEventListener('orientationchange', this._onResizeBound);
      this.tabListEl.removeEventListener('click', this._onTabListClickBound);
      this.tabListEl.removeEventListener('touchstart', this._onTouchStartBound);
      this.tabListEl.removeEventListener('mousedown', this._onMouseDownBound);
      this.tabListEl.removeEventListener('mousewheel', this._onScrollBound);
      this.tabListEl.removeEventListener('DOMMouseScroll', this._onScrollBound);
      this.tabListEl.removeEventListener('focus', this._onFocusBound);
      this.tabListEl.removeEventListener('blur', this._onBlurBound);
      if (this.leftEl) {
        this.leftEl.removeEventListener('click', this._onClickBound);
      }
      if (this.rightEl) {
        this.rightEl.removeEventListener('click', this._onClickBound);
      }
    }

    /**
     * Add event listeners for touchmove, touchend, mousemove and mouseup.
     * We add these to the window so that the user can move off of the element
     * but keep dragging the tabs.
     * @param {String} type Which type of listeners to add
     */
  }, {
    key: "_addMoveEventListeners",
    value: function _addMoveEventListeners(type) {
      // Only listen for events of the type we asked for.
      switch (type) {
        case 'mouse':
          window.addEventListener('mousemove', this._onMouseMoveBound);
          window.addEventListener('mouseup', this._onMouseUpBound);
          break;
        case 'touch':
          window.addEventListener('touchmove', this._onTouchMoveBound);
          window.addEventListener('touchend', this._onTouchEndBound);
          break;
      }
    }

    /**
     * Remove event listeners for move events.
     * @param {String} type Which type of listeners to remove
     */
  }, {
    key: "_removeMoveEventListeners",
    value: function _removeMoveEventListeners(type) {
      // Only unbind events of the type we asked for.
      switch (type) {
        case 'mouse':
          window.removeEventListener('mousemove', this._onMouseMoveBound);
          window.removeEventListener('mouseup', this._onMouseUpBound);
          break;
        case 'touch':
          window.removeEventListener('touchmove', this._onTouchMoveBound);
          window.removeEventListener('touchend', this._onTouchEndBound);
          break;
      }
    }

    /**
     * Determine which size class to set on the element. This is a way of using breakpoint-like
     * logic for the tabs. We can't rely on real breakpoints because there is no guarantee that
     * the tabs will be the width of the window.
     * Also determine if we should be showing navigation arrows.
     */
  }, {
    key: "_determineSize",
    value: function _determineSize() {
      var width = this.el.clientWidth;
      var bp = (0, _breakpoint.get)(width, this.breakpoints);

      // If the found breakpoint is different than the current breakpoint, set the proper state.
      if (this.currentBreakpoint !== bp) {
        (0, _toggleClass.default)(this.el, this.currentBreakpoint, false);
        this.currentBreakpoint = bp;
        (0, _toggleClass.default)(this.el, this.currentBreakpoint, true);
      }

      // Get the scrolling container's current dimensions incase they changed with browser resizing
      this.scrollRect = this.tabListScrollEl.getBoundingClientRect();

      // If the tab list is wider than the scroll container, set the scrollable class.
      this.isScrollable = this.tabListEl.clientWidth > this.scrollRect.width;
      (0, _toggleClass.default)(this.navEl, 'scrollable', this.isScrollable);

      // Because dimensions have changed with the addition of the scrollable class,
      // we need to re-fetch dimensions and coordinates of the scrolling container
      if (this.isScrollable) {
        this.scrollRect = this.tabListScrollEl.getBoundingClientRect();
      }
      this._determineMinMax();
    }

    /**
     * Determine the min and max values for the slider.
     */
  }, {
    key: "_determineMinMax",
    value: function _determineMinMax() {
      if (!this.tabListEl || !this.tabListScrollEl) {
        return;
      }
      this.maxX = 0;
      this.minX = this.scrollRect.width - this.tabListEl.clientWidth - this.maxX;
    }

    /**
     * Enable the animation state.
     */
  }, {
    key: "_enableAnimation",
    value: function _enableAnimation() {
      this.isAnimatable = true;
      (0, _toggleClass.default)(this.navEl, 'no-animation', !this.isAnimatable);
    }

    /**
     * Disable the animation state.
     */
  }, {
    key: "_disableAnimation",
    value: function _disableAnimation() {
      this.isAnimatable = false;
      (0, _toggleClass.default)(this.navEl, 'no-animation', !this.isAnimatable);
    }

    /**
     * Update the position of the tabs.
     */
  }, {
    key: "_updatePosition",
    value: function _updatePosition() {
      this._getPageDirection();
      if (this.pageDirection === 'rtl') {
        this.tabListEl.setAttribute('style', (0, _transform.default)('translate', -this.x + 'px'));
      } else {
        this.tabListEl.setAttribute('style', (0, _transform.default)('translate', this.x + 'px'));
      }
    }

    /**
     * Check the x position
     */
  }, {
    key: "_checkX",
    value: function _checkX() {
      if (this.x < this.minX) {
        this.x = this.minX;
        this._updatePosition();
      }
      if (this.x > 0) {
        this.x = 0;
        this._updatePosition();
      }
    }

    /**
     * When the user clicks on a tab, make it active.
     * @param {Object} e
     */
  }, {
    key: "_onTabListClick",
    value: function _onTabListClick(e) {
      // Make sure we haven't scrolled.
      if (this.scrollDistance > 5) {
        e.preventDefault();
        return;
      }
      var tab;

      // Find if one of our tab elements is in the path
      if (tab = this._findTabByChildElement(e.target)) {
        e.preventDefault();
        this.setActive(tab);
      }
    }

    /**
     * When the window resizes, determine the size we should be using for tabs.
     * @param {Object} e
     */
  }, {
    key: "_onResize",
    value: function _onResize() {
      this._determineSize();
      this.focus(this.activeTabEl);
    }

    /**
     * When the touchstart event fires, start the scrolling process
     * @param {Object} e
     */
  }, {
    key: "_onTouchStart",
    value: function _onTouchStart(e) {
      if (!this.isScrollable) {
        return;
      }

      // Disable the animation class so we scroll smoothly
      this._disableAnimation();
      this.start({
        lastX: e.touches[0].clientX,
        lastY: e.touches[0].clientY,
        type: 'touch'
      });
    }

    /**
     * As the user continues moving the touch, determine
     * if we should move.
     * @param {Object} e
     */
  }, {
    key: "_onTouchMove",
    value: function _onTouchMove(e) {
      var xDistance = e.touches[0].clientX - this.lastX;
      var yDistance = e.touches[0].clientY - this.lastY;

      // If we haven't yet determined a scroll direction
      if (!this.scrollDirection) {
        // Moving up and down
        if (Math.abs(yDistance) > Math.abs(xDistance)) {
          this.scrollDirection = 'ns';

          // Moving side to side
        } else {
          this.scrollDirection = 'ew';
        }
      }

      // If We're moving left to right, start the move.
      if (this.scrollDirection === 'ew') {
        e.preventDefault();
        this._getPageDirection();
        xDistance = this.pageDirection === 'rtl' ? -xDistance : xDistance;
        this.move({
          x: xDistance
        });
      }
      this.lastX = e.touches[0].clientX;
      this.lastY = e.touches[0].clientY;
    }

    /**
     * When the touch is over.
     * @param {Object} e
     */
  }, {
    key: "_onTouchEnd",
    value: function _onTouchEnd() {
      // Enable the animation class
      this._enableAnimation();

      // Stop after one frame so that animation is fully reenabled
      window.setTimeout(function () {
        this.stop({
          type: 'touch'
        });
      }.bind(this), 1);
    }

    /**
     * When the mousedown event fires, start the scrolling process
     * @param {Object} e
     */
  }, {
    key: "_onMouseDown",
    value: function _onMouseDown(e) {
      if (!this.isScrollable) {
        return;
      }

      // Disable the animation class so we scroll smoothly
      this._disableAnimation();
      this.start({
        lastX: e.clientX,
        lastY: e.clientY,
        type: 'mouse'
      });
    }

    /**
     * As the user continues moving the mouse, determine
     * if we should move.
     * @param {Object} e
     */
  }, {
    key: "_onMouseMove",
    value: function _onMouseMove(e) {
      var xDistance = e.clientX - this.lastX;
      var yDistance = e.clientY - this.lastY;

      // If we haven't yet determined a scroll direction
      if (!this.scrollDirection) {
        // Moving up and down
        if (Math.abs(yDistance) > Math.abs(xDistance)) {
          this.scrollDirection = 'ns';

          // Moving side to side
        } else {
          this.scrollDirection = 'ew';
        }
      }

      // If We're moving left to right, start the move.
      if (this.scrollDirection === 'ew') {
        e.preventDefault();
        this._getPageDirection();
        xDistance = this.pageDirection === 'rtl' ? -xDistance : xDistance;
        this.move({
          x: xDistance
        });
      }
      this.lastX = e.clientX;
      this.lastY = e.clientY;
    }

    /**
     * When the mouse move is complete.
     * @param {Object} e
     */
  }, {
    key: "_onMouseUp",
    value: function _onMouseUp() {
      // If we haven't been dragging, get outta here!
      if (!this.isDragging) {
        return;
      }

      // Enable the animation class
      this._enableAnimation();

      // Stop after one frame so that animation is fully reenabled
      window.setTimeout(function () {
        this.stop({
          type: 'mouse'
        });
      }.bind(this), 1);
    }

    /**
     * When the user scrolls horizontally on the tabs, slide.
     * @param {Object} e
     */
  }, {
    key: "_onScroll",
    value: function _onScroll(e) {
      // Don't bother if we aren't scrollable
      if (!this.isScrollable) {
        return;
      }

      // Disable the animation class so we scroll smoothly
      this._disableAnimation();

      // Allow for Firefox's wheel detail
      var val = e.wheelDeltaX || -e.detail * 40;

      // If the scroll has moved...
      if (val) {
        // Supress native
        e.preventDefault();
        this._getPageDirection();
        val = this.pageDirection === 'rtl' ? -val : val;

        // Move us to the new position
        this.move({
          x: val,
          scroll: true
        });
      }

      // Cancel an existing scroll timer
      if (this.scrollTimer) {
        window.clearTimeout(this.scrollTimer);
        this.scrollTimer = null;
      }

      // The scroll is considered "done" after 100ms
      this.scrollTimer = window.setTimeout(this._onScrollEnd.bind(this), 100);
    }

    /**
     * When the scrolling ends, reset the scrollTop
     */
  }, {
    key: "_onScrollEnd",
    value: function _onScrollEnd() {
      // Enable the animation class
      this._enableAnimation();

      // Stop after one frame so that animation is fully reenabled
      window.setTimeout(function () {
        this.stop({
          type: 'scroll'
        });
      }.bind(this), 1);
    }

    /**
     * Determine which direction to scroll based on direction property and button clicked
     * @param {Object} e
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      if ((0, _hasClass.default)(e.target, 'spark-tabs__btn--left')) {
        this._onLeftClick();
      }
      if ((0, _hasClass.default)(e.target, 'spark-tabs__btn--right')) {
        this._onRightClick();
      }
    }

    /**
     * Slide tabs to the right on click of the "visual" left button
     */
  }, {
    key: "_onLeftClick",
    value: function _onLeftClick() {
      this.move({
        x: this.scrollRect.width,
        force: true
      });
      this.stop({
        type: 'force'
      });
    }

    /**
     * Slide tabs to the left on click of the "visual" right button
     */
  }, {
    key: "_onRightClick",
    value: function _onRightClick() {
      this.move({
        x: -this.scrollRect.width,
        force: true
      });
      this.stop({
        type: 'force'
      });
    }

    /**
     * When focus is gained on a tab.
     * @param {Object} e
     */
  }, {
    key: "_onFocus",
    value: function _onFocus(e) {
      var target = e.target || e.srcElement;
      var parent = (0, _getParent.default)(target, '.spark-tabs__tab', this.tabListEl);
      if (parent) (0, _addClass.default)(parent, 'focus');
    }

    /**
     * When focus is lost on a tab.
     * @param {Object} e
     */
  }, {
    key: "_onBlur",
    value: function _onBlur(e) {
      var target = e.target || e.srcElement;
      var parent = (0, _getParent.default)(target, '.spark-tabs__tab', this.tabListEl);
      if (parent) (0, _removeClass.default)(parent, 'focus');
    }
  }]);
  return Tabs;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
Tabs.prototype._whitelistedParams = ['useHash', 'breakpoints'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
Tabs.prototype.defaults = {
  el: null,
  tabListEl: null,
  tabListScrollEl: null,
  tabEls: null,
  panelEls: null,
  activeTabEl: null,
  activePanelEl: null,
  navEl: null,
  leftEl: null,
  rightEl: null,
  useHash: false,
  isScrollable: false,
  isDragging: false,
  isAnimatable: false,
  scrollDirection: '',
  scrollDistance: 0,
  lastX: 0,
  lastY: 0,
  minX: 0,
  maxX: 0,
  x: 0,
  _onFocusBound: null,
  _onBlurBound: null,
  _onTabListClickBound: null,
  _onLeftClickBound: null,
  _onRightClickBound: null,
  _onResizeBound: null,
  _onTouchStartBound: null,
  _onTouchMoveBound: null,
  _onTouchEndBound: null,
  _onMouseDownBound: null,
  _onMouseMoveBound: null,
  _onMouseUpBound: null,
  _onScrollBound: null
};
var _default = Tabs;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/css/transform":56,"../helpers/dom/add-class":59,"../helpers/dom/breakpoint":60,"../helpers/dom/has-class":61,"../helpers/dom/remove-class":67,"../helpers/dom/toggle-class":68,"../helpers/traversal/get-children":85,"../helpers/traversal/get-index":86,"../helpers/traversal/get-parent":87,"../helpers/traversal/has-parent":91,"../helpers/util/passive-events":99,"./base":3,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155,"@babel/runtime-corejs3/helpers/typeof":162}],41:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _typeahead = _interopRequireDefault(require("./typeahead"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _mixin = _interopRequireDefault(require("../helpers/util/mixin"));
var _messaging = _interopRequireDefault(require("../mixins/messaging"));
var _validation = _interopRequireDefault(require("../mixins/validation"));
var _makeElement = _interopRequireDefault(require("../helpers/dom/make-element"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # TextInput
                                                                                                                                                                                                                                                                                                                                              * A text input container.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new TextInput(el, {
                                                                                                                                                                                                                                                                                                                                              *   // Optional. Callback for when the input value changes.
                                                                                                                                                                                                                                                                                                                                              *   onChange(value, inputInstance) {}
                                                                                                                                                                                                                                                                                                                                              * });
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/text-input.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var TextInput = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(TextInput, _BaseComponent);
  var _super = _createSuper(TextInput);
  /**
   * TextInput constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function TextInput(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, TextInput);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    _this._createTypeahead();
    if (_this.inputEl.value) {
      _this.show();
      _this._onInput();
    }
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Show the input by adding the active state and setting character counts (if necessary).
   */
  (0, _createClass2.default)(TextInput, [{
    key: "show",
    value: function show() {
      this.isActive = true;
      this._updateClass();
      return this;
    }

    /**
     * Hide the input by removing the active state.
     */
  }, {
    key: "hide",
    value: function hide() {
      this.isActive = false;
      this._updateClass();
      return this;
    }

    /**
     * Set the value of the input.
     * @param {Mixed} value
     */
  }, {
    key: "setValue",
    value: function setValue(value) {
      if (this.typeahead) {
        this.typeahead.setValue(value);
      } else {
        this.inputEl.value = value;
        if (value) {
          this.show();
        } else {
          this.hide();
        }
      }
      return this;
    }

    /**
     * Get the value of the input.
     * @return {String}
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return this.inputEl.value;
    }

    /**
     * Clear the value of the input.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      if (this.typeahead) this.typeahead.clear();else this.inputEl.value = '';
      return this;
    }

    /**
     * Disable the input.
     */
  }, {
    key: "disable",
    value: function disable() {
      if (this.typeahead) this.typeahead.disable();else this.inputEl.setAttribute('disabled', '');
      return this;
    }

    /**
     * Enable the input.
     */
  }, {
    key: "enable",
    value: function enable() {
      if (this.typeahead) this.typeahead.enable();else this.inputEl.removeAttribute('disabled');
      return this;
    }

    /**
     * Remove.
     * @param {Boolean} leaveElement
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      if (this.typeahead) this.typeahead.remove(leaveElement);
      return (0, _get2.default)((0, _getPrototypeOf2.default)(TextInput.prototype), "remove", this).call(this, leaveElement);
    }

    /**
     * Update the element in use and the position.
     * @param {Element} el
     */
  }, {
    key: "update",
    value: function update(el) {
      if (this.typeahead) this.typeahead.remove();
      return (0, _get2.default)((0, _getPrototypeOf2.default)(TextInput.prototype), "update", this).call(this, el);
    }

    /**
     * Create the typeahead instance.
     */
  }, {
    key: "_createTypeahead",
    value: function _createTypeahead() {
      if (this.typeahead === true || this.inputEl.getAttribute('data-typeahead') !== null) {
        this.typeahead = new _typeahead.default(this.el, {
          onBlur: this._onBlurBound
        });
      }
    }

    /**
     * Store a reference to the needed elements.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.inputEl = this.el.querySelector('input, textarea');
      this.passwordToggleEl = this.el.querySelector('.spark-input__password-toggle');
      if (!this.inputEl) {
        throw new Error('No <input> or <textarea> element present in input container!', this.el);
      }
      this.messageEl = this.el.querySelector('.spark-input__message') || (0, _makeElement.default)('<span class="spark-input__message"></span>');
      this.clearEl = this.el.querySelector('.spark-input__clear');
    }

    /**
     * Parse parameters from the elements.
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      this.validatePattern = this.validatePattern || this.inputEl.getAttribute('data-validate');
      this.type = this.inputEl.getAttribute('type') || 'text';
      this.showCharacters = this.el.getAttribute('data-characters') !== null ? true : false;
      this.showCharactersRemaining = this.el.getAttribute('data-characters-remaining') !== null ? true : false;
      this.maxlength = this.inputEl.getAttribute('maxlength') || this.inputEl.getAttribute('data-maxlength-soft') || null;
      this.isTextarea = this.inputEl.nodeName.toLowerCase() === 'textarea' ? true : false;
      this.isActive = this.inputEl.value ? true : false;
    }

    /**
     * Set the characters count attribute.
     */
  }, {
    key: "_setCharactersCount",
    value: function _setCharactersCount() {
      if (this.showCharacters) {
        this.el.setAttribute('data-characters', this.inputEl.value.length);
      } else if (this.showCharactersRemaining) {
        var remaining = this.maxlength - this.inputEl.value.length;
        this.el.setAttribute('data-characters-remaining', remaining);
        if (remaining < 1) {
          this.el.setAttribute('data-characters-remaining-danger', true);
        } else {
          this.el.removeAttribute('data-characters-remaining-danger');
        }
      }
    }

    /**
     * Set the height of the textarea so that it doesn't scroll.
     */
  }, {
    key: "_setTextareaHeight",
    value: function _setTextareaHeight() {
      var style = window.getComputedStyle(this.inputEl);
      var borders = parseInt(style.borderTopWidth, 10) + parseInt(style.borderBottomWidth, 10);
      this.inputEl.style.height = null;
      var height = this.inputEl.scrollHeight;
      var lines;

      // No height, most likely the element is invisible. Get a rough
      // approximation of height so we have something.
      if (!height) {
        lines = this.inputEl.innerHTML.split('\n');
        height = Math.max(parseFloat(style.lineHeight)) * lines.length + parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
      }
      this.inputEl.style.height = height + borders + 'px';
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onFocusBound = this._onFocus.bind(this);
      this._onBlurBound = this._onBlur.bind(this);
      this._onInputBound = this._onInput.bind(this);
      this._onTogglePasswordViewHideBound = this._onTogglePasswordViewHide.bind(this);
      this._onClearClickBound = this._onClearClick.bind(this);
    }

    /**
     * Add event listeners for focus, blur, input, and click.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.inputEl.addEventListener('focus', this._onFocusBound);
      this.inputEl.addEventListener('blur', this._onBlurBound);
      this.inputEl.addEventListener('input', this._onInputBound);
      if (this.passwordToggleEl) {
        this.passwordToggleEl.addEventListener('click', this._onTogglePasswordViewHideBound);
        this.passwordToggleEl.addEventListener('keyup', this._onTogglePasswordViewHideBound);
      }
      if (this.clearEl) {
        this.clearEl.addEventListener('click', this._onClearClickBound);
      }
    }

    /**
     * Remove event listeners for focus, blur and input.
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.inputEl.removeEventListener('focus', this._onFocusBound);
      this.inputEl.removeEventListener('blur', this._onBlurBound);
      this.inputEl.removeEventListener('input', this._onInputBound);
      if (this.passwordToggleEl) {
        this.passwordToggleEl.removeEventListener('click', this._onTogglePasswordViewHideBound);
        this.passwordToggleEl.removeEventListener('keyup', this._onTogglePasswordViewHideBound);
      }
      if (this.clearEl) {
        this.clearEl.removeEventListener('click', this._onClearClickBound);
      }
    }

    /**
     * Update the active class.
     */
  }, {
    key: "_updateClass",
    value: function _updateClass() {
      (0, _toggleClass.default)(this.el, 'active', this.isActive);
    }

    /**
     * When the input element gains focus.
     * @param {Object} e
     */
  }, {
    key: "_onFocus",
    value: function _onFocus() {
      // Fix issue in IE where onFocus is triggered after onBlur for inputs using Typeahead
      if (document.activeElement !== this.inputEl) return;
      this.show();
      this._setCharactersCount();
      (0, _toggleClass.default)(this.el, 'focus', true);
      (this.onFocus || noop)(this.inputEl.value, this);
    }

    /**
     * When the input element loses focus.
     * @param {Object} e
     */
  }, {
    key: "_onBlur",
    value: function _onBlur() {
      if (!this.inputEl.value) {
        this.hide();
      }
      (0, _toggleClass.default)(this.el, 'focus', false);
      (this.onBlur || noop)(this.inputEl.value, this);
    }

    /**
     * When the value is about to change, run the validation, set the characters count
     * and resize if we're a textarea.
     * @param {Object} e
     */
  }, {
    key: "_onInput",
    value: function _onInput() {
      this.validate();
      this._setCharactersCount();
      if (this.isTextarea) {
        this._setTextareaHeight();
      }
      (this.onChange || noop)(this.inputEl.value, this);
    }

    /**
     * When a clear button is clicked, empty the field.
     * @param {Object} e
     */
  }, {
    key: "_onClearClick",
    value: function _onClearClick() {
      this.inputEl.value = '';
      this.hide();
      (this.onChange || noop)(this.inputEl.value, this);
    }

    /**
     * Toggle the current type value (text/password) of password input.
     * @param {Object} e
     */
  }, {
    key: "_onTogglePasswordViewHide",
    value: function _onTogglePasswordViewHide(e) {
      e.preventDefault();

      // Toggle password example code used a tabindex focusable span which is not actionable by default
      if (e.type === "click" || e.type === "keyup" && (e.keyCode === 13 || e.keyCode === 32)) {
        this.inputEl.setAttribute('type', this.inputEl.getAttribute('type') === 'password' ? 'text' : 'password');
      }
    }
  }]);
  return TextInput;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
TextInput.prototype._whitelistedParams = ['validate', 'validatePattern', 'onValidate', 'onChange', 'onFocus', 'onBlur'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
TextInput.prototype.defaults = {
  el: null,
  messageEl: null,
  inputEl: null,
  passwordToggleEl: null,
  clearEl: null,
  isActive: false,
  isTextarea: false,
  validatePattern: false,
  type: null,
  showCharacters: false,
  showCharactersRemaining: false,
  maxlength: null,
  typeahead: null,
  onValidate: noop,
  onChange: noop,
  onFocus: noop,
  onBlur: noop,
  _onFocusBound: null,
  _onBlurBound: null,
  _onInputBound: null,
  _onTogglePasswordViewHideBound: null,
  _onClearClickBound: null
};
(0, _mixin.default)(TextInput.prototype, _messaging.default, _validation.default);
var _default = TextInput;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/make-element":62,"../helpers/dom/toggle-class":68,"../helpers/util/mixin":96,"../mixins/messaging":104,"../mixins/validation":105,"./base":3,"./typeahead":50,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],42:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/includes"));
var _startsWith = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/starts-with"));
var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/slicedToArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _timeSet = _interopRequireDefault(require("./time-set"));
var _pad = _interopRequireDefault(require("../helpers/util/pad"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _appendChildren = _interopRequireDefault(require("../helpers/manipulation/append-children"));
var _triggerEvent = _interopRequireDefault(require("../helpers/dom/trigger-event"));
var _each = _interopRequireDefault(require("../helpers/util/each"));
var _parseAttribute = require("../helpers/dom/parse-attribute");
var _makeElement = _interopRequireDefault(require("../helpers/dom/make-element"));
var _mixin = _interopRequireDefault(require("../helpers/util/mixin"));
var _time = require("../helpers/time/time.js");
var _messaging = _interopRequireDefault(require("../mixins/messaging"));
var _validation = _interopRequireDefault(require("../mixins/validation"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Time Text Input
                                                                                                                                                                                                                                                                                                                                              * A time text input container.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new TimeInput(el, {
                                                                                                                                                                                                                                                                                                                                              *   // Optional. Callback for when the input value changes.
                                                                                                                                                                                                                                                                                                                                              *   onChange(value, inputInstance) {}
                                                                                                                                                                                                                                                                                                                                              * });
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/time-input.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var TimeInput = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(TimeInput, _BaseComponent);
  var _super = _createSuper(TimeInput);
  /**
   * TextInput constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function TimeInput(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, TimeInput);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._initializeInputs();
    _this._updateClass();
    _this._addEventListeners();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Store a reference to the needed elements.
   * @param {Element} el
   */
  (0, _createClass2.default)(TimeInput, [{
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.inputEl = this.el.querySelector('[type="time"]');
      this.messageEl = this.el.querySelector('.spark-input__message') || (0, _makeElement.default)('<span class="spark-input__message"></span>');
      if (!this.inputEl) {
        throw new Error('No <input> element present in input container!', this.el);
      }
    }

    /**
     * Parse parameters from the elements.
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      this.isActive = this.isActive !== null ? this.isActive : this.inputEl.value ? true : false;
      this.timeFormat = this.timeFormat !== null ? this.timeFormat : (0, _parseAttribute.string)(this.inputEl, 'data-time-format', '12');
      this.hourAriaLabel = this.hourAriaLabel !== null ? this.hourAriaLabel : 'Please enter hour';
      this.minuteAriaLabel = this.minuteAriaLabel !== null ? this.minuteAriaLabel : 'Please enter minutes';
      this.periodAriaLabel = this.periodAriaLabel !== null && this.timeFormat === '12' ? this.periodAriaLabel : 'Please enter a.m. or p.m.';
      this.currValue = this.inputEl.value !== null ? this.inputEl.value : null;
    }

    /**
     * Setup the group of typeahead fields.
     */
  }, {
    key: "_initializeInputs",
    value: function _initializeInputs() {
      this._initializeInputPieces();
      this._runTypeaheads();
    }

    /**
     * Replace the time input with a group of typeaheads.
     * Keep the time input around and store the typeahead data in there in an ISO date format.
     */
  }, {
    key: "_initializeInputPieces",
    value: function _initializeInputPieces() {
      // Hide the original element. This will be updated as the typeahead values change
      this.inputEl.style.display = 'none';
      var els = [];

      // Create the parts needed for the individual time fields
      this.timeParts = [{
        "name": "hour",
        "value": "12",
        "length": 2,
        "format": "\\d\\d"
      }, {
        "name": "divider",
        "value": ":",
        "length": 1
      }, {
        "name": "minute",
        "value": "00",
        "length": 2,
        "format": "\\d\\d"
      }];

      // If in 12hr format, add the additional fields needed for a.m./p.m.
      if (this.timeFormat === '12') {
        this.timeParts.push({
          "name": "divider",
          "value": " ",
          "length": 1
        }, {
          "name": "period",
          "value": "a.m.",
          "length": 4,
          "format": "\\D\\D\\D\\D"
        });
      }

      // Create a new typeahead for each part of the parsed format, and add placeholder elements
      this.timeParts.forEach(function (part) {
        this._initializeTypeaheadPiece(els, part);
      }, this);

      // Create a holder for all the pieces
      this.piecesEl = document.createElement('span');
      this.piecesEl.className = 'spark-input__fields';

      // Add all the necessary elements
      (0, _appendChildren.default)(this.piecesEl, els);

      // Add handlers to maintain focus if a specific input field is clicked. If a delimiter is clicked select the next closest input
      els.forEach(function (part) {
        if ((0, _hasClass.default)(part, 'spark-input')) {
          part.addEventListener('click', function (e) {
            part.querySelector('input').focus();
            e.preventDefault();
          });
        }
      });

      // Add the pieces holder
      this.el.insertBefore(this.piecesEl, this.inputEl);

      // Set the value
      if (this.inputEl.value) {
        var val = this.timeFormat === '12' ? (0, _time.convertTimeTo12Hr)(this.inputEl.value) : this.inputEl.value;
        var _val$split = val.split(':'),
          _val$split2 = (0, _slicedToArray2.default)(_val$split, 2),
          hours = _val$split2[0],
          minutes = _val$split2[1];
        var period;
        if ((0, _includes.default)(minutes).call(minutes, 'a.m.') || (0, _includes.default)(minutes).call(minutes, 'p.m.')) {
          period = minutes.substr(minutes.length - 4);
          minutes = minutes.substr(0, minutes.length - 4);
        }
        var values = {
          hour: hours,
          minute: minutes
        };
        if (this.timeFormat === '12') values.period = period;
        this.setValue(values);
        this.isActive = true;
      }
    }

    /**
     * Create a typeahead or placeholder piece.
     * @param {Array} els
     * @param {Object} part
     */
  }, {
    key: "_initializeTypeaheadPiece",
    value: function _initializeTypeaheadPiece(els, part) {
      this.typeaheads = this.typeaheads || {};
      this.typeaheadEls = this.typeaheadEls || [];
      var el;
      switch (part.name) {
        case 'hour':
        case 'minute':
        case 'period':
          this.typeaheads[part.name] = new _timeSet.default({
            type: part.name,
            placeholder: part.value,
            len: part.length,
            format: part.format,
            timeFormat: this.timeFormat,
            hourAriaLabel: this.hourAriaLabel,
            minuteAriaLabel: this.minuteAriaLabel,
            periodAriaLabel: this.periodAriaLabel,
            onFocus: this._onTypeaheadFocusBound,
            onBlur: this._onTypeaheadBlurBound,
            onInput: this._onTypeaheadInputBound,
            onBackspace: this._onTypeaheadBackspaceBound,
            onEnd: this._onTypeaheadEndBound
          });
          el = this.typeaheads[part.name].typeahead.el;
          this.typeaheadEls.push(el);
          break;
        default:
          el = document.createElement('span');
          el.innerHTML = part.value;
          el.className = 'spark-input__divider';
          break;
      }
      els.push(el);
    }

    /**
     * Update the active and focus classes.
     */
  }, {
    key: "_updateClass",
    value: function _updateClass() {
      (0, _toggleClass.default)(this.el, 'active', this.isActive);
      (0, _toggleClass.default)(this.el, 'focus', this.inFocus ? true : false);
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because them.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onTypeaheadFocusBound = this._onTypeaheadFocus.bind(this);
      this._onTypeaheadInputBound = this._onTypeaheadInput.bind(this);
      this._onTypeaheadBackspaceBound = this._onTypeaheadBackspace.bind(this);
      this._onTypeaheadEndBound = this._onTypeaheadEnd.bind(this);
      this._onTypeaheadBlurBound = this._onTypeaheadBlur.bind(this);
      this._onVisibleChildrenBound = this._onVisibleChildren.bind(this);
      this._onInputChangeBound = this._onInputChange.bind(this);
    }

    /**
     * Add event listeners.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.inputEl.addEventListener('change', this._onInputChangeBound);
      document.addEventListener('spark.visible-children', this._onVisibleChildrenBound, true);
    }

    /**
     * Remove event listeners.
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.inputEl.removeEventListener('change', this._onInputChangeBound);
      document.removeEventListener('spark.visible-children', this._onVisibleChildrenBound, true);
    }

    /**
     * Handle the spark.visible-children event.
     * @param {Object} e
     */
  }, {
    key: "_onVisibleChildren",
    value: function _onVisibleChildren(e) {
      var _this2 = this;
      if (e.target.contains(this.el)) {
        setTimeout(function () {
          _this2.update();
        }, 0);
      }
    }

    /**
     * Show the input by adding the active state and setting character counts (if necessary).
     */
  }, {
    key: "show",
    value: function show() {
      if (!this.isActive) {
        this._runTypeaheads();
        this.isActive = true;
        this._updateClass();
      }
      return this;
    }

    /**
     * Hide the input by removing the active state.
     */
  }, {
    key: "hide",
    value: function hide() {
      if (!this.isActive) return this;
      this.isActive = false;
      this._updateClass();
      return this;
    }

    /**
     * Get the value of the input.
     * @return {String}
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return this.inputEl.value;
    }

    /**
     * Given an object with hour, minute and period, set the value of the input.
     * @param {Object} values
     */
  }, {
    key: "setValue",
    value: function setValue(values) {
      values = values || {
        hour: '',
        minute: '',
        period: ''
      };
      var i;
      var hadValue;
      for (i in this.typeaheads) {
        if (values[i] !== undefined) {
          this.typeaheads[i].setValue(values[i]);
          hadValue = hadValue || (values[i] ? true : false);
        }
      }
      if (!this.isActive && hadValue) {
        this.isActive = true;
      }
      this._padTypeaheads();
      this._updateClass();
      this.updateInput();
      return this;
    }

    /**
     * Clear the values.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      (0, _each.default)(this.typeaheads, function (k, v) {
        v.clearValue();
      });
      this.inputEl.value = '';
      return this;
    }

    /**
     * Disable the inputs.
     */
  }, {
    key: "disable",
    value: function disable() {
      (0, _each.default)(this.typeaheads, function (k, v) {
        v.disable();
      });
      this.inputEl.setAttribute('disabled', '');
      (0, _toggleClass.default)(this.el, 'disabled', true);
      return this;
    }

    /**
     * Enable the inputs.
     */
  }, {
    key: "enable",
    value: function enable() {
      (0, _each.default)(this.typeaheads, function (k, v) {
        v.enable();
      });
      this.inputEl.removeAttribute('disabled');
      (0, _toggleClass.default)(this.el, 'disabled', false);
      return this;
    }

    /**
     * Augment default remove call w/ helper cleanup.
     * @param {Boolean} leaveElement Leave the element intact.
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      this._removeTypeaheads(leaveElement);
      this._removeInputPieces();
      (0, _get2.default)((0, _getPrototypeOf2.default)(TimeInput.prototype), "remove", this).call(this, leaveElement);
      return this;
    }

    /**
     * Update the input values to match the typeaheads.
     */
  }, {
    key: "updateInput",
    value: function updateInput() {
      var inputs;
      if (this.typeaheads) {
        inputs = this.typeaheads;
      }
      if (inputs) {
        var hour = inputs.hour.getValue(true);
        var minute = inputs.minute.getValue(true).toString();
        var period;
        if (this.timeFormat === '12') {
          period = inputs.period.getValue().toLowerCase();
          if (hour === 12 && period === 'a.m.') {
            hour = 0;
          } else if (hour >= 0 && hour < 12 && period === 'p.m.') {
            hour += 12;
          }
        }
        hour = hour.toString();
        var val = this.inputEl.value;

        // Set the value for the input if we have the necessary pieces
        if (this.timeFormat === '12' && hour !== '' && minute !== '' && period !== '') {
          this.inputEl.value = (0, _pad.default)(hour, 2) + ':' + (0, _pad.default)(minute, 2);
        } else if (this.timeFormat === '24' && hour !== '' && minute !== '') {
          this.inputEl.value = (0, _pad.default)(hour, 2) + ':' + (0, _pad.default)(minute, 2);
        } else {
          this.inputEl.value = '';
        }
        if (val !== this.inputEl.value) {
          this._pauseInputChange = true;
          (0, _triggerEvent.default)(this.inputEl, 'change');
          (this.onChange || noop)(this.inputEl.value, this);
          this._pauseInputChange = false;
        }
      }
      this.currValue = this.inputEl.value;
      return this;
    }

    /**
     * Get current typing value.
     */
  }, {
    key: "getTypingValue",
    value: function getTypingValue() {
      var inputs;
      var result = '';
      if (this.typeaheads) {
        inputs = this.typeaheads;
      }
      if (inputs) {
        var hour = inputs.hour.getValue(true);
        var minute = inputs.minute.getValue(true);
        var period = '';
        if (this.timeFormat === '12') {
          period = inputs.period.getValue();
        }
        result = hour.toString() + minute.toString() + period.toString();
      }
      return result;
    }

    /**
     * Move the focus to a typeahead element.
     * @param {Number} i
     * @param {String} character Optional A character to add.
     */
  }, {
    key: "focus",
    value: function focus(i, character) {
      if (!this.isActive || !this.inFocus) {
        return this;
      }
      var index = this.typeaheadEls.indexOf(this.inFocus.typeahead.el);
      var sib = this.typeaheadEls[index + i];
      var typeahead;

      // If we were passed a character to prepend, find the typeahead for this element
      if (character) {
        typeahead = this._getTypeaheadByElement(sib);
        if (typeahead) {
          // If this is the period field we need to ensure that only allowed characters can be entered
          if (typeahead.type === 'period') {
            if (character.toLowerCase() === 'a' || character.toLowerCase() === 'p') {
              typeahead.typeahead.addCharacterAtIndex(character, 0);
            }
          } else {
            typeahead.typeahead.addCharacterAtIndex(character, 0);
          }
        }
      }
      if (!sib) {
        return false;
      }
      var sibInput = sib.querySelector('input');
      if (sibInput) {
        sibInput.focus();

        // If we have a typeahead (because we needed to prepend a character), move the caret
        if (typeahead) {
          typeahead.typeahead.moveCaret(1);
        }
      }
      return this;
    }

    /**
     * Move the focus to the next element.
     * @param {String} character Optional A character to add.
     */
  }, {
    key: "focusNext",
    value: function focusNext(character) {
      if (this.focus(1, character)) {
        if (this.inFocus && !character) {
          this.inFocus.typeahead.moveCaretToStart();
        }
      }
      return this;
    }

    /**
     * Move the focus to the next element.
     * @param {String} character Optional A character to add.
     */
  }, {
    key: "focusPrevious",
    value: function focusPrevious(character) {
      if (this.focus(-1, character)) {
        if (this.inFocus) this.inFocus.typeahead.moveCaretToEnd();
      }
      return this;
    }

    /**
     * Pad the typeahead input values.
     */
  }, {
    key: "_padTypeaheads",
    value: function _padTypeaheads() {
      if (this._pauseInputChange) return;
      this._pauseInputChange = true;
      for (var i in this.typeaheads) {
        this._padTypeahead(this.typeaheads[i]);
      }
      this._pauseInputChange = false;
    }

    /**
     * Pad the typeahead input values.
     * @param {Typeahead} typeahead
     */
  }, {
    key: "_padTypeahead",
    value: function _padTypeahead(typeahead) {
      var value = typeahead.getValue().toLowerCase();
      if (value) {
        if (typeahead.type === 'period') {
          var _context, _context2;
          if ((0, _startsWith.default)(_context = 'a.m.').call(_context, value) || (0, _startsWith.default)(_context2 = 'p.m.').call(_context2, value)) {
            value = (0, _concat.default)(value).call(value, 'a.m.'.substring(value.length));
            typeahead.setValue(value);
          }
        } else {
          var padded = (0, _pad.default)(value, typeahead.typeahead.format.length);
          if (value !== padded) typeahead.setValue((0, _pad.default)(value, typeahead.typeahead.format.length));
        }
      }
    }

    /**
     * Do any of the typeaheads have a value?
     * @return {Boolean}
     */
  }, {
    key: "_hasTypeaheadValue",
    value: function _hasTypeaheadValue() {
      for (var i in this.typeaheads) {
        if (this.typeaheads[i].getValue()) {
          this.isActive = true;
          return true;
        }
      }
      return false;
    }

    /**
     * Resize the elements, to account for any changed display property.
     * @param {Element} el Optional.
     */
  }, {
    key: "update",
    value: function update(el) {
      if (el) {
        this._removeTypeaheads();
        this._removeInputPieces();
        this._removeEventListeners();
        this._cacheElements(el);
        this._initializeInputs();
        this._updateClass();
        this._addEventListeners();
      } else {
        this._runTypeaheads();
      }
      return this;
    }

    /**
     * Remove the input pieces.
     */
  }, {
    key: "_removeInputPieces",
    value: function _removeInputPieces() {
      this.inputEl.style.display = '';

      // Remove elements we inserted into the DOM
      if (this.piecesEl) {
        this.piecesEl.parentNode.removeChild(this.piecesEl);
      }
    }

    /**
     * Remove typeaheads.
     * @param {Boolean} leaveElement Leave the element intact.
     */
  }, {
    key: "_removeTypeaheads",
    value: function _removeTypeaheads(leaveElement) {
      if (this.typeaheads) {
        for (var i in this.typeaheads) {
          this.typeaheads[i].remove(leaveElement);
        }
      }
    }

    /**
     * When the typeahead gains focus.
     * @param {Number} val
     * @param {Object} typeahead
     */
  }, {
    key: "_onTypeaheadFocus",
    value: function _onTypeaheadFocus(val, typeahead) {
      if (this.runningTypeaheads) return;
      if (!this._hasFocus) {
        this._hasFocus = true;
        (this.onFocus || noop)(this.inputEl.value, this);
      }
      (0, _triggerEvent.default)(this.inputEl, 'focus');
      this.inFocus = typeahead;
      this.show();
      this._updateClass();
      if (this._blurTimer) {
        clearTimeout(this._blurTimer);
        this._blurTimer = null;
      }
    }

    /**
     * Run all typeaheads so they have placeholder values.
     */
  }, {
    key: "_runTypeaheads",
    value: function _runTypeaheads() {
      // Make sure we don't get into an infinite loop. Even though the logic
      // in the typeaheads should be stopping this from happening, there is
      // something in Safari where the focus and blur events fire in different
      // order than other browsers so those failsafes do not work.
      if (this.runningTypeaheads) {
        return;
      }
      this.runningTypeaheads = true;
      if (this.inFocus) {
        this.inFocus.pause();
      }
      for (var i in this.typeaheads) {
        if (this.typeaheads[i] !== this.inFocus) {
          this.typeaheads[i].run();
        }
      }
      if (this.inFocus) {
        this.inFocus.resume();
        this.inFocus.run();
      }
      this.runningTypeaheads = false;
    }

    /**
     * Get the typeahead that corresponds to the given element.
     * @param {Element} el
     * @return {Object}
     */
  }, {
    key: "_getTypeaheadByElement",
    value: function _getTypeaheadByElement(el) {
      for (var i in this.typeaheads) {
        if (this.typeaheads[i].typeahead.el === el) {
          return this.typeaheads[i];
        }
      }
    }

    /**
     * When the typeahead loses focus, make sure numbers are padded properly.
     * @param {Number} val
     * @param {Object} typeahead
     */
  }, {
    key: "_onTypeaheadBlur",
    value: function _onTypeaheadBlur(val, typeahead) {
      if (this.runningTypeaheads) return;
      this.inFocus = null;
      this._padTypeahead(typeahead);
      this.updateInput();
      if (!this.inputEl.value && !this._hasTypeaheadValue()) {
        this.hide();
      }
      this._updateClass();
      this._blurTimer = setTimeout(function () {
        this._hasFocus = false;
        (this.onBlur || noop)(this.inputEl.value, this);
      }.bind(this), 1);
    }

    /**
     * `input` event callback for typeahead.
     */
  }, {
    key: "_onTypeaheadInput",
    value: function _onTypeaheadInput() {
      (this.onInput || noop)(this.getTypingValue(), this);
    }

    /**
     * When the typeahead fires a backspace event, move back to the previous input.
     * @param {Number} val
     * @param {Object} typeahead
     */
  }, {
    key: "_onTypeaheadBackspace",
    value: function _onTypeaheadBackspace() {
      this.focusPrevious();
    }

    /**
     * When the typeahead is at its maximum length and the caret is at the end,
     * focus on the next input field.
     * @param {Object} typeahead
     * @param {String} character Optional
     */
  }, {
    key: "_onTypeaheadEnd",
    value: function _onTypeaheadEnd(typeahead, character) {
      this.focusNext(character);
    }

    /**
     * When the input that corresponds to this instance changes. Allows us to listen
     * and respond to changes made by other components (Calendar Popover, for example).
     * @param {Object} e
     */
  }, {
    key: "_onInputChange",
    value: function _onInputChange(e) {
      this.isActive = e.target.value ? true : false;
      this._updateClass();
      if (this._pauseInputChange) return;
      this.setValue(e.target.value);
      (this.onChange || noop)(this.inputEl.value, this);
    }
  }]);
  return TimeInput;
}(_base.default);
/**
* Whitelisted parameters which can be set on construction.
* @type {Array}
*/
TimeInput.prototype._whitelistedParams = ['onChange', 'onFocus', 'onBlur', 'validate', 'onValidate', 'timeFormat', 'hourAriaLabel', 'minuteAriaLabel', 'periodAriaLabel'];

/**
* Default values for internal properties we will be setting.
* These are set on each construction so we don't leak properties
* into the prototype chain.
* @type {Object}
*/
TimeInput.prototype.defaults = {
  el: null,
  inputEl: null,
  messageEl: null,
  piecesEl: null,
  timeParts: null,
  hourAriaLabel: null,
  minuteAriaLabel: null,
  periodAriaLabel: null,
  isActive: null,
  inFocus: null,
  timeFormat: null,
  onChange: null,
  onInput: null,
  onFocus: null,
  onBlur: null,
  typeaheads: null,
  typeaheadEls: null,
  runningTypeaheads: false,
  onValidate: null,
  _blurTimer: null,
  _hasFocus: false,
  _pauseInputChange: false,
  _onTypeaheadFocusBound: null,
  _onTypeaheadInputBound: null,
  _onTypeaheadBackspaceBound: null,
  _onTypeaheadEndBound: null,
  _onTypeaheadBlurBound: null,
  _onVisibleChildrenBound: null,
  _onInputChangeBound: null
};
(0, _mixin.default)(TimeInput.prototype, _messaging.default, _validation.default);
var _default = TimeInput;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/has-class":61,"../helpers/dom/make-element":62,"../helpers/dom/parse-attribute":66,"../helpers/dom/toggle-class":68,"../helpers/dom/trigger-event":69,"../helpers/manipulation/append-children":73,"../helpers/time/time.js":83,"../helpers/util/each":94,"../helpers/util/mixin":96,"../helpers/util/pad":98,"../mixins/messaging":104,"../mixins/validation":105,"./base":3,"./time-set":44,"@babel/runtime-corejs3/core-js-stable/instance/concat":108,"@babel/runtime-corejs3/core-js-stable/instance/includes":112,"@babel/runtime-corejs3/core-js-stable/instance/starts-with":118,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155,"@babel/runtime-corejs3/helpers/slicedToArray":157}],43:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/values"));
var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/includes"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/slicedToArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _rangeSlider = _interopRequireDefault(require("./range-slider"));
var _timeInput = _interopRequireDefault(require("./time-input"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _getIndex = _interopRequireDefault(require("../helpers/traversal/get-index"));
var _makeElement = _interopRequireDefault(require("../helpers/dom/make-element"));
var _modulo = _interopRequireDefault(require("../helpers/util/modulo"));
var _parseAttribute = require("../helpers/dom/parse-attribute");
var _time = require("../helpers/time/time.js");
var _debounce = _interopRequireDefault(require("../helpers/util/debounce"));
var _mixin = _interopRequireDefault(require("../helpers/util/mixin"));
var _validation = _interopRequireDefault(require("../mixins/validation"));
var _messaging = _interopRequireDefault(require("../mixins/messaging"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Time Range Slider
                                                                                                                                                                                                                                                                                                                                              * A dual slider for Time inputs.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new TimeRangeSlider(el, {
                                                                                                                                                                                                                                                                                                                                              *   // Optional. Slide along the x or y-axis?
                                                                                                                                                                                                                                                                                                                                              *   isX: true,
                                                                                                                                                                                                                                                                                                                                              *   onChange: function(inst, index, value){},
                                                                                                                                                                                                                                                                                                                                              * });
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/time-range-slider.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var TimeRangeSlider = /*#__PURE__*/function (_RangeSlider) {
  (0, _inherits2.default)(TimeRangeSlider, _RangeSlider);
  var _super = _createSuper(TimeRangeSlider);
  /**
   * TimeRangeSlider constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function TimeRangeSlider(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, TimeRangeSlider);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._initTypeaheads();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Start the slider moving.
   * @param {Number} index The index of the handle or input element.
   * @param {Number} position The position of the pointer.
   * @param {String} type Optional Which type of events to listen for.
   */
  (0, _createClass2.default)(TimeRangeSlider, [{
    key: "start",
    value: function start(index, position, type) {
      // Noop if we're disabled or an invalid index was passed
      if (index < 0 || this.inputEls[index].querySelector('[type="time"]').getAttribute('disabled') !== null) {
        return this;
      }
      this._addMoveEventListeners(type || 'mouse');
      this._cacheSize();
      this.isActive = this.isActive || [];
      this.isActive[index] = true;
      this.currentIndex = index;
      this._updateActiveClasses(index);
      this._updateDisabledClasses();
      this._oldVal = (0, _values.default)(this)[index];
      this.move(position);
      return this;
    }

    /**
     * Store a reference to the slider and its associated elements.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.controlsEl = this.el.querySelector('.spark-slider__controls');
      this.inputEls = this.el.querySelectorAll('.spark-time');
      this.handleEls = this.el.querySelectorAll('.spark-slider__handle');
      this.trackEl = this.el.querySelector('.spark-slider__track');
      this.trackFillEl = this.trackEl.querySelector('.spark-slider__track-fill');
      this.messageEl = this.el.querySelector('.spark-slider__message') || (0, _makeElement.default)('<span class="spark-slider__message"></span>');
      if (!this.inputEls || this.inputEls.length <= 1) {
        throw new Error('Tried to create a slider instance without two text inputs.');
      }
      if (!this.handleEls || this.handleEls.length <= 1) {
        throw new Error('Tried to create a slider instance without two handle buttons.');
      }
    }

    /**
     * Parse parameters from the elements and set initial values and handle positions.
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      var lowestMin = Infinity;
      var highestMax = -Infinity;
      var values = [];
      this.mins = [];
      this.maxes = [];
      this.steps = [];
      this.valuePrecision = [];
      this.typeaheads = [];
      this.timeFormat = this.timeFormat !== null ? this.timeFormat : (0, _parseAttribute.string)(this.el, 'data-time-format', '12');
      this.customAriaLabels = this.customAriaLabels !== null ? this.customAriaLabels : null;

      // Cache the size of the element so that we can properly set values on handles.
      this._cacheSize();

      // Set the minimum and max values for each element. Also set any predefined value.
      for (var i = 0, numInputs = this.inputEls.length; i < numInputs; i++) {
        // Parse and set min
        var parsedMin = this.inputEls[i].querySelector('[type="time"]').getAttribute('min');
        if (parsedMin === null) {
          // Set to 12:00 a.m. in minutes
          this.mins[i] = 0;
        } else {
          if (!(0, _time.isValidTime)(parsedMin) && this.timeFormat !== (0, _time.isValidTime)(parsedMin)) {
            throw new Error('The provided min time is not valid. Please refer to the Time Selector documentation for accepted time notations.');
          }
          this.mins[i] = (0, _time.convertTimeToMinutes)(parsedMin);
        }

        // Parse and set max
        var parsedMax = this.inputEls[i].querySelector('[type="time"]').getAttribute('max');
        if (parsedMax === null) {
          // Set to 11:59 p.m. in minutes
          this.maxes[i] = 1439;
        } else {
          if (!(0, _time.isValidTime)(parsedMax) && this.timeFormat !== (0, _time.isValidTime)(parsedMax)) {
            throw new Error('The provided max time is not valid. Please refer to the Time Selector documentation for accepted time notations.');
          }
          this.maxes[i] = (0, _time.convertTimeToMinutes)(parsedMax);
        }

        // Step should be in minutes, hence an integer. Will defaut to 60 minutes if not provided
        this.steps[i] = parseInt(this.inputEls[i].querySelector('[type="time"]').getAttribute('step')) || 60;

        // Default precision for Integers
        this.valuePrecision[i] = 1;
        if (this.mins[i] < lowestMin) {
          lowestMin = this.mins[i];
        }
        if (this.maxes[i] > highestMax) {
          highestMax = this.maxes[i];
        }
      }
      this.lowestMin = lowestMin;
      this.highestMax = highestMax;

      // If we have a default value, set it. Otherwise resort to min and max
      for (var _i = 0, _numInputs = this.inputEls.length; _i < _numInputs; _i++) {
        values[_i] = this.inputEls[_i].querySelector('[type="time"]').getAttribute('value');
        if (values[_i] === null) {
          if (_i + 1 === _numInputs) {
            this.setValue(_i, this.maxes[_i] !== null ? this.maxes[_i] : 0);
          } else {
            this.setValue(_i, this.mins[_i] !== null ? this.mins[_i] : 0);
          }
        } else {
          this.setValue(_i, values[_i]);
        }
      }
    }

    /**
     * Enable the Slider handles and inputs.
     * @param {Number} index
     */
  }, {
    key: "enable",
    value: function enable(index) {
      // We don't have an input element at that index, so something went wrong.
      if (!this.typeaheads[index] || !this.handleEls[index]) {
        throw new Error('Cannot find a slider input element with an index of ' + index + '. That element does not exist.');
      }
      this.typeaheads[index].enable();
      this.handleEls[index].removeAttribute('disabled');
      this.handleEls[index].removeAttribute('tabindex');
      this._updateDisabledClasses();
      return this;
    }

    /**
     * Disable the Slider handles and inputs.
     * @param {Number} index
     */
  }, {
    key: "disable",
    value: function disable(index) {
      // We don't have an input element at that index, so something went wrong.
      if (!this.typeaheads[index] || !this.handleEls[index]) {
        throw new Error('Cannot find a slider input element with an index of ' + index + '. That element does not exist.');
      }
      this.typeaheads[index].disable();
      this.handleEls[index].setAttribute('disabled', '');
      this.handleEls[index].setAttribute('tabindex', '-1');
      this._updateDisabledClasses();
      return this;
    }

    /**
     * Update which handles are disabled.
     */
  }, {
    key: "_updateDisabledClasses",
    value: function _updateDisabledClasses() {
      var disabledCount = 0;
      for (var i = 0, len = this.inputEls.length; i < len; i++) {
        var timeInput = this.inputEls[i].querySelector('[type="time"]');
        if (timeInput.getAttribute('disabled') !== null) {
          (0, _toggleClass.default)(this.handleEls[i], 'disabled', true);
          disabledCount++;
        } else {
          (0, _toggleClass.default)(this.handleEls[i], 'disabled', false);
        }
      }
      (0, _toggleClass.default)(this.el, 'all-disabled', disabledCount === this.handleEls.length);
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onTouchStartBound = this._onTouchStart.bind(this);
      this._onTouchMoveBound = this._onTouchMove.bind(this);
      this._onTouchEndBound = this._onTouchEnd.bind(this);
      this._onClickBound = this._onClick.bind(this);
      this._onMouseDownBound = this._onMouseDown.bind(this);
      this._onMouseMoveBound = this._onMouseMove.bind(this);
      this._onMouseUpBound = this._onMouseUp.bind(this);
      this._onInputBlurBound = this._onInputBlur.bind(this);
      this._onInputChangeBound = this._onInputChange.bind(this);
      this._onFocusBound = this._onFocus.bind(this);
      this._onKeydownBound = this._onKeydown.bind(this);
      this._onBlurBound = this._onBlur.bind(this);
      this._onResizeBound = (0, _debounce.default)(this._onResize.bind(this), 90);
      this._onVisibleChildrenBound = this._onVisibleChildren.bind(this);
      this._onWindowClickBound = this._onWindowClick.bind(this);
    }

    /**
     * Add event listeners for touchstart and mouse click.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.controlsEl.addEventListener('touchstart', this._onTouchStartBound);
      this.controlsEl.addEventListener('mousedown', this._onMouseDownBound);
      for (var i = 0, len = this.handleEls.length; i < len; i++) {
        this.handleEls[i].addEventListener('focus', this._onFocusBound);
        this.handleEls[i].addEventListener('click', this._onClickBound);
      }
      document.addEventListener('spark.visible-children', this._onVisibleChildrenBound, true);
      window.addEventListener('resize', this._onResizeBound);
      window.addEventListener('orientationchange', this._onResizeBound);
      window.addEventListener('click', this._onWindowClickBound);
    }

    /**
     * Remove event listeners for touchstart and mouse click.
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.controlsEl.removeEventListener('touchstart', this._onTouchStartBound);
      this.controlsEl.removeEventListener('mousedown', this._onMouseDownBound);
      document.removeEventListener('spark.visible-children', this._onVisibleChildrenBound);
      for (var j = 0, len2 = this.handleEls.length; j < len2; j++) {
        this.handleEls[j].removeEventListener('focus', this._onFocusBound);
        this.handleEls[j].removeEventListener('click', this._onClickBound);
      }
      window.removeEventListener('resize', this._onResizeBound);
      window.removeEventListener('orientationchange', this._onResizeBound);
      window.removeEventListener('click', this._onWindowClickBound);
    }

    /**
     * Initialize the typeahead inputs.
     */
  }, {
    key: "_initTypeaheads",
    value: function _initTypeaheads() {
      if (this.inputEls) {
        for (var i = 0; i < this.inputEls.length; i++) {
          var hourAriaLabel = null;
          var minuteAriaLabel = null;
          var periodAriaLabel = null;
          if (this.customAriaLabels) {
            hourAriaLabel = this.customAriaLabels[i].hourAriaLabel;
            minuteAriaLabel = this.customAriaLabels[i].minuteAriaLabel;
            periodAriaLabel = this.customAriaLabels[i].periodAriaLabel;
            if (hourAriaLabel === '' || hourAriaLabel === undefined) {
              hourAriaLabel = null;
            }
            if (minuteAriaLabel === '' || minuteAriaLabel === undefined) {
              minuteAriaLabel = null;
            }
            if (periodAriaLabel === '' || periodAriaLabel === undefined) {
              periodAriaLabel = null;
            }
          }
          this.typeaheads[i] = new _timeInput.default(this.inputEls[i], {
            timeFormat: this.timeFormat,
            hourAriaLabel: hourAriaLabel,
            minuteAriaLabel: minuteAriaLabel,
            periodAriaLabel: periodAriaLabel,
            onBlur: this._onInputBlurBound,
            onChange: this._onInputChangeBound
          });
        }
      }
    }

    /**
     * Get the value as a valid time in desired format.
     * @param {Number} index
     */
  }, {
    key: "getValue",
    value: function getValue(index) {
      if (!this.inputEls[index]) {
        throw new Error('Cannot get value from a slider input element with an index of ' + index + '. That element does not exist.');
      }
      return (0, _time.convertMinutesToTime)((0, _values.default)(this)[index], this.timeFormat);
    }

    /**
     * Set the value of the handle.
     * @param {Number} index The index of the input element.
     * @param {Number} value
     */
  }, {
    key: "setValue",
    value: function setValue(index, value) {
      // We don't have an input element at that index, so something went wrong.
      if (!this.inputEls[index]) {
        throw new Error('Cannot set value on a slider input element with an index of ' + index + '. That element does not exist.');
      }
      if (isNaN(value)) {
        value = typeof value === 'string' && value !== '' ? (0, _time.convertTimeToMinutes)(value) : undefined;
      }

      // If the value is invalid due to invalid user input, set to the min to recover gracefully and not blow up the slider
      if (value === undefined) value = this.mins[index];

      // Move in increments if we have a defined step size
      if (this.steps[index]) {
        value = value - (0, _modulo.default)(value, this.steps[index]);
      }
      value = Math.round(value * this.valuePrecision[index]) / this.valuePrecision[index];
      this.values = (0, _values.default)(this) || [];

      // Check bounds of the new value
      if (value > this.maxes[index]) {
        value = this.maxes[index];
      } else if (value < this.mins[index]) {
        value = this.mins[index];
      }
      if ((0, _values.default)(this)[index + 1] !== undefined && value >= (0, _values.default)(this)[index + 1]) {
        value = (0, _values.default)(this)[index + 1] - (this.steps[index] || 1);
      } else if ((0, _values.default)(this)[index - 1] !== undefined && value <= (0, _values.default)(this)[index - 1]) {
        value = (0, _values.default)(this)[index - 1] + (this.steps[index] || 1);
      }

      // Store value
      (0, _values.default)(this)[index] = value;

      // Update elements
      var timeValue = [];
      timeValue['12'] = (0, _time.convertMinutesToTime)((0, _values.default)(this)[index], '12');
      timeValue['24'] = (0, _time.convertMinutesToTime)((0, _values.default)(this)[index]);
      this.inputEls[index].querySelector('[type="time"]').value = timeValue['24'];
      this.handleEls[index].setAttribute('data-value', timeValue[this.timeFormat]);
      this.handleEls[index].setAttribute('data-value-minutes', (0, _values.default)(this)[index]);
      this.handleEls[index].setAttribute('aria-valuenow', timeValue[this.timeFormat]);
      this.handleEls[index].setAttribute('aria-valuetext', timeValue[this.timeFormat]);

      // Update Typeaheads
      if (this.typeaheads[index] !== undefined) {
        var _timeValue$this$timeF = timeValue[this.timeFormat].split(':'),
          _timeValue$this$timeF2 = (0, _slicedToArray2.default)(_timeValue$this$timeF, 2),
          hours = _timeValue$this$timeF2[0],
          minutes = _timeValue$this$timeF2[1];
        var period;
        if ((0, _includes.default)(minutes).call(minutes, 'a.m.') || (0, _includes.default)(minutes).call(minutes, 'p.m.')) {
          period = minutes.substr(minutes.length - 4);
          minutes = minutes.substr(0, minutes.length - 4);
        }
        var values = {
          hour: hours,
          minute: minutes
        };
        if (this.timeFormat === '12') values.period = period;
        this.typeaheads[index].setValue(values);
      }

      // Set the percentage
      this.percentages = this.percentages || [];
      this.percentages[index] = ((0, _values.default)(this)[index] - this.lowestMin) / (this.highestMax - this.lowestMin);

      // Update the position of the handle
      this._updateHandlePosition(index);
      return this;
    }

    /**
     * When a key is pressed, see if it's one of the Arrow, Page up, Page down, Home
     * or End keys move the handle accordingly.
     * @param {Object} e
     */
  }, {
    key: "_onKeydown",
    value: function _onKeydown(e) {
      if ((0, _getIndex.default)(this.inputEls, e.target) !== -1) {
        return;
      }
      if (e.keyCode === 39 || e.keyCode === 38 || e.keyCode === 33) {
        // Right or Up arrow or Page Up
        this.increment(false);
      } else if (e.keyCode === 37 || e.keyCode === 40 || e.keyCode === 34) {
        // Left or down arrow
        this.decrement(false);
      } else if (e.keyCode === 35) {
        // End
        this.setValue(this.max);
      } else if (e.keyCode === 36) {
        // Home
        this.setValue(this.min);
      }
    }

    /**
     * When an input is blurred, update the slider values
     * @param {Number} val
     * @param {Object} inst An instance of a Time Input
     */
  }, {
    key: "_onInputBlur",
    value: function _onInputBlur(val, inst) {
      var index = (0, _getIndex.default)(this.inputEls, inst.el);
      this._updateDisabledClasses();
      if ((0, _time.convertTimeToMinutes)(inst.inputEl.value) !== (0, _values.default)(this)[index]) {
        this.setValue(index, inst.inputEl.value);
      }
      (this.onChange || noop)(index, (0, _time.convertMinutesToTime)((0, _values.default)(this)[index], this.timeFormat), this);
    }

    /**
     * When an input value is changed, update the slider values
     * @param {Number} val
     * @param {Object} inst An instance of a Time Input
     */
  }, {
    key: "_onInputChange",
    value: function _onInputChange(val, inst) {
      var index = (0, _getIndex.default)(this.inputEls, inst.el);
      this._updateDisabledClasses();
      if (inst.inputEl.value === '') {
        var minute = inst.typeaheads.minute.getValue(true);

        // If the minute field is emptied by the user, set it to 00
        if (minute === '' || minute === null) {
          inst.typeaheads.minute.setValue('00');
          inst.updateInput();
        }

        // If the period field is emptied by the user, set it to what it was before
        if (this.timeFormat === '12') {
          var period = inst.typeaheads.period.getValue();
          if (period === '' || period === null) {
            var oldValue = (0, _time.convertTimeTo12Hr)(inst.currValue);
            inst.typeaheads.period.setValue((0, _time.getTimePeriod)(oldValue));
            inst.updateInput();
          }
        }
      }
      if ((0, _time.convertTimeToMinutes)(inst.inputEl.value) !== (0, _values.default)(this)[index]) {
        this.setValue(index, inst.inputEl.value);
      }
      (this.onChange || noop)(index, (0, _time.convertMinutesToTime)((0, _values.default)(this)[index], this.timeFormat), this);
    }

    /**
     * Update the element and handle positions.
     * @param {Element} el
     */
  }, {
    key: "update",
    value: function update(el) {
      this._removeEventListeners();
      this._removeMoveEventListeners('touch');
      this._removeMoveEventListeners('mouse');
      this._removeMoveEventListeners('keyboard');
      this._cacheElements(el);
      this._parseParams();
      this._addEventListeners();
      this._updateDisabledClasses();
      for (var i = 0; i < this.handleEls.length; i++) {
        this._updateHandlePosition(i);
      }
      return this;
    }
  }]);
  return TimeRangeSlider;
}(_rangeSlider.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
TimeRangeSlider.prototype._whitelistedParams = ['validate', 'onValidate', 'onChange', 'timeFormat', 'customAriaLabels'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
TimeRangeSlider.prototype.defaults = {
  el: null,
  messageEl: null,
  controlsEl: null,
  inputEls: null,
  handleEls: null,
  trackEl: null,
  trackFillEl: null,
  isActive: null,
  isX: true,
  onValidate: null,
  onChange: null,
  position: 0,
  width: 0,
  height: 0,
  mins: null,
  maxes: null,
  steps: null,
  interval: null,
  values: null,
  percentages: null,
  offsetLeft: 0,
  offsetTop: 0,
  handleSizePercentage: 0,
  currentIndex: null,
  lastIndex: null,
  _oldVal: null,
  timeFormat: null,
  customAriaLabels: null,
  _onTouchStartBound: null,
  _onTouchMoveBound: null,
  _onTouchEndBound: null,
  _onMouseDownBound: null,
  _onMouseMoveBound: null,
  _onMouseUpBound: null,
  _onMouseOutBound: null,
  _onFocusBound: null,
  _onKeydownBound: null,
  _onBlurBound: null,
  _onResizeBound: null,
  _onClickBound: null,
  _onVisibleChildrenBound: null
};
(0, _mixin.default)(TimeRangeSlider.prototype, _messaging.default, _validation.default);
var _default = TimeRangeSlider;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/make-element":62,"../helpers/dom/parse-attribute":66,"../helpers/dom/toggle-class":68,"../helpers/time/time.js":83,"../helpers/traversal/get-index":86,"../helpers/util/debounce":93,"../helpers/util/mixin":96,"../helpers/util/modulo":97,"../mixins/messaging":104,"../mixins/validation":105,"./range-slider":32,"./time-input":42,"@babel/runtime-corejs3/core-js-stable/instance/includes":112,"@babel/runtime-corejs3/core-js-stable/instance/values":119,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155,"@babel/runtime-corejs3/helpers/slicedToArray":157}],44:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _timeTypeahead = _interopRequireDefault(require("./time-typeahead"));
var _parseAttribute = require("../helpers/dom/parse-attribute");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Time Set
                                                                                                                                                                                                                                                                                                                                              * Listen to an input element and format it as the user types.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new TimeSet(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/time-set.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
function createDefaultElement() {
  var el = document.createElement('span');
  el.className = 'spark-input';
  return el;
}
var TimeSet = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(TimeSet, _BaseComponent);
  var _super = _createSuper(TimeSet);
  /**
   * TimeSet constructor
   * @param {Element} el Optional
   * @param {Object} params Optional
   */
  function TimeSet(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, TimeSet);
    // If only one arg passed, assume it was a parameters
    // object since the user MUST provide those but the element
    // is optional. Doing it this way to keep the arity the same
    // as other components.
    if (arguments.length < 2) {
      params = el || {};
      el = createDefaultElement();
    }
    _this = _super.call(this, el, params);
    _this._bindEventListenerCallbacks();
    _this._createTypeahead(el, params);
    return _this;
  }

  /**
   * Create bound versions of event listener callbacks and store them.
   * Otherwise we can't unbind from these events later because the
   * function signatures won't match.
   */
  (0, _createClass2.default)(TimeSet, [{
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onTypeaheadChangeBound = this._onTypeaheadChange.bind(this);
      this._onTypeaheadInputBound = this._onTypeaheadInput.bind(this);
      this._onTypeaheadFocusBound = this._onTypeaheadFocus.bind(this);
      this._onTypeaheadBlurBound = this._onTypeaheadBlur.bind(this);
      this._onTypeaheadBackspaceBound = this._onTypeaheadBackspace.bind(this);
      this._onTypeaheadEndBound = this._onTypeaheadEnd.bind(this);
    }

    /**
     * Cache elements.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
    }

    /**
     * Parse parameters from the elements.
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      this.type = this.type !== null ? this.type : (0, _parseAttribute.string)(this.el, 'data-type', 'hour');
      this.format = this.format !== null ? this.format : (0, _parseAttribute.string)(this.el, 'data-format', null);
      this.placeholder = this.placeholder !== null ? this.placeholder : (0, _parseAttribute.string)(this.el, 'data-placeholder', null);
      this.len = this.len !== null ? this.len : (0, _parseAttribute.number)(this.el, 'length', null);
      this.timeFormat = this.timeFormat !== null ? this.timeFormat : (0, _parseAttribute.string)(this.el, 'data-time-format', '12');
      this.hourAriaLabel = this.hourAriaLabel !== null ? this.hourAriaLabel : null;
      this.minuteAriaLabel = this.minuteAriaLabel !== null ? this.minuteAriaLabel : null;
      this.periodAriaLabel = this.periodAriaLabel !== null && this.timeFormat === '12' ? this.periodAriaLabel : null;
      if (!this.format) {
        throw new Error('You must provide a format value for TimeSet.');
      }
      if (!this.placeholder) {
        throw new Error('You must provide a placeholder value for TimeSet.');
      }
    }

    /**
     * Get the value.
     * @param {Boolean} asInt Get the value as a parsed integer.
     * @return {Mixed}
     */
  }, {
    key: "getValue",
    value: function getValue(asInt) {
      return this.typeahead.getValue(asInt);
    }

    /**
     * Set the value.
     * @param {Mixed} val
     */
  }, {
    key: "setValue",
    value: function setValue(val) {
      return this.typeahead.setValue(val);
    }

    /**
     * Clear the value.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      return this.typeahead.clearValue();
    }

    /**
     * Enable the input.
     */
  }, {
    key: "enable",
    value: function enable() {
      return this.typeahead.enable();
    }

    /**
     * Disable the input.
     */
  }, {
    key: "disable",
    value: function disable() {
      return this.typeahead.disable();
    }

    /**
     * Run the typeahead calculations.
     */
  }, {
    key: "run",
    value: function run() {
      return this.typeahead.run();
    }

    /**
     * Pause the typeahead events.
     */
  }, {
    key: "pause",
    value: function pause() {
      return this.typeahead.pause();
    }

    /**
     * Reseume typeahead events.
     */
  }, {
    key: "resume",
    value: function resume() {
      return this.typeahead.resume();
    }

    /**
     * Augment default remove call w/ helper cleanup.
     * @param {Boolean} leaveElement Leave the element intact.
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      this.typeahead.remove(leaveElement);
      (0, _get2.default)((0, _getPrototypeOf2.default)(TimeSet.prototype), "remove", this).call(this, leaveElement);
      return this;
    }

    /**
     * Create a typeahead with the given format.
     * @param {Object} el
     */
  }, {
    key: "_createTypeahead",
    value: function _createTypeahead(el) {
      this.typeahead = new _timeTypeahead.default(el, {
        placeholder: this.placeholder,
        format: this.format,
        matchPlaceholderSize: true,
        onChange: this._onTypeaheadChangeBound,
        onInput: this._onTypeaheadInputBound,
        onFocus: this._onTypeaheadFocusBound,
        onBlur: this._onTypeaheadBlurBound,
        onBackspace: this._onTypeaheadBackspaceBound,
        onEnd: this._onTypeaheadEndBound
      });

      // Ensure we have an ARIA label
      var input = el.querySelector('input');
      if (!input.getAttribute('aria-label')) {
        var ariaLabel = '';
        switch (this.type) {
          case 'hour':
            ariaLabel = this.hourAriaLabel;
            break;
          case 'minute':
            ariaLabel = this.minuteAriaLabel;
            break;
          case 'period':
            ariaLabel = this.periodAriaLabel;
            break;
        }
        input.setAttribute('aria-label', ariaLabel);
      }
    }

    /**
     * When the typeahead changes, make sure the value is valid. This
     * is very basic validation. More complex validation like the number
     * of days in a specific month should be handled by the callback.
     * And run our callback.
     * @param {String} val The value of the input
     */
  }, {
    key: "_onTypeaheadChange",
    value: function _onTypeaheadChange(val) {
      if (this._checkValidity(val)) {
        (this.onChange || noop)(val, this);
      }
    }

    /**
     * Callback for `input` event
     * @param {String} val The value of the input
     *
     */
  }, {
    key: "_onTypeaheadInput",
    value: function _onTypeaheadInput(val) {
      (this.onInput || noop)(val, this);
    }

    /**
     * When the typeahead gains focus, let anyone who is interested know.
     * @param {String} val
     */
  }, {
    key: "_onTypeaheadFocus",
    value: function _onTypeaheadFocus(val) {
      (this.onFocus || noop)(val, this);
    }

    /**
     * When the typeahead loses focus, let anyone who is interested know.
     * @param {String} val
     */
  }, {
    key: "_onTypeaheadBlur",
    value: function _onTypeaheadBlur(val) {
      this._checkValidity(val, true);
      (this.onBlur || noop)(val, this);
    }

    /**
     * When the typeahead fires a backspace event because it's empty and
     * the user is hitting backspace, let anyone who is interested know.
     * @param {String} val
     */
  }, {
    key: "_onTypeaheadBackspace",
    value: function _onTypeaheadBackspace(val) {
      (this.onBackspace || noop)(val, this);
    }

    /**
     * When the typeahead is full and at its end, let anyone who is interested know.
     * @param {Object} typeahead
     * @param {String} character Optional The character to pass to the next input.
     */
  }, {
    key: "_onTypeaheadEnd",
    value: function _onTypeaheadEnd(typeahead, character) {
      (this.onEnd || noop)(this, character);
    }

    /**
     * Check to see if an input value is valid.
     * @param {Mixed} val
     * @param {Boolean} allowEmpty All the value to be empty instead of 0.
     */
  }, {
    key: "_checkValidity",
    value: function _checkValidity(val, allowEmpty) {
      if (this.type === 'period') {
        return;
      }
      val = parseInt(val, 10);
      var origVal = val;
      var isNumber = !isNaN(val);

      // Format time pieces to the appropriate values
      if (isNumber) {
        if (this.type === 'hour' && this.timeFormat === '12') {
          val = val ? Math.min(Math.max(val, 1), 12) : allowEmpty ? '' : 0;
        } else if (this.type === 'hour' && this.timeFormat === '24') {
          val = val ? Math.min(Math.max(val, 0), 23) : allowEmpty ? '' : 0;
        } else if (this.type === 'minute') {
          val = val ? Math.min(Math.max(val, 0), 59) : allowEmpty ? '' : 0;
        }
      }

      // Need to make sure we aren't looping forever on these updates.
      if (isNumber && val !== origVal) {
        if (this.type === 'minute' && origVal === 0 && val === '') {
          this.typeahead.setValue('00' + '');
        } else if (this.type === 'hour' && this.timeFormat === '24' && origVal === 0 && val === '') {
          this.typeahead.setValue('00' + '');
        } else {
          this.typeahead.setValue(val + '');
        }
        return false;
      }
      return true;
    }
  }]);
  return TimeSet;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
TimeSet.prototype._whitelistedParams = ['type', 'format', 'timeFormat', 'hourAriaLabel', 'minuteAriaLabel', 'periodAriaLabel', 'matchPlaceholderSize', 'placeholder', 'len', 'onChange', 'onInput', 'onFocus', 'onBlur', 'onBackspace', 'onEnd'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
TimeSet.prototype.defaults = {
  el: null,
  type: null,
  format: null,
  timeFormat: null,
  placeholder: null,
  len: null,
  hourAriaLabel: null,
  minuteAriaLabel: null,
  periodAriaLabel: null,
  typeahead: null,
  onChange: null,
  onInput: null,
  onFocus: null,
  onBlur: null,
  onBackspace: null,
  onEnd: null,
  _onTypeaheadChangeBound: null,
  _onTypeaheadInputBound: null,
  _onTypeaheadFocusBound: null,
  _onTypeaheadBlurBound: null,
  _onTypeaheadBackspaceBound: null,
  _onTypeaheadEndBound: null,
  matchPlaceholderSize: null
};
var _default = TimeSet;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/parse-attribute":66,"./base":3,"./time-typeahead":45,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],45:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _typeahead = _interopRequireDefault(require("./typeahead"));
var _triggerEvent = _interopRequireDefault(require("../helpers/dom/trigger-event"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Time Typeahead
                                                                                                                                                                                                                                                                                                                                              * Listen to an input element and format it as the user types.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new TimeTypeahead(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/time-typeahead.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var TimeTypeahead = /*#__PURE__*/function (_Typeahead) {
  (0, _inherits2.default)(TimeTypeahead, _Typeahead);
  var _super = _createSuper(TimeTypeahead);
  /**
   * Typeahead constructor
   * @param {Element} el
   * @param {Object} params
   */
  function TimeTypeahead(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, TimeTypeahead);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Run the formatting.
   * @param {Number} cursorIndex
   */
  (0, _createClass2.default)(TimeTypeahead, [{
    key: "run",
    value: function run(cursorIndex) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (this.isRunning) return this;
      this.isRunning = true;
      var oldVal = this.inputEl.value;
      var val = '';
      var placeholder = '';
      var len = this.format.length;
      var skipCount = 0;
      var valDone = false;
      for (var i = 0; i < len; i++) {
        // Add numbers, letters or placeholders
        if (this.format[i] === '\\d') {
          if (this.characters[i - skipCount]) {
            val += this.characters[i - skipCount];
          } else {
            valDone = true;
          }
          placeholder += valDone && this.placeholder[i] ? this.placeholder[i] : '&nbsp;';
        } else if (this.format[i] === '\\D') {
          if (this.characters[i - skipCount]) {
            val += this.characters[i - skipCount];
          } else {
            valDone = true;
          }
          placeholder += valDone && this.placeholder[i] ? this.placeholder[i] : '&nbsp;';
        } else {
          if (!valDone) {
            val += this.format[i];
          }
          placeholder += this.format[i];
          skipCount++;
        }
      }
      if (this.isFocused) {
        cursorIndex = cursorIndex === undefined ? this._getCaretEnd() : cursorIndex;
      }

      // If there are no characters, set the cursorIndex to be the last placeholder entry.
      if (this.isFocused && !this.characters.length) {
        cursorIndex = val.length;
      }

      // No characters and we shouldn't use just placeholder values
      if (!this.characters.length && params.notOnlyPlaceholders) {
        val = '';
      }
      this.inputEl.value = val;
      this.placeholderEl.innerHTML = placeholder;
      this._updateWidth();
      if (this.isFocused) {
        this._setCaretPositionTranslated(cursorIndex);
      }
      if (val !== oldVal) {
        (0, _triggerEvent.default)(this.inputEl, 'input');
      }
      this.isRunning = false;
      if (val !== oldVal) {
        (this.onChange || noop)(val, oldVal, this);
      }
      if (!this._atEnd && this.isFocused && this.characters.length === this.maxLength && this._caretIsAtEnd()) {
        this._atEnd = true;
        (this.onEnd || noop)(this);
      } else {
        this._atEnd = false;
      }
      return this;
    }

    /**
     * Set the value of the typeahead. Maintain the position of the caret.
     * @param {String} value
     */
  }, {
    key: "setValue",
    value: function setValue(value) {
      this.settingValue = true;
      this.pause();
      if (typeof value === 'string') {
        // Ensure that periods are not stripped from a.m./p.m.
        if (this.placeholder !== 'a.m.') {
          this.characters = (value.replace(/\W/g, '') + '').split('');
        } else {
          this.characters = value.split('');
        }
      } else if (typeof value === 'number') {
        // Perform regex replace if a float is set
        if (value % 1 !== 0) {
          this.characters = (value.toString().replace(/\W/g, '') + '').split('');
        } else {
          this.characters = (value + '').split('');
        }
      }
      this.run();
      if (this.isFocused) this._setCaretPosition(this._getCaretStart());
      this.resume();
      this.settingValue = false;
      return this;
    }

    /**
     * Create the default input element.
     * @return {Element}
     */
  }, {
    key: "_createDefaultInputElement",
    value: function _createDefaultInputElement() {
      var el = document.createElement('input');
      el.className = 'spark-input__field';
      el.setAttribute('data-typeahead', '');
      if (this.placeholder === 'a.m.') {
        el.setAttribute('type', 'text');
      } else {
        el.setAttribute('type', 'tel');
      }
      this.el.appendChild(el);
      return el;
    }

    /**
     * Get the maximum number of characters allowed.
     * @param {Array} format
     * @return {Number}
     */
  }, {
    key: "_getCharactersAllowedCount",
    value: function _getCharactersAllowedCount(format) {
      var len = format.length;
      var allowed = 0;
      for (var i = 0; i < len; i++) {
        if (format[i] === '\\d' || format[i] === '\\D') {
          allowed++;
        }
      }
      return allowed;
    }

    /**
     * Get the position of the caret translated to the corresponding index in the
     * characters array. This means ignoring format characters.
     * @param {Number} pos
     * @return {Number}
     */
  }, {
    key: "_getCaretPositionTranslated",
    value: function _getCaretPositionTranslated(pos) {
      var i = 0;
      var skipCount = 0;
      for (; i < pos; i++) {
        if (this.format[i] !== '\\d' && this.format[i] !== '\\D') {
          skipCount++;
        }
      }
      return pos - skipCount;
    }

    /**
     * Set the position of the caret translated to the corresponding index in the
     * characters array. This means ignoring format characters.
     * @param {Number} pos
     */
  }, {
    key: "_setCaretPositionTranslated",
    value: function _setCaretPositionTranslated(pos) {
      var i = 0;
      var skipCount = 0;
      for (; i < pos + skipCount; i++) {
        if (this.format[i] !== undefined && this.format[i] !== '\\d' && this.format[i] !== '\\D') {
          skipCount++;
        }
      }
      this._setCaretPosition(pos + skipCount);
    }

    /**
     * Remove characters from the period field
     * @param  {String} action Action can be Backspace or Delete
     * @param  {Number} caretStart
     * @param  {Number} inputLength
     */
  }, {
    key: "_removePeriodCharacters",
    value: function _removePeriodCharacters(action, caretStart, inputLength) {
      var zeroBasedAdjustment = action === 'BACKSPACE' ? 1 : 0;
      var caretPos = action === 'BACKSPACE' ? -1 : 0;
      for (var c = 0; c < inputLength - caretStart + zeroBasedAdjustment; c++) {
        if (caretStart === 1 && action === 'BACKSPACE') {
          this.inputEl.setSelectionRange(caretStart - 1, inputLength);
          this.removeCharactersInRange();
          break;
        } else {
          this.removeCharacterAtCaret(caretPos);
        }
        caretPos = caretPos === -1 ? 0 : -1;
      }
    }

    /**
     * Listen for delete and arrows.
     * @param  {Object} e
     */
  }, {
    key: "_onKeydown",
    value: function _onKeydown(e) {
      var code = e.keyCode || e.which;
      if (code === this.pasteCode && (e.metaKey || e.ctrlKey)) {
        return;
      }
      if (code === this.actionCodes.BACKSPACE) {
        if (this.placeholder === 'a.m.') {
          var caretStart = this._getCaretStart();
          var inputLength = this.inputEl.value.length;
          this._removePeriodCharacters('BACKSPACE', caretStart, inputLength);
        } else {
          this.removeCharacterAtCaret(-1);
        }
        this._onBackspace();
        e.preventDefault();
      } else if (code === this.actionCodes.DELETE) {
        if (this.placeholder === 'a.m.') {
          var _caretStart = this._getCaretStart();
          var _inputLength = this.inputEl.value.length;
          this._removePeriodCharacters('DELETE', _caretStart, _inputLength);
        } else {
          this.removeCharacterAtCaret(0);
        }
        e.preventDefault();
      } else if (code === this.actionCodes.LEFT) {
        if (!this._getCaretStart()) {
          (this.onBackspace || noop)();
        }
      } else if (code === this.actionCodes.RIGHT) {
        if (this._getCaretStart() === this.characters.length) {
          (this.onEnd || noop)();
        }
      } else {
        if (this.ignoreCodes.indexOf(code) === -1) {
          e.preventDefault();

          // Account for Numpad keys
          if (code >= 96 && code <= 105) {
            code -= 48;
          }
          if (this.placeholder === 'a.m.') {
            var enteredCharacter = String.fromCharCode(code).toLowerCase();

            // If the contents of the field have been selected, set cursor position to beginning of selection
            var selectedText = '';
            selectedText = this.inputEl.value.substring(this.inputEl.selectionStart, this.inputEl.selectionEnd);
            if (selectedText !== '') {
              this._setCaretPosition(this._getCaretStart());
            }
            if (this.inputEl.value) {
              var inputVal = this.inputEl.value.toLowerCase();
              if (inputVal === 'a' || inputVal === 'p' || inputVal === 'a.m' || inputVal === 'p.m') {
                // Allow m only if we have a or p. Append . before the m
                if (code === 77 && (inputVal === 'a' || inputVal === 'p')) {
                  this.addCharacterAtCaret('.');
                  this.addCharacterAtCaret(enteredCharacter);
                }

                // Allow . only
                if (code === 190) {
                  this.addCharacterAtCaret('.');
                }
              } else if (inputVal === 'a.' || inputVal === 'p.') {
                // Allow m only
                if (code === 77) {
                  this.addCharacterAtCaret(enteredCharacter);
                }
              } else if (inputVal === 'a.m.' || inputVal === 'p.m.') {
                // Check position of cursor to determine what's allowed
                var currPos = this._getCaretStart();
                if (currPos === 0) {
                  // Allow a or p
                  if (enteredCharacter === 'a' || enteredCharacter === 'p') {
                    this.removeCharacterAtCaret(0);
                    this._moveCaret('left');
                    this.addCharacterAtCaret(enteredCharacter);
                  }
                }
                if (currPos === 1) {
                  // Allow .
                  if (code === 190) {
                    this.removeCharacterAtCaret(0);
                    this._moveCaret('left');
                    this.addCharacterAtCaret('.');
                  }
                }
                if (currPos === 2) {
                  // Allow m only
                  if (code === 77) {
                    this.removeCharacterAtCaret(0);
                    this._moveCaret('left');
                    this.addCharacterAtCaret(enteredCharacter);
                  }
                }
                if (currPos === 3) {
                  // Allow .
                  if (code === 190) {
                    this.removeCharacterAtCaret(0);
                    this.addCharacterAtCaret('.');
                  }
                }
              } else {
                return false;
              }
            } else {
              if (enteredCharacter === 'a' || enteredCharacter === 'p') {
                this.addCharacterAtCaret(enteredCharacter);
              }
            }
          } else {
            this.addCharacterAtCaret(String.fromCharCode(code));
          }
        }
      }
    }
  }]);
  return TimeTypeahead;
}(_typeahead.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
TimeTypeahead.prototype._whitelistedParams = ['format', 'placeholder', 'matchPlaceholderSize', 'onChange', 'onFocus', 'onBlur', 'onInput', 'onBackspace', 'onEnd'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
TimeTypeahead.prototype.defaults = {
  el: null,
  inputEl: null,
  placeholderEl: null,
  placeholder: null,
  characters: null,
  format: null,
  ignoreCodes: [
  // Tab
  9,
  // Shift
  16,
  // Ctrl
  17,
  // Alt
  18,
  // CAPS
  20,
  // Meta
  91,
  // Alt
  93,
  // F1-F12
  112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123,
  // Arrows
  38, 40],
  actionCodes: {
    BACKSPACE: 8,
    DELETE: 46,
    LEFT: 37,
    RIGHT: 39
  },
  // v
  pasteCode: 86,
  pauseBlurFocus: 0,
  matchPlaceholderSize: null,
  maxLength: null,
  isFocused: false,
  isRunning: false,
  onChange: null,
  onFocus: null,
  onBlur: null,
  onInput: null,
  onBackspace: null,
  onEnd: null,
  _atEnd: false,
  _oldVal: null,
  _onKeydownBound: null,
  _onKeypressBound: null,
  _onFocusBound: null,
  _onBlurBound: null,
  _onInputBound: null,
  _onPlaceholderClickBound: null
};
var _default = TimeTypeahead;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/trigger-event":69,"./typeahead":50,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],46:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _debounce = _interopRequireDefault(require("../helpers/util/debounce"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _offset = _interopRequireDefault(require("../helpers/dom/offset"));
var _outerHeight = _interopRequireDefault(require("../helpers/dom/outer-height"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Toast
                                                                                                                                                                                                                                                                                                                                              * Show or hide a toast notification. toast appears at the top of the panel or below a header at the top of the panel.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * to anchor the toast below a header
                                                                                                                                                                                                                                                                                                                                              * new Toast(el, {elHeader:[DOM OBJECT] });
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * to anchor the toast at the top of a panel
                                                                                                                                                                                                                                                                                                                                              * new Toast(el);
                                                                                                                                                                                                                                                                                                                                              * @module components/toast.js
                                                                                                                                                                                                                                                                                                                                              */
var Toast = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(Toast, _BaseComponent);
  var _super = _createSuper(Toast);
  /**
   * Toast Constructor
   * @param {Element} el          root element to attach the toast
   * @param {Object} [params={}]  toast parameters see defaults
   */
  function Toast(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Toast);
    _this = _super.call(this, el, params);
    if (!el) return (0, _possibleConstructorReturn2.default)(_this, (0, _assertThisInitialized2.default)(_this));

    // get the position type of the container. if it's fixed you have to handle the toast differently
    _this._elPosition = window.getComputedStyle(_this.el, null).getPropertyValue('position');
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    _this._createTypes();
    _this._isActive = false;
    return _this;
  }

  /**
   * Add Toast window event listners
   */
  (0, _createClass2.default)(Toast, [{
    key: "_addWindowListeners",
    value: function _addWindowListeners() {
      // listen to the scroll event, manage to visiblity / position on the screen
      window.addEventListener('scroll', this._onScrollBound);

      // resize the toast as the screen resizes
      window.addEventListener('resize', this._doResizeBound);
    }

    /**
     * Add Toast event listners
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      // if the position is fixed then this is probably the fixed header with the resize
      if (window.getComputedStyle(this.el, null).getPropertyValue('position') === 'fixed') {
        this.el.addEventListener('transitionend', this._fixedHeaderTransitionBound);
      }
      this._dom.panel.actions.el.addEventListener('click', this._doActionBound);
      this._dom.root.addEventListener('touchstart', this._touchStart.bind(this));
      this._dom.root.addEventListener('touchend', this._touchEnd.bind(this));
    }

    /**
     * attach the toast to the DOM
     */
  }, {
    key: "_attachToast",
    value: function _attachToast() {
      this.el.insertBefore(this._dom.root, this.el.firstChild);
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._fixedHeaderTransitionBound = this._fixedHeaderTansition.bind(this);
      this._onScrollBound = this._onScroll.bind(this);
      this._doActionBound = this._doAction.bind(this);
      this._doResizeBound = (0, _debounce.default)(this._resize.bind(this), 100);
      this._onHidePanelBound = this._onHidePanel.bind(this);
      this._onTimerDoneBound = this._onTimerDone.bind(this);
    }

    /**
     * Set's up references
     * @param  {Element} el base DOM element
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      // set up a convience object to hold all the references to the dom elements;
      this._dom = {
        root: '',
        panel: {
          root: '',
          icon: {
            root: '',
            el: ''
          },
          content: {
            root: '',
            title: '',
            details: ''
          },
          actions: {
            root: '',
            el: ''
          },
          timer: {
            root: ''
          }
        }
      };
      this.el = el;

      // capture the creation time to set a unique ID on the toast messages that may be used by accessibility features if needed for an alertdialog
      var _toastTime = new Date().getTime();

      // set id's for alertdialogs
      this._ariaLabelledBy = 'spark-toast--title-' + _toastTime.toString(16);
      this._arialDescribedBy = 'spark-toast--details-' + _toastTime.toString(16);

      // create the dom components
      this._dom.root = document.createElement('div');
      this._dom.toast = document.createElement('div');
      this._dom.panel.root = document.createElement('div');
      this._dom.panel.icon.root = document.createElement('div');
      this._dom.panel.icon.el = document.createElement('i');
      this._dom.panel.icon.root.setAttribute('aria-hidden', true);
      this._dom.panel.content.root = document.createElement('div');
      this._dom.panel.content.title = document.createElement('h4');
      this._dom.panel.content.title.setAttribute('role', 'presentation');
      this._dom.panel.content.title.setAttribute('id', this._ariaLabelledBy);
      this._dom.panel.content.details = document.createElement('p');
      this._dom.panel.content.details.setAttribute('id', this._arialDescribedBy);
      this._dom.panel.actions.root = document.createElement('div');
      this._dom.panel.actions.el = document.createElement('button');
      this._dom.panel.actions.el.setAttribute('role', 'button');
      this._dom.panel.timer.root = document.createElement('div');
      (0, _addClass.default)(this._dom.root, 'spark-toast-root');
      (0, _addClass.default)(this._dom.toast, 'spark-toast');
      (0, _addClass.default)(this._dom.panel.root, 'spark-toast__panel');
      (0, _addClass.default)(this._dom.panel.icon.root, 'spark-toast__icon');
      (0, _addClass.default)(this._dom.panel.content.root, 'spark-toast__content');
      (0, _addClass.default)(this._dom.panel.content.title, '');
      (0, _addClass.default)(this._dom.panel.content.details, '');
      (0, _addClass.default)(this._dom.panel.actions.root, 'spark-toast__actions');
      (0, _addClass.default)(this._dom.panel.content.title, 'spark-toast__heading');
      (0, _addClass.default)(this._dom.panel.content.details, 'spark-toast__details');
      (0, _addClass.default)(this._dom.panel.timer.root, 'spark-toast__timer');
      this._dom.panel.icon.root.appendChild(this._dom.panel.icon.el);
      this._dom.panel.content.root.appendChild(this._dom.panel.content.title);
      this._dom.panel.content.root.appendChild(this._dom.panel.content.details);
      this._dom.panel.actions.root.appendChild(this._dom.panel.actions.el);
      this._dom.panel.root.appendChild(this._dom.panel.icon.root);
      this._dom.panel.root.appendChild(this._dom.panel.content.root);
      this._dom.panel.root.appendChild(this._dom.panel.actions.root);
      this._dom.panel.root.appendChild(this._dom.panel.timer.root);
      this._dom.toast.appendChild(this._dom.panel.root);
      this._dom.root.appendChild(this._dom.toast);
    }

    /**
     * method decides if the toast should be fixed or position absolute, makes adjustments as need to position of the toast
     *
     */
  }, {
    key: "_checkFixed",
    value: function _checkFixed() {
      // if the parent is not fixed (currently only use case is fixed header) then position toast correctly
      if (this._elPosition !== 'fixed') {
        var scrollTop = window.pageYOffset !== undefined ? window.pageYOffset : window.document.body.scrollTop;
        var scrollLeft = window.pageXOffset !== undefined ? window.pageXOffset : window.document.body.scrollLeft;

        // if the starting position less than the scroll top value, then the toast still needs to display so set the fixed class
        if (this._startTop < scrollTop) {
          (0, _toggleClass.default)(this._dom.toast, 'spark-toast--fixed', true);
          this._dom.toast.style['top'] = 0;
          this._dom.toast.style['left'] = (0, _offset.default)(this.el, false).left - scrollLeft + 'px';
        } else {
          // set notification is positioned absolute
          (0, _toggleClass.default)(this._dom.toast, 'spark-toast--fixed', false);

          // if it should appear below a header element.
          if (this.elHeader) {
            this._dom.toast.style['left'] = '-' + Math.floor((0, _offset.default)(this.elHeader, false).left - (0, _offset.default)(this.el, false).left) + 'px';
            this._dom.toast.style['top'] = (0, _outerHeight.default)(this.elHeader) + 'px';
          } else {
            this._dom.toast.style['left'] = 0;
            this._dom.toast.style['top'] = 0;
          }
        }
      } else {
        this._dom.toast.style['top'] = (0, _outerHeight.default)(this.el) + 'px';
      }
    }

    /**
     * Creates a object that contains default classnames, allows for possible other defaults
     *
     */
  }, {
    key: "_createTypes",
    value: function _createTypes() {
      this._toastTypes = {};
      this._toastTypes.positive = {
        className: 'spark-toast--positive'
      };
      this._toastTypes.neutral = {
        className: 'spark-toast--neutral'
      };
      this._toastTypes.warning = {
        className: 'spark-toast--warning'
      };
      this._toastTypes.error = {
        className: 'spark-toast--error'
      };
    }

    /**
     * Action is the generic method called from pressing the dismiss button. it's generic incase we open the flood gates and allow other actions in that location
     * @param  {MouseEvent} _event click
     */
  }, {
    key: "_doAction",
    value: function _doAction(_event) {
      if (_event) {
        _event.stopImmediatePropagation();
      }

      // Custom on action call back disable due to accessibility concerns
      this.onAction = null;

      // trigger the timer done event to start the close animation
      if (typeof this.onAction === 'function') {
        this.onAction();
      }

      // user interacted with the Toast time,to hide it.
      this._onTimerDoneBound(_event);
    }

    /**
     * listen to fixed header transition then adjust the header of the toast notification
     * @param  {AnimationEvent} _event animationend
     */
  }, {
    key: "_fixedHeaderTansition",
    value: function _fixedHeaderTansition() {
      this._dom.toast.style['top'] = (0, _outerHeight.default)(this.el) + 'px';
    }

    /**
     * remove the toast from the DOM
     * @param  {AnimationEvent} _event animationend
     */
  }, {
    key: "_onHidePanel",
    value: function _onHidePanel(_event) {
      if (_event) {
        _event.stopImmediatePropagation();
      }

      // set the toast to inactive
      this._isActive = false;

      // remove the show class
      (0, _removeClass.default)(this._dom.panel.root, 'spark-toast--show');

      // remove the event listener, IE10 doesn't like the once:true option
      this._dom.panel.root.removeEventListener('animationend', this._onHidePanelBound);

      // remove toast from dom.
      this._dom.root.parentNode.removeChild(this._dom.root);

      // toast doesn't need to respond to window events, since it's not part of the DOM
      this._removeWindowListeners();

      // restore focus
      if (this._lastFocused !== null) {
        this._lastFocused.focus();
      }
      this._lastFocused = null;
    }

    /**
     * if the toast is in a fixed position make sure it stays relative to the element that its attached too.
     * even left / right.
     */
  }, {
    key: "_onScroll",
    value: function _onScroll() {
      this._checkFixed();
    }

    /**
     * called fromt timer animation completion, triggers animation to hide toast
     * @param  {AnimationEvent} _event animationend event triggered from timer
     */
  }, {
    key: "_onTimerDone",
    value: function _onTimerDone(_event) {
      if (_event) {
        _event.stopImmediatePropagation();
      }

      // remove the event listener, the {once:true} does not work in IE10 so we have to do it manually
      this._dom.panel.timer.root.removeEventListener('animationend', this._onTimerDoneBound);

      // clear out any animations;
      this._dom.panel.root.style['animation'] = '';

      // add listener to trigger Hiding the Panel
      this._dom.panel.root.addEventListener('animationend', this._onHidePanelBound);

      // quickly animate out the panel.
      this._dom.panel.root.style['animation'] = 'toast-animation-out .25s ease-out .2s 1 backwards';
      this._isActive = false;
    }

    /**
     * main public method, opens toast.
     * @param  {Object} options Toast options Object
     */
  }, {
    key: "open",
    value: function open(options) {
      // get the currently focussed element;
      this._setLastFocused();
      if (!this.el) return this;
      this._updateValues(options);

      // use the role alertsdialog since the toast is actionable
      if (this.actionIcon === '' && this.actionLabel === '') {
        // no action to be taken the role changes to alert
        this._dom.toast.removeAttribute('aria-labelledby');
        this._dom.toast.removeAttribute('aria-describedby');
        this._dom.toast.setAttribute('role', 'alert');
      } else {
        this._dom.toast.setAttribute('aria-labelledby', this._ariaLabelledBy);
        this._dom.toast.setAttribute('aria-describedby', this._arialDescribedBy);
        this._dom.toast.setAttribute('role', 'alertdialog');
      }
      this._dom.panel.content.title.innerHTML = this.title;
      this._dom.panel.content.details.innerHTML = this.details;
      this._dom.toast.className = 'spark-toast spark-toast--' + this.type;

      // if the parent is fixed add the toast fixed style to it;
      if (this._elPosition === 'fixed') {
        (0, _toggleClass.default)(this._dom.toast, 'spark-toast--fixed', true);
      } else {
        (0, _toggleClass.default)(this._dom.toast, 'spark-toast--fixed', false);

        // place the element under the header if necessary
        this._dom.toast.style['top'] = this.el.offsetTop + this.el.offsetHeight + 'px';
      }
      this._dom.panel.icon.el.className = 'spark-icon spark-icon--fill ' + this.icon;
      if (this.actionIcon !== '' && this.actionIcon) {
        if (this.actionLabel) {
          // add accessiblility attribute to so it reads like DISMISS BUTTON instead of just BUTTON
          this._dom.panel.actions.el.setAttribute('aria-label', this.actionLabel);
        }
        this._dom.panel.actions.el.className = 'spark-btn--icon spark-icon spark-icon--fill ' + this.actionIcon;
        this._dom.panel.actions.el.innerHTML = '';
      } else {
        this._dom.panel.actions.el.removeAttribute('aria-label');
        this._dom.panel.actions.el.className = 'spark-btn spark-btn--text';
        this._dom.panel.actions.el.innerHTML = this.actionLabel;
      }
      if (this._isActive === false) {
        // checks if a new event came it before the animation has finished on the previous toast notificaiton;
        if (this._dom.root.parentNode) {
          this._onHidePanel();
        }

        // add the window listeners
        this._addWindowListeners();

        // attach the toast to the element;
        this._attachToast();

        // gets the position of the parent this will allow us to decide if this should be handled be place under a fixed position header
        this._elPosition = window.getComputedStyle(this.el, null).getPropertyValue('position');

        // keep track of the current starting position, in this case header would scroll, but the message will be fixed so it is display on the screen
        if (this.elHeader) {
          this._startTop = (0, _outerHeight.default)(this.elHeader) + (0, _offset.default)(this.el, false).top;
        } else {
          this._startTop = (0, _offset.default)(this.el, false).top;
        }

        // track the width of the parent, the toast content is positioned absolute so doesn't have a default widht;
        this._dom.toast.style['width'] = this.el.offsetWidth + 'px';

        // stop any panel animations;
        this._dom.panel.root.style['animation'] = '';

        // set the show panel animation;
        (0, _addClass.default)(this._dom.panel.root, 'spark-toast--show');
      }

      // check if it the toast is fixed position or to absolute relative to an element
      this._checkFixed();

      // set the focus to the action button
      this._setFocus();

      // restarts timer
      this._startTimer();

      // track if the notification is still active
      this._isActive = true;
    }

    /**
     * remove / clean up Toast
     */
  }, {
    key: "remove",
    value: function remove() {
      this._onHidePanel();
      this.el.removeEventListener('transitionend', this._fixedHeaderTansitionBound);
      this._dom = undefined;
    }

    /**
     * removes window listeners
     */
  }, {
    key: "_removeWindowListeners",
    value: function _removeWindowListeners() {
      window.removeEventListener('scroll', this._onScrollBound);
      window.removeEventListener('resize', this._doResizeBound);
    }

    /**
     * resizes toast message
     */
  }, {
    key: "_resize",
    value: function _resize() {
      if (this._isActive === true) {
        this._dom.toast.style['width'] = this.el.offsetWidth + 'px';
      }
    }

    /**
     * sets the focus of the action button
     */
  }, {
    key: "_setFocus",
    value: function _setFocus() {
      if (this.actionLabel !== '' || this.actionIcon !== '') {
        this._dom.panel.actions.el.focus();
      }
    }

    /**
     * set a reference to the last focused element
     */
  }, {
    key: "_setLastFocused",
    value: function _setLastFocused() {
      this._lastFocused = document.activeElement;
      if (!this._lastFocused || this._lastFocused === document.body) {
        this._lastFocused = null;
      } else if (document.querySelector) {
        this._lastFocused = document.querySelector(":focus");
      }
    }

    /**
     * this is the call back
     * @param  {Object} _event [description]
     */
  }, {
    key: "_startTimer",
    value: function _startTimer() {
      // stop all the timer animation
      this._dom.panel.timer.root.style['animation'] = '';

      // trigger reflow to clear animation;
      void this._dom.panel.timer.root.offsetWidth;

      // add timer done listener this will trigger the close animation
      this._dom.panel.timer.root.addEventListener('animationend', this._onTimerDoneBound);

      // restart animation using current duration
      this._dom.panel.timer.root.style['animation'] = this.duration + 's linear 1s toast-timer-animation forwards';
    }

    /**
     * track initial touch location on toast
     * @param  {TouchEvent} _event touchstart
     */
  }, {
    key: "_touchStart",
    value: function _touchStart(_event) {
      if (_event) {
        _event.stopImmediatePropagation();
      }
      this._toastRect = this._dom.toast.getBoundingClientRect();
      this._startX = _event.changedTouches[0].screenX;
      this._startY = _event.changedTouches[0].screenY;
    }

    /**
     * track touch end to test if it
     * @param  {TouchEvent} _event touchend
     */
  }, {
    key: "_touchEnd",
    value: function _touchEnd(_event) {
      var ratio_horizontal = (_event.changedTouches[0].screenX - this._startX) / this._toastRect.width;
      var ratio_vertical = (_event.changedTouches[0].screenY - this._startY) / this._toastRect.height;
      if (ratio_horizontal > ratio_vertical && ratio_horizontal > 0.25) {
        return 'swipe-right';
      }
      if (ratio_vertical > ratio_horizontal && ratio_vertical > 0.25) {
        return 'swipe-down';
      }
      if (ratio_horizontal < ratio_vertical && ratio_horizontal < -0.25) {
        return 'swipe-left';
      }
      if (ratio_vertical < ratio_horizontal && ratio_vertical < -0.25) {
        // trigger close event;
        this._doActionBound(_event);
        return 'swipe-up';
      }
    }

    /**
     * open can be called with values from initial toast creation or called with new values.
     * this will update the toast values, or set them to the defaults if they are omitted from the open call
     * @param  {Object} [options={}] Toast options object
     */
  }, {
    key: "_updateValues",
    value: function _updateValues() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // nothing to do options would have been set on creation
      if ((0, _keys.default)(options).length === 0) {
        return;
      }
      this.title = options.title || this.defaults.title;
      this.details = options.details || this.defaults.details;
      this.duration = options.duration || this.defaults.duration;
      this.type = options.type || this.defaults.type;
      this.icon = options.icon || this.defaults.icon;
      this.actionIcon = options.actionIcon || this.defaults.actionIcon;
      this.actionLabel = options.actionLabel || this.defaults.actionLabel;
      this.onAction = options.onAction || this.defaults.onAction;
    }
  }]);
  return Toast;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
Toast.prototype._whitelistedParams = ['elHeader', 'type', 'title', 'details', 'duration', 'icon', 'actionIcon', 'actionLabel', 'onAction'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
Toast.prototype.defaults = {
  el: null,
  elHeader: null,
  type: 'positive',
  title: '',
  details: '',
  icon: '',
  duration: 3,
  actionIcon: '',
  actionLabel: '',
  onAction: null
};
var _default = Toast;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/add-class":59,"../helpers/dom/offset":63,"../helpers/dom/outer-height":64,"../helpers/dom/remove-class":67,"../helpers/dom/toggle-class":68,"../helpers/util/debounce":93,"./base":3,"@babel/runtime-corejs3/core-js-stable/object/keys":123,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/assertThisInitialized":143,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],47:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _getParent = _interopRequireDefault(require("../helpers/traversal/get-parent"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # ToggleSwitch
                                                                                                                                                                                                                                                                                                                                              * ToggleSwitch and collapse an element.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new ToggleSwitch(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/ToggleSwitch.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var ToggleSwitch = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(ToggleSwitch, _BaseComponent);
  var _super = _createSuper(ToggleSwitch);
  /**
   * ToggleSwitch constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function ToggleSwitch(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, ToggleSwitch);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Toggle the ToggleSwitch state.
   */
  (0, _createClass2.default)(ToggleSwitch, [{
    key: "toggle",
    value: function toggle() {
      if (!this.input) return this;
      return this.input.checked ? this.deactivate() : this.activate();
    }

    /**
     * Activate toggle state
     */
  }, {
    key: "activate",
    value: function activate() {
      return this.setValue(true);
    }

    /**
     * Deactivate toggle state
     */
  }, {
    key: "deactivate",
    value: function deactivate() {
      return this.setValue(false);
    }

    /**
     * Set the value.
     * @param {Boolean} check
     */
  }, {
    key: "setValue",
    value: function setValue(check) {
      if (this.input) {
        if (this.input.checked !== check) {
          this.input.checked = check;
          (this.onChange || noop)(check, this);
        }
      }
      return this;
    }

    /**
     * Get the value.
     * @return {Boolean}
     */
  }, {
    key: "getValue",
    value: function getValue() {
      return this.input && this.input.checked;
    }

    /**
     * Clear the checked value. Not very helpful but here for parity.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      return this.deactivate();
    }

    /**
     * Enable the input.
     */
  }, {
    key: "enable",
    value: function enable() {
      if (this.input) this.input.removeAttribute('disabled');
      return this;
    }

    /**
     * Disable the input.
     */
  }, {
    key: "disable",
    value: function disable() {
      if (this.input) this.input.setAttribute('disabled', '');
      return this;
    }

    /**
     * Store a reference to the element.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.input = el.querySelector('.spark-toggle__input');
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onKeydownBound = this._onKeydown.bind(this);
      this._onClickBound = this._onClick.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.el.addEventListener('keydown', this._onKeydownBound);
      this.el.addEventListener('click', this._onClickBound);
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.el.removeEventListener('keydown', this._onKeydownBound);
      this.el.removeEventListener('click', this._onClickBound);
    }

    /**
     * Allow onChange when clicked
     * @param {Object} e
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      if (!(0, _getParent.default)(e.target, '.spark-toggle-switch', this.el) || this.input.hasAttribute('disabled')) {
        return;
      }
      e.preventDefault();
      this.toggle();
    }

    /**
     * When the space or enter key is pressed on the toggle, toggle!
     * @param {Object} e
     */
  }, {
    key: "_onKeydown",
    value: function _onKeydown(e) {
      if (!(0, _getParent.default)(e.target, '.spark-toggle-switch, spark-toggle-switch__handle', this.el)) {
        return;
      }
      var code = e.keyCode || e.which;
      switch (code) {
        case 32:
          // space
          e.preventDefault();
          this.toggle();
          break;
        case 13:
          // enter
          e.preventDefault();
          this.toggle();
          break;
        case 39:
        case 40:
          // right
          // down
          e.preventDefault();
          this.activate();
          break;
        case 37:
        case 38:
          // left
          // up
          e.preventDefault();
          this.deactivate();
          break;
      }
    }
  }]);
  return ToggleSwitch;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
ToggleSwitch.prototype._whitelistedParams = ['onChange'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
ToggleSwitch.prototype.defaults = {
  el: null,
  input: null,
  onChange: null,
  _onKeydownBound: null,
  _onClickBound: null
};
var _default = ToggleSwitch;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/traversal/get-parent":87,"./base":3,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],48:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));
var _splice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/splice"));
var _sort = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/sort"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _debounce = _interopRequireDefault(require("../helpers/util/debounce"));
var _each = _interopRequireDefault(require("../helpers/util/each"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _parseAttribute = require("../helpers/dom/parse-attribute");
var _getParent = _interopRequireDefault(require("../helpers/traversal/get-parent"));
/**
 * # Toolbar
 * Setup a responsive toolbar
 *
 * @example
 * new Toolbar(el);
 *
 * @module components/toolbar.js
 */
var Toolbar = /*#__PURE__*/function () {
  /**
   * Toolbar constructor.
   * @param {Element} el
   * @param {Object} params
   */
  function Toolbar(el) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Toolbar);
    if (!el) return;
    this.setParams(this.defaults || {}, true);
    this.setParams(params);
    this._init(el);
    this._windowInnerWidth = window.innerWidth;
  }

  /**
   * Set a hash of parameters if they're whitelisted or we're told to force the set.
   * This is used to set initial values as well as set passed parameters.
   * @param {Object} params
   * @param {Boolean} force Force setting even if the param is not whitelisted.
   */
  (0, _createClass2.default)(Toolbar, [{
    key: "setParams",
    value: function setParams(params, force) {
      var _this = this;
      (0, _each.default)(params, function (k, v) {
        if (_this._whitelistedParams.indexOf(k) !== -1 || force) {
          _this[k] = v;
        }
      });
      return this;
    }

    /**
     * Unset all parameters.
     * @param {Array|Object} keys
     * @param {Object} scope The object to unset the params from. Defaults to `this`.
     */
  }, {
    key: "unsetParams",
    value: function unsetParams(keys, scope) {
      keys = keys instanceof Array ? keys : (0, _keys.default)(keys);
      scope = scope || this;
      (0, _each.default)(keys, function (k) {
        delete scope[k];
      });
      return this;
    }

    /**
     * This function will update cached sizing when an element in the toolbar is changed
     * or, when toolbar items are added or removed
     */
  }, {
    key: "change",
    value: function change() {
      if (!this.el) {
        return this;
      }
      this._closeAll();
      (0, _removeClass.default)(this.el, ['ready', 'show-more', 'measured']);
      var v = document.createDocumentFragment();
      for (var i = 0; i < this.items.length; i++) {
        v.appendChild(this.items[i].el);
      }
      this.visibleContainer.appendChild(v);
      this._initItems();
      (0, _addClass.default)(this.el, 'measured');
      this._calculateStyles();
      (0, _addClass.default)(this.el, 'ready');
      return this;
    }

    /**
     * Update the component to use a new element or reparse from
     * the existing element.
     * @param {Element} el Optional
     */
  }, {
    key: "update",
    value: function update(el) {
      if (el) {
        this.remove(true);
        this._init(el);
      } else {
        this.change();
      }
      return this;
    }

    /**
     * Remove the element from the DOM and prepare for garbage collection by dereferencing values.
     * @param {Boolean} leaveElement Leave the element intact.
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      this._removeListeners();
      delete this.el.sparktoolbarcon;
      delete this.showMoreButton.sparktoolbarshowmore;
      for (var i = 0; i < this.items.length; i++) {
        this.items[i].remove();
      }
      if (!leaveElement && this.el.parentNode) {
        this.el.parentNode.removeChild(this.el);
        this.el = undefined;
      }
      return this;
    }

    /**
     * Setup a toolbarItem Instance to track the state of individual toolbar items
     * @param {Element} parent Reference to parent toolbar
     * @param {Element} el Node to initalize as toolbarItem
     * @param {Number} order The original index of the item in list of toolbarItems (used for maintaining order when sorting)
     */
  }, {
    key: "toolbarItem",
    value: function toolbarItem(parent, el, order) {
      // Setup and cache the values for this item
      var a = {};
      a.parent = parent;
      a.el = el;

      // cache the priority value present on the toolbar element if it is present, else default to 0
      a.priority = a.el.attributes['data-priority'] ? a.el.attributes['data-priority'].value : 0;
      a.order = a.el.attributes['data-order'] ? a.el.attributes['data-order'].value : order;
      a.hasContent = a.el.querySelector('.spark-toolbar__item--content') ? true : false;
      a.helper = a.el.querySelector('.spark-toolbar__item-helper');
      a.label = a.el.attributes.label ? a.el.attributes.label.value : false;
      a.closeOnClick = (0, _hasClass.default)(a.el, 'spark-toolbar__item--close-more-on-click');
      a.width = a.el.offsetWidth;
      a.height = a.el.offsetHeight;
      a.dropdown = el.querySelector('.spark-toolbar__item--content');
      if (a.dropdown) {
        a.dropdown.sparktoolbardropdown = true;
      }

      /**
       * Call method to toggle the open state, optional param sets open state to value
       * Can get current state by referencing a.toggleDropdown.open
       * @param {Boolean} open Set state to this regardless of current state
       */
      a.toggleDropdown = function (open) {
        var o = typeof open !== 'undefined' ? !open : a.toggleDropdown.open;
        if (o) {
          a.toggleDropdown.open = false;
          (0, _removeClass.default)(a.el, 'animate');
          window.setTimeout(function () {
            (0, _removeClass.default)(a.el, 'open');
          }, 100);
        } else {
          if (a.hasContent) {
            a.toggleDropdown.open = true;
            (0, _addClass.default)(a.el, 'open');
            a.positionDropdown();
            var e = document.createEvent('Event');
            e.initEvent('spark.visible-children', true, true);
            a.dropdown.dispatchEvent(e);
            window.setTimeout(function () {
              (0, _addClass.default)(a.el, 'animate');
            }, 0);
          } else {
            a.parent._toggleShowMore(false);
          }
        }
      };

      /**
       * Click handler for local element - determines to close element
       * conditionally based on presence of spark-toolbar__item--close-on-click
       * closes parent's more dropdown conditionally as well
       * @param {Boolean} open Set state to this regardless of current state
       */
      a.handleClick = function (e) {
        if ((0, _parseAttribute.boolean)(a.el, 'disabled')) {
          e.preventDefault();
          return;
        }
        if (!a.toggleDropdown.open) {
          a.toggleDropdown(true);
        } else {
          if (e.target === a.el || e.target === a.helper) {
            a.toggleDropdown();
          } else {
            var b = e.target;
            while (b !== a.el) {
              if ((0, _hasClass.default)(b, 'spark-toolbar__item--close-on-click')) {
                a.toggleDropdown(false);

                // close the mode section, as event originated inside a close-on-click area
                a.parent._toggleShowMore(false);
                break;
              }
              b = b.parentElement;
            }
          }
        }

        // e.preventDefault();
      };

      // perform bounds checking on dropdown open to position dropdown inside visual area
      // this is called each time a dropdown is opened, in case the state of the component has
      // changed since initialization
      a.positionDropdown = function () {
        if (a.dropdown) {
          a.dropdown.style.left = '';
          a.dropdown.style.right = '';
          var pos = a.dropdown.getBoundingClientRect();
          var left = window.pageXOffset;
          var right = window.pageXOffset + document.documentElement.clientWidth;
          if (pos.right > right) {
            a.dropdown.style.left = 'inherit';
            a.dropdown.style.right = 0;
          }
          if (pos.left < left) {
            a.dropdown.style.left = 0;
            a.dropdown.style.right = 'inherit';
          }
        }
      };
      a.remove = function () {
        if (a.el) {
          delete a.el.sparktoolbar;
        }
        if (a.dropdown) {
          delete a.dropdown.sparktoolbardropdown;
        }
      };
      a.el.sparktoolbar = a;
      return a;
    }

    /**
     * Close any open items, and more dropdown
     */
  }, {
    key: "_closeAll",
    value: function _closeAll() {
      this._closeItems();
      this._toggleShowMore(false);
    }

    /**
     * Returns array of open toolbarItems
     */
  }, {
    key: "_getOpenItems",
    value: function _getOpenItems() {
      var a = [];
      for (var i = 0; i < this.items.length; i++) {
        if (this.items[i].toggleDropdown.open) {
          a.push(this.items[i]);
        }
      }
      return a;
    }

    /**
     * Close any open items
     * @param {Array} a Optional array of toolbarItems to close, defaults to all open items
     */
  }, {
    key: "_closeItems",
    value: function _closeItems(a) {
      a = typeof a === 'undefined' ? this._getOpenItems() : a;
      for (var i = 0; i < a.length; i++) {
        a[i].toggleDropdown(false);
      }
    }

    /**
     * Setup the toolbar element, cache properties, and initalize styling
     * when complete, show toolbar
     * @param {Element} el The node to initalize on
     */
  }, {
    key: "_init",
    value: function _init(el) {
      this.el = el;

      // store a reference to this on the node to expedite event handling
      this.el.sparktoolbarcon = this;
      this.visibleContainer = this.el.querySelector('.spark-toolbar__container--visible');
      this.hiddenContainer = this.el.querySelector('.spark-toolbar__container--hidden');
      this.showMoreButton = this.el.querySelector('.spark-toolbar__show-more');
      this.showMoreButton.sparktoolbarshowmore = true;
      this.isOpen = false;
      this.isFocus = false;
      this._setupListeners();
      this.el.style.width = '100%';
      this._initItems();
      (0, _addClass.default)(this.el, 'measured');
      this._calculateStyles();
      this.tabindex = this.el.attributes.tabindex ? this.el.attributes.tabindex.value : 0;
      (0, _addClass.default)(this.el, 'ready');
    }
  }, {
    key: "_initItems",
    value: function _initItems() {
      var items = this.el.querySelectorAll('.spark-toolbar__item');
      this.items = [];
      for (var i = 0; i < items.length; i++) {
        this.items[i] = new this.toolbarItem(this, items[i], i);
      }
    }

    /**
     * _onTouchStart note touch target
     * @param  {Object} e Event Object
     */
  }, {
    key: "_onTouchStart",
    value: function _onTouchStart(e) {
      if (!this.el.contains(e.target)) {
        this._tapStart = e.target;
      }
    }

    /**
     * _onTouchEnd compare touch start target w/ touch end target, if identical, treat as "tap"
     * @param  {Object} e Event Object
     */
  }, {
    key: "_onTouchEnd",
    value: function _onTouchEnd(e) {
      if (e.target === this._tapStart) {
        this._closeAll();
      }
      this._tapStart = undefined;
    }

    /**
     * Setup event listeners for clicks and resize events
     */
  }, {
    key: "_setupListeners",
    value: function _setupListeners() {
      this._handleWindowClick = this._handleWindowClickH.bind(this);
      document.addEventListener('click', this._handleWindowClick);
      this._onTouchStartBound = this._onTouchStart.bind(this);
      document.addEventListener('touchstart', this._onTouchStartBound, true);
      this._onTouchEndBound = this._onTouchEnd.bind(this);
      document.addEventListener('touchend', this._onTouchEndBound, true);
      this._handleResize = (0, _debounce.default)(this._handleResizeH.bind(this), 100);
      window.addEventListener('resize', this._handleResize);
      this._handleKeyDown = this._handleKeyDownH.bind(this);
      this.el.addEventListener('keydown', this._handleKeyDown);
      this._handleFocus = this._handleFocusH.bind(this);
      document.addEventListener('focus', this._handleFocus, true);
      this._handleBlur = this._handleBlurH.bind(this);
      document.addEventListener('blur', this._handleBlur, true);
      this._handleVisibleChildren = this._handleVisibleChildrenH.bind(this);
      document.addEventListener('spark.visible-children', this._handleVisibleChildren, true);
    }

    /**
     * Remove event listeners for clicks and resize events
     */
  }, {
    key: "_removeListeners",
    value: function _removeListeners() {
      document.removeEventListener('click', this._handleWindowClick);
      document.removeEventListener('touchstart', this._onTouchStartBound, true);
      document.removeEventListener('touchend', this._onTouchEndBound, true);
      window.removeEventListener('resize', this._handleResize);
      this.el.removeEventListener('keydown', this._handleKeyDown);
      document.removeEventListener('blur', this._handleBlur, true);
      document.removeEventListener('focus', this._handleFocus, true);
      document.removeEventListener('spark.visible-children', this._handleVisibleChildren, true);
    }

    /**
     * reset our tab index when user focuses outside of element (gets immediately reset to -1 if focus is placed back inside element)
     * @param {Event} e The FocusEvent
     */
  }, {
    key: "_handleBlurH",
    value: function _handleBlurH(e) {
      if (this.el.contains(e.target)) {
        this.el.attributes.tabindex.value = this.tabindex;
      }
    }

    /**
     * focus handler, works in conjunction with blur handler to set correct tabindex value
     * @param {Event} e The FocusEvent
     */
  }, {
    key: "_handleFocusH",
    value: function _handleFocusH(e) {
      // if we're not being focused, reset our tabindex so we are accessible again, and close anything open
      if (!this.el.contains(e.target)) {
        this._closeAll();
        this.el.attributes.tabindex.value = this.tabindex;
      } else {
        // set our tabindex to -1 so the user can shift-tab out of our element
        this.el.attributes.tabindex.value = -1;
        if (e.target.sparktoolbarcon) {
          this._focusLast();
          return;
        }

        // handle focusing an item
        if (e.target.sparktoolbar) {
          e.target.sparktoolbar.el.focus();
          return;
        }
        var a = e.target;

        // harder case - look up the tree to find if we're focusing inside content
        while (!a.sparktoolbarcon) {
          if (a.sparktoolbar) {
            break;
          }

          // if we are - give our parent element a tabindex so the user can refocus the menu using shift-tab
          if (a.sparktoolbardropdown) {
            this.el.attributes.tabindex.value = this.tabindex;
            return;
          }
          a = a.parentElement;
        }
      }
    }

    /**
     * reset our focus to the last menu item that was focused
     */
  }, {
    key: "_focusLast",
    value: function _focusLast() {
      if (!this._lastFocus) {
        var a = this.visibleContainer.querySelector('.spark-toolbar__item') || this.hiddenContainer.querySelector('.spark-toolbar__item');
        this._lastFocus = a.sparktoolbar;
      }
      if (this.hiddenContainer.contains(this._lastFocus.el)) {
        this._toggleShowMore(true);
      }
      this._lastFocus.el.focus();
    }

    /**
     * keydown handler, used for keyboard navigation
     * @param {Event} e The KeyDown Event
     */
  }, {
    key: "_handleKeyDownH",
    value: function _handleKeyDownH(e) {
      var a = e.target;

      // find the nearest toolbaritem
      while (!a.sparktoolbarcon) {
        if (a.sparktoolbar) {
          break;
        }
        if (a.sparktoolbardropdown) {
          return;
        }
        a = a.parentElement;
      }
      if (a.sparktoolbar) {
        // handle keys
        switch (e.keyCode) {
          // left arrow
          // up arrow
          case 37:
          case 38:
            if (a.previousSibling && a.previousSibling.sparktoolbar) {
              this._lastFocus = a.previousSibling.sparktoolbar;
              a.previousSibling.focus();
            } else {
              if (this.visibleContainer.querySelector('.spark-toolbar__item') !== a.sparktoolbar.el) {
                a = this.visibleContainer.querySelector('.spark-toolbar__item:last-of-type');
                if (a) {
                  this._toggleShowMore(false);
                  this._lastFocus = a.sparktoolbar;
                  a.focus();
                }
              }
            }
            this._closeItems();
            e.preventDefault();
            break;

          // right arrow
          // down arrow
          case 39:
          case 40:
            if (a.nextSibling && a.nextSibling.sparktoolbar) {
              this._lastFocus = a.nextSibling.sparktoolbar;
              a.nextSibling.focus();
            } else {
              if (this.hiddenContainer.querySelector('.spark-toolbar__item:last-of-type') !== a.sparktoolbar.el) {
                a = this.hiddenContainer.querySelector('.spark-toolbar__item');
                if (a) {
                  this._toggleShowMore(true);
                  this._lastFocus = a.sparktoolbar;
                  a.focus();
                }
              }
            }
            this._closeItems();
            e.preventDefault();
            break;

          // spacebar
          case 32:
            e.preventDefault();

            // we only want to toggle the toolbar if we are actually focused directly on it;
            if (e.target.sparktoolbar) {
              e.target.sparktoolbar.el.click();
            }
            break;

          // enter
          case 13:
            // we only want to toggle the toolbar if we are actually focused directly on it;
            if (e.target.sparktoolbar) {
              e.target.sparktoolbar.el.click();
            }
            break;
        }
      }
    }

    /**
     * Hanldes the spark.visible-children event to resize the component when it is made visible.
     * @param {Event} e The spark.visible-children event
     */
  }, {
    key: "_handleVisibleChildrenH",
    value: function _handleVisibleChildrenH(e) {
      if (e.target.contains(this.el)) {
        window.setTimeout(function () {
          this.change();
        }.bind(this), 0);
      }
    }

    /**
     * Event handler for click events, handles window clicks, control element clicks,
     * and forwards events to toolbarItem click handlers as needed
     * @param {Event} e The click event
     */
  }, {
    key: "_handleWindowClickH",
    value: function _handleWindowClickH(e) {
      if ((0, _parseAttribute.boolean)(e.target, 'disabled')) {
        e.preventDefault();
        return;
      }

      // Check to see if the click was outside of the toolbar
      if (!this.el.contains(e.target)) {
        this._closeItems();
        this._toggleShowMore(false);
      } else {
        var a = e.target;
        var toolbarItem = (0, _hasClass.default)(a, 'spark-toolbar__item') ? a : (0, _getParent.default)(a, '.spark-toolbar__item', this.el);
        if (toolbarItem) {
          this.onClick.call(this, toolbarItem, this);
        }

        // traverse the dom node tree until we find an element that handles the event,
        // or we reach the toolbar root node
        if (a === this.visibleContainer || a === this.el) {
          e.stopPropagation();
          e.preventDefault();
          return;
        }
        while (a !== this.el) {
          if (a.sparktoolbar) {
            var c = this._getOpenItems();
            if (c.indexOf(a.sparktoolbar) >= 0) {
              (0, _splice.default)(c).call(c, c.indexOf(a.sparktoolbar), 1);
            }
            this._closeItems(c);
            if (!this.hiddenContainer.contains(e.target)) {
              this._toggleShowMore(false);
            }
            return a.sparktoolbar.handleClick(e);
          }
          if (a.sparktoolbarshowmore) {
            this._closeItems();
            this._toggleShowMore();
            return;
          }
          a = a.parentElement;
        }
        this._closeAll();
      }
    }

    /**
     * Toggle the state of the show more dropdown, optional parameter overrides toggle and
     * sets state to passed value
     * @param {Boolean} open The new state of the show more dropdown
     */
  }, {
    key: "_toggleShowMore",
    value: function _toggleShowMore(open) {
      var o = typeof open !== 'undefined' ? !open : this.isOpen;
      if (o) {
        (0, _removeClass.default)(this.el, 'animate');
        window.setTimeout(function () {
          (0, _removeClass.default)(this.el, 'open');
          this.isOpen = false;
        }.bind(this), 100);
      } else {
        this.isOpen = true;
        (0, _addClass.default)(this.el, 'open');
        this._positionShowMore();
        window.setTimeout(function () {
          (0, _addClass.default)(this.el, 'animate');
        }.bind(this), 0);
      }
    }

    /**
    * Do bounds checking on show-more dropdown when it is opened, and position it accordingly
    */
  }, {
    key: "_positionShowMore",
    value: function _positionShowMore() {
      this.hiddenContainer.style.right = '0px';
      var pos = this.hiddenContainer.getBoundingClientRect();
      var left = window.pageXOffset;
      var right = window.pageXOffset + document.documentElement.clientWidth;
      if (pos.right > right) {
        this.hiddenContainer.style.right = 'calc(' + (pos.right - right) + 'px + 1rem)';
      }
      if (pos.left < left) {
        this.hiddenContainer.style.right = 'calc(' + (pos.left - left) + 'px - 1rem)';
      }
    }

    /**
     * Resize event helper, closes items then triggers recalculation of styles
     */
  }, {
    key: "_handleResizeH",
    value: function _handleResizeH() {
      // If the element isn't there or only the height is changing, don't do anything.
      // Chrome Mobile triggers a resize event when a keyboard opens. see EDL-215
      if (!this.el || this._windowInnerWidth === window.innerWidth) {
        return;
      }
      this._windowInnerWidth = window.innerWidth;
      this._closeAll();
      this._calculateStyles();
    }

    /**
     * Reevaluates the available area of the toolbar and places toolbarItems into
     * the hidden container, as necessary. Should not call with any specified value
     * for showMore (used internally)
     * @param {Boolean} showMore Used to conditionally evaluate styling when showMore area is used
     */
  }, {
    key: "_calculateStyles",
    value: function _calculateStyles(showMore) {
      var _context;
      this.el.style.width = '100%';
      showMore = typeof showMore !== 'undefined' ? showMore : false;
      if (!showMore) {
        (0, _removeClass.default)(this.el, 'show-more');
      }
      var visible = [];
      var hidden = [];
      var i;

      // sort items by their priority to ensure higher-priority items are always placed
      // into the visible area first
      (0, _sort.default)(_context = this.items).call(_context, this._prioritySort);

      // get container width and start placing items into their containers
      var visibleWidth = this.visibleContainer.clientWidth;
      for (i = 0; i < this.items.length; i++) {
        if (visibleWidth - this.items[i].width > 0) {
          visible.push(this.items[i]);
          visibleWidth -= this.items[i].width;
        } else {
          if (!showMore) {
            (0, _addClass.default)(this.el, 'show-more');
            return this._calculateStyles(true);
          }
          hidden.push(this.items[i]);
        }
      }

      // sort items back into their original order before inserting them into the document
      (0, _sort.default)(visible).call(visible, this._orderSort);
      (0, _sort.default)(hidden).call(hidden, this._orderSort);
      var v = document.createDocumentFragment();
      var h = document.createDocumentFragment();
      for (i = 0; i < visible.length; i++) {
        v.appendChild(visible[i].el);
      }
      for (i = 0; i < hidden.length; i++) {
        h.appendChild(hidden[i].el);
      }
      this.visibleContainer.appendChild(v);
      this.hiddenContainer.appendChild(h);
      this.el.style.width = '';
    }

    /**
     * Sorts toolbar items in descending order based on their priority value
     */
  }, {
    key: "_prioritySort",
    value: function _prioritySort(l, r) {
      return r.priority - l.priority;
    }

    /**
     * Sorts toolbar items in ascending order based on their order value
     */
  }, {
    key: "_orderSort",
    value: function _orderSort(l, r) {
      return l.order - r.order;
    }
  }]);
  return Toolbar;
}();
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
Toolbar.prototype._whitelistedParams = ['onClick'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
Toolbar.prototype.defaults = {
  el: null,
  onClick: function onClick() {},
  _windowInnerWidth: 0
};
var _default = Toolbar;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/add-class":59,"../helpers/dom/has-class":61,"../helpers/dom/parse-attribute":66,"../helpers/dom/remove-class":67,"../helpers/traversal/get-parent":87,"../helpers/util/debounce":93,"../helpers/util/each":94,"@babel/runtime-corejs3/core-js-stable/instance/sort":116,"@babel/runtime-corejs3/core-js-stable/instance/splice":117,"@babel/runtime-corejs3/core-js-stable/object/keys":123,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],49:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _hasParent = _interopRequireDefault(require("../helpers/traversal/has-parent"));
var _parseAttribute = require("../helpers/dom/parse-attribute");
var _affix = _interopRequireDefault(require("../helpers/position/affix"));
var _makeElement = _interopRequireDefault(require("../helpers/dom/make-element"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Tooltip
                                                                                                                                                                                                                                                                                                                                              * Show and hide a tooltip.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Tooltip(el, {
                                                                                                                                                                                                                                                                                                                                              *   // Optional. Default anchoring of the content's x and y-axis relative to the button.
                                                                                                                                                                                                                                                                                                                                              *   anchorX: 'center', // 'left', 'center', 'right'
                                                                                                                                                                                                                                                                                                                                              *   anchorY: 'center' // 'top', 'middle', 'bottom'
                                                                                                                                                                                                                                                                                                                                              * });
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/popover.js
                                                                                                                                                                                                                                                                                                                                              */
var Tooltip = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(Tooltip, _BaseComponent);
  var _super = _createSuper(Tooltip);
  function Tooltip(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Tooltip);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._bindEventListenerCallbacks();
    _this._addEventListeners();
    _this.closeTimer = null;
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Open.
   */
  (0, _createClass2.default)(Tooltip, [{
    key: "open",
    value: function open() {
      if (this.affix) return this;
      this.affix = new _affix.default({
        el: this.contentEl,
        targetEl: this.toggleEl,
        caretEl: this.caretEl,
        anchorX: this.anchorX,
        anchorY: this.anchorY
      });
      (0, _addClass.default)(this.contentEl, 'active');
      this.isActive = true;
      this.toggleEl.setAttribute('aria-expanded', 'true');
      return this;
    }

    /**
     * Close.
     */
  }, {
    key: "close",
    value: function close() {
      if (!this.affix) return this;
      (0, _removeClass.default)(this.contentEl, 'active');
      this.el.appendChild(this.contentEl);
      this.affix.remove({
        keepEl: true
      });
      this.affix = null;
      this.isActive = false;
      this.toggleEl.setAttribute('aria-expanded', 'false');
      return this;
    }

    /**
     * Toggle the open state.
     */
  }, {
    key: "toggle",
    value: function toggle() {
      return this[this.isActive ? 'close' : 'open']();
    }

    /**
     * Update the component to use a new element or reparse from
     * the existing element.
     * @param {Element} el Optional
     */
  }, {
    key: "update",
    value: function update(el) {
      if (this.affix) this.affix.update();
      this._removeEventListeners();
      this._cacheElements(el || this.el);
      this._addEventListeners();
      return this;
    }

    /**
     * Close on remove.
     * @param {Boolean} leaveElement
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      this.close();
      (0, _removeClass.default)(this.el, 'tooltip-initialized');
      return (0, _get2.default)((0, _getPrototypeOf2.default)(Tooltip.prototype), "remove", this).call(this, leaveElement);
    }

    /**
     * Store a reference to the tabs list, each tab and each panel.
     * Set which tab is active, or use the first.
     * @param {Element} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.toggleEl = this.el.querySelector('.spark-tooltip__toggle, [data-role="toggle"]') || this.el;
      this.contentEl = this.contentEl || this.el.querySelector('[class*="spark-tooltip__content--"]') || this._createContentEl();
      this.caretEl = this.el.querySelector('.spark-tooltip__caret') || this._createCaretEl();
      if (!(0, _hasParent.default)(this.caretEl, this.contentEl)) {
        this.contentEl.appendChild(this.caretEl);
      }
      this.isActive = (0, _hasClass.default)(this.toggleEl, 'tooltip-active');
      (0, _addClass.default)(this.el, 'tooltip-initialized');
    }

    /**
     * Parse config values from the element.
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      this.anchorY = this.anchorY !== null ? this.anchorY : (0, _parseAttribute.string)(this.el, 'data-anchor-y', null);
      this.anchorX = this.anchorX !== null ? this.anchorX : (0, _parseAttribute.string)(this.el, 'data-anchor-x', null);

      // No anchors defined
      if (!this.anchorY && !this.anchorX) {
        // Left
        if ((0, _hasClass.default)(this.contentEl, 'spark-tooltip__content--left')) {
          this.anchorY = 'middle';
          this.anchorX = 'left';

          // Right
        } else if ((0, _hasClass.default)(this.contentEl, 'spark-tooltip__content--right')) {
          this.anchorY = 'middle';
          this.anchorX = 'right';

          // Top
        } else if ((0, _hasClass.default)(this.contentEl, 'spark-tooltip__content--top')) {
          this.anchorY = 'top';
          this.anchorX = 'center';

          // Bottom
        } else if ((0, _hasClass.default)(this.contentEl, 'spark-tooltip__content--bottom')) {
          this.anchorY = 'bottom';
          this.anchorX = 'center';
        }
      }
    }

    /**
     * Update classes for the open or close state.
     */
  }, {
    key: "_updateAttributes",
    value: function _updateAttributes() {
      (0, _toggleClass.default)(this.el, 'tooltip-active', this.isActive);
      (0, _toggleClass.default)(this.contentEl, 'tooltip-active', this.isActive);
      (0, _toggleClass.default)(this.toggleEl, 'active', this.isActive);
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onMouseoverBound = this._onMouseover.bind(this);
      this._onMouseoutBound = this._onMouseout.bind(this);
      this._onWindowMouseoverBound = this._onWindowMouseover.bind(this);
      this._onFocusBound = this._onFocus.bind(this);
      this._onBlurBound = this._onBlur.bind(this);
      this._onMouseoverToolTipBound = this._onMouseoverToolTip.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.toggleEl.addEventListener('mouseover', this._onMouseoverBound);
      this.toggleEl.addEventListener('mouseout', this._onMouseoutBound);
      this.toggleEl.addEventListener('focus', this._onFocusBound);
      this.toggleEl.addEventListener('blur', this._onBlurBound);
      this.contentEl.addEventListener('mouseover', this._onMouseoverToolTipBound);
      this.contentEl.addEventListener('mouseout', this._onMouseoutBound);
    }

    /**
     * Remove event listeners for DOM events..
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.toggleEl.removeEventListener('mouseover', this._onMouseoverBound);
      this.toggleEl.removeEventListener('mouseout', this._onMouseoutBound);
      this.toggleEl.removeEventListener('focus', this._onFocusBound);
      this.toggleEl.removeEventListener('blur', this._onBlurBound);
      this.contentEl.removeEventListener('mouseover', this._onMouseoverToolTipBound);
      this.contentEl.removeEventListener('mouseout', this._onMouseoutBound);
    }

    /**
     * Add window listeners.
     */
  }, {
    key: "_addWindowEventListeners",
    value: function _addWindowEventListeners() {
      window.addEventListener('mouseover', this._onWindowMouseoverBound);
    }

    /**
     * Remove window listeners.
     */
  }, {
    key: "_removeWindowEventListeners",
    value: function _removeWindowEventListeners() {
      window.removeEventListener('mouseover', this._onWindowMouseoverBound);
    }

    /**
     * Create a content element.
     * @return {Element}
     */
  }, {
    key: "_createContentEl",
    value: function _createContentEl() {
      return (0, _makeElement.default)('<div class="spark-tooltip__content"></div>');
    }

    /**
     * Create the caret element.
     * @return {Element}
     */
  }, {
    key: "_createCaretEl",
    value: function _createCaretEl() {
      return (0, _makeElement.default)('<div class="spark-tooltip__caret"></div>');
    }

    /**
     * Open the tooltip on mouseover.
     */
  }, {
    key: "_onMouseover",
    value: function _onMouseover() {
      clearTimeout(this.closeTimer);
      this._addWindowEventListeners();
      this.open();
    }

    /**
     * Clear close timer when mouse is over tooltip content.
     */
  }, {
    key: "_onMouseoverToolTip",
    value: function _onMouseoverToolTip() {
      clearTimeout(this.closeTimer);
    }

    /**
     * Close the tooltip on mouseout.
     */
  }, {
    key: "_onMouseout",
    value: function _onMouseout() {
      var _this2 = this;
      this._removeWindowEventListeners();
      clearTimeout(this.closeTimer);
      this.closeTimer = setTimeout(function () {
        _this2.close();
      }, 100);
    }

    /**
     * Open the tooltip on focus.
     */
  }, {
    key: "_onFocus",
    value: function _onFocus() {
      this._addWindowEventListeners();
      this.open();
    }

    /**
     * Close the tooltip on blur.
     */
  }, {
    key: "_onBlur",
    value: function _onBlur() {
      this._removeWindowEventListeners();
      this.close();
    }

    /**
     * Close the tooltip if we mouse over another element.
     * @param {Object} e
     */
  }, {
    key: "_onWindowMouseover",
    value: function _onWindowMouseover(e) {
      if (e.target === this.el || (0, _hasParent.default)(e.target, this.el)) return;
      this._onMouseout();
    }
  }]);
  return Tooltip;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
Tooltip.prototype._whitelistedParams = ['anchorY', 'anchorX', 'contentEl', 'toggleEl'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
Tooltip.prototype.defaults = {
  el: null,
  toggleEl: null,
  contentEl: null,
  caretEl: null,
  isActive: false,
  affix: null,
  anchorY: null,
  anchorX: null,
  _onMouseoverBound: null,
  _onMouseoutBound: null,
  _onFocusBound: null,
  _onBlurBound: null,
  _onWindowMouseoverBound: null
};
var _default = Tooltip;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/add-class":59,"../helpers/dom/has-class":61,"../helpers/dom/make-element":62,"../helpers/dom/parse-attribute":66,"../helpers/dom/remove-class":67,"../helpers/dom/toggle-class":68,"../helpers/position/affix":81,"../helpers/traversal/has-parent":91,"./base":3,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],50:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _splice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/splice"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _base = _interopRequireDefault(require("./base"));
var _triggerEvent = _interopRequireDefault(require("../helpers/dom/trigger-event"));
var _parseAttribute = require("../helpers/dom/parse-attribute");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Typeahead
                                                                                                                                                                                                                                                                                                                                              * Listen to an input element and format it as the user types.
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Typeahead(el);
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/typeahead.js
                                                                                                                                                                                                                                                                                                                                              */
var noop = function noop() {};
var Typeahead = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(Typeahead, _BaseComponent);
  var _super = _createSuper(Typeahead);
  /**
   * Typeahead constructor
   * @param {Element} el
   * @param {Object} params
   */
  function Typeahead(el) {
    var _this;
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Typeahead);
    params.elRequired = true;
    if (!(_this = _super.call(this, el, params))) {
      return (0, _possibleConstructorReturn2.default)(_this);
    }
    _this._maintainFocus(function () {
      this._parseParams();
      this._bindEventListenerCallbacks();
      this._addEventListeners();
    });
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Run the formatting.
   * @param {Number} cursorIndex
   */
  (0, _createClass2.default)(Typeahead, [{
    key: "run",
    value: function run(cursorIndex) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (this.isRunning) return this;
      this.isRunning = true;
      var oldVal = this.inputEl.value;
      var val = '';
      var placeholder = '';
      var i = 0;
      var len = this.format.length;
      var skipCount = 0;
      var valDone = false;
      for (; i < len; i++) {
        // Add numbers
        if (this.format[i] === '\\d') {
          if (this.characters[i - skipCount]) {
            val += this.characters[i - skipCount];
          } else {
            valDone = true;
          }
          placeholder += valDone && this.placeholder[i] ? this.placeholder[i] : '&nbsp;';

          // Placeholder characters
        } else {
          if (!valDone) {
            val += this.format[i];
          }
          placeholder += this.format[i];
          skipCount++;
        }
      }
      if (this.isFocused) {
        cursorIndex = cursorIndex === undefined ? this._getCaretEnd() : cursorIndex;
      }

      // If there are no characters, set the cursorIndex to be the last placeholder entry.
      if (this.isFocused && !this.characters.length) {
        cursorIndex = val.length;
      }

      // No characters and we shouldn't use just placeholder values
      if (!this.characters.length && params.notOnlyPlaceholders) {
        val = '';
      }
      this.inputEl.value = val;
      this.placeholderEl.innerHTML = placeholder;
      this._updateWidth();
      if (this.isFocused) {
        this._setCaretPositionTranslated(cursorIndex);
      }
      if (val !== oldVal) {
        (0, _triggerEvent.default)(this.inputEl, 'input');
      }
      this.isRunning = false;
      if (val !== oldVal) {
        (this.onChange || noop)(val, oldVal, this);
      }
      if (!this._atEnd && this.isFocused && this.characters.length === this.maxLength && this._caretIsAtEnd()) {
        this._atEnd = true;
        (this.onEnd || noop)(this);
      } else {
        this._atEnd = false;
      }
      return this;
    }

    /**
     * Add a character to the characters array at a given index.
     * @param {String} character
     * @param {Number} start
     * @param {Number} end
     * @param {Boolean} skipCheck
     */
  }, {
    key: "addCharacterAtIndex",
    value: function addCharacterAtIndex(character, start, end, skipCheck) {
      var _context;
      // Don't add at an index beyond what we can support.
      if (this.maxLength && start >= this.maxLength) {
        return this;
      }
      if (!skipCheck) {
        var re;

        // Try to build a regex for this format character.
        try {
          re = new RegExp(this.format[start]);
        } catch (e) {

          //
        }
        if (!re || !re.exec(character)) {
          return this;
        }
      }
      (0, _splice.default)(_context = this.characters).call(_context, start, end - start, character);

      // If we've added at an index that pushes the length beyond what we support,
      // remove the trailing characters.
      if (this.maxLength && this.characters.length > this.maxLength) {
        var _context2;
        (0, _splice.default)(_context2 = this.characters).call(_context2, this.maxLength, this.characters.length);
      }
      this.run(start + 1);
      return this;
    }

    /**
     * Add a character at the position of the caret.
     * @param {String} character
     */
  }, {
    key: "addCharacterAtCaret",
    value: function addCharacterAtCaret(character) {
      var pos = this._getCaretStart();
      var re;

      // If we're beyond the bounds of the format, stop.
      if (this.format[pos] === undefined) {
        (this.onEnd || noop)(this, character);
        return this;
      }

      // Try to build a regex for this format character.
      try {
        re = new RegExp(this.format[pos]);
      } catch (e) {

        //
      }

      // We couldn't build a regex (so it's invalid) or the regex failed (so it's invalid)
      if (!re || !re.exec(character)) {
        if (this._moveCaret('right')) {
          this.addCharacterAtCaret(character);
        }
        return this;
      }
      this.addCharacterAtIndex(character, this._getCaretStartTranslated(), this._getCaretEndTranslated(), true);
      return this;
    }

    /**
     * Remove a character from the character array by index.
     * @param {Number} index
     * @param {Number} length Optional
     * @param {Number} offset Optional
     */
  }, {
    key: "removeCharacterAtIndex",
    value: function removeCharacterAtIndex(index, length, offset) {
      var _context3;
      // Don't want a negative splice length or else we start
      // removing characters from the end.
      if (index + offset < 0) {
        return this;
      }
      length = length !== undefined ? length : 1;
      (0, _splice.default)(_context3 = this.characters).call(_context3, index + offset, length);
      this.run(index + (offset || 1));
      return this;
    }

    /**
     * Remove the character at the caret.
     * @param {Number} offset Optional An offset from the current position.
     */
  }, {
    key: "removeCharacterAtCaret",
    value: function removeCharacterAtCaret(offset) {
      var start = this._getCaretStartTranslated();
      var end = this._getCaretEndTranslated();
      var length = 1;
      var tmp;
      if (start !== end) {
        // If the end is less than the start, the user dragged from right to left.
        // Just swap them to make it easier to handle.
        if (end < start) {
          tmp = start;
          start = end;
          end = tmp;
        }

        // The length of characters removed
        length = end - start;

        // Bump the start position @todo: haven't thought through why this is, but it's needed.
        start++;
      }
      this.removeCharacterAtIndex(start, length, offset);
      return this;
    }

    /**
     * Remove the character in the current range.
     */
  }, {
    key: "removeCharactersInRange",
    value: function removeCharactersInRange() {
      this.removeCharacterAtIndex(this._getCaretStartTranslated(), this._getCaretEndTranslated());
      return this;
    }

    /**
     * Set the value of the typeahead. Maintain the position of the caret.
     * @param {String} value
     */
  }, {
    key: "setValue",
    value: function setValue(value) {
      this.settingValue = true;
      this.pause();
      if (typeof value === 'string') {
        this.characters = (value.replace(/\W/g, '') + '').split('');
      } else if (typeof value === 'number') {
        // Perform regex replace if a float is set
        if (value % 1 !== 0) {
          this.characters = (value.toString().replace(/\W/g, '') + '').split('');
        } else {
          this.characters = (value + '').split('');
        }
      }
      this.run();
      if (this.isFocused) this._setCaretPosition(this._getCaretStart());
      this.resume();
      this.settingValue = false;
      return this;
    }

    /**
     * Get the value of the typeahead.
     * @param {Boolean} asInt Get the value as a parsed integer.
     * @return {String|Number}
     */
  }, {
    key: "getValue",
    value: function getValue(asInt) {
      return asInt && this.inputEl.value ? parseInt(this.inputEl.value, 10) : this.inputEl.value;
    }

    /**
     * Clear the selected value.
     */
  }, {
    key: "clearValue",
    value: function clearValue() {
      this.pause();
      this.characters = [];
      this.run(0, {
        notOnlyPlaceholders: true
      });
      return this.resume();
    }

    /**
     * Take the date values from the inputs and set them as dates on the calendar.
     */
  }, {
    key: "updateValue",
    value: function updateValue() {
      return this.setValue(this.inputEl.value);
    }

    /**
     * Move the caret position.
     * @param {Number} pos
     */
  }, {
    key: "moveCaret",
    value: function moveCaret(pos) {
      this._setCaretPositionTranslated(pos);
      return this;
    }

    /**
     * Move the caret to the end of the input.
     */
  }, {
    key: "moveCaretToEnd",
    value: function moveCaretToEnd() {
      return this.moveCaret(this.characters.length);
    }

    /**
     * Move the caret to the start of the input.
     */
  }, {
    key: "moveCaretToStart",
    value: function moveCaretToStart() {
      return this.moveCaret(0);
    }

    /**
     * Pause events.
     */
  }, {
    key: "pause",
    value: function pause() {
      this.pauseBlurFocus++;
      return this;
    }

    /**
     * Resume events.
     */
  }, {
    key: "resume",
    value: function resume() {
      this.pauseBlurFocus--;
      return this;
    }

    /**
     * Disable entry into the input.
     */
  }, {
    key: "disable",
    value: function disable() {
      this.inputEl.setAttribute('disabled', '');
      return this;
    }

    /**
     * Enable entry into the input.
     */
  }, {
    key: "enable",
    value: function enable() {
      this.inputEl.removeAttribute('disabled');
      return this;
    }

    /**
     * Clear the value.
     * Changed to clearValue in v2.0.0.
     */
  }, {
    key: "clear",
    value: function clear() {
      return this.clearValue();
    }

    /**
     * Augment default remove call w/ helper cleanup.
     * @param {Boolean} leaveElement Leave the element intact.
     */
  }, {
    key: "remove",
    value: function remove(leaveElement) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(Typeahead.prototype), "remove", this).call(this, leaveElement);
      return this;
    }

    /**
     * Store a reference to the needed elements.
     * @param {Object} el
     */
  }, {
    key: "_cacheElements",
    value: function _cacheElements(el) {
      this.el = el;
      this.inputEl = this.el.querySelector('[type="text"], [type="email"], [type="phone"], [type="tel"], textarea') || this._createDefaultInputElement();
      this.placeholderEl = this.el.querySelector('.spark-input__placeholder') || this._createDefaultPlaceholderElement();
    }

    /**
     * Parse parameters from the elements.
     */
  }, {
    key: "_parseParams",
    value: function _parseParams() {
      // Store the value characters
      this.characters = this._parseCharacters(this.inputEl.value);

      // Store format
      this.format = this._parseFormat(this.format ? this.format : this.inputEl.getAttribute('data-typeahead-format'));

      // Store the original placeholder
      this.placeholder = this.placeholder ? this.placeholder : this.inputEl.getAttribute('placeholder').split('');

      // Get the total number of characters we can have
      this.maxLength = this._getCharactersAllowedCount(this.format);
      this.matchPlaceholderSize = this.matchPlaceholderSize !== null ? this.matchPlaceholderSize : (0, _parseAttribute.boolean)(this.inputEl, 'data-match-placeholder-size', false);
    }

    /**
     * Parse the format string into an array.
     * @param  {String} format
     * @return {Array}
     */
  }, {
    key: "_parseFormat",
    value: function _parseFormat(format) {
      var i = 0;
      var len = format.length;
      var arr = [];
      var lastWasEscape = false;
      for (; i < len; i++) {
        if (format[i] === '\\' && !lastWasEscape) {
          lastWasEscape = true;
        } else {
          arr.push((lastWasEscape ? '\\' : '') + format[i]);
          lastWasEscape = false;
        }
      }
      return arr;
    }

    /**
     * Parse the characters string into an array, ignoring characters which don't
     * match the format requirements.
     * @param {String} characters
     * @return {Array}
     */
  }, {
    key: "_parseCharacters",
    value: function _parseCharacters(characters) {
      var chars = characters.split('');
      var i = 0;
      var len = characters.length;
      var regexes = [];
      var arr = [];
      for (; i < len; i++) {
        // Try to build a regex for this format character.
        try {
          // Make sure this format starts with an escape character.
          regexes[i] = this.format[i][0] === '\\' ? new RegExp(this.format[i]) : null;
        } catch (e) {

          //
        }

        // If we were able to create a regex and our char passes, add it to the array
        // of characters to return.
        if (regexes[i] && regexes[i].exec(chars[i])) {
          arr.push(chars[i]);
        }
      }
      return arr;
    }

    /**
     * Create the default input element.
     * @return {Element}
     */
  }, {
    key: "_createDefaultInputElement",
    value: function _createDefaultInputElement() {
      var el = document.createElement('input');
      el.className = 'spark-input__field';
      el.setAttribute('data-typeahead', '');
      el.setAttribute('type', 'tel');
      this.el.appendChild(el);
      return el;
    }

    /**
     * Create the default input element.
     * @return {Element}
     */
  }, {
    key: "_createDefaultPlaceholderElement",
    value: function _createDefaultPlaceholderElement() {
      var el = document.createElement('span');
      el.className = 'spark-input__placeholder';
      this.el.appendChild(el);
      return el;
    }

    /**
     * Get the maximum number of characters allowed.
     * @param {Array} format
     * @return {Number}
     */
  }, {
    key: "_getCharactersAllowedCount",
    value: function _getCharactersAllowedCount(format) {
      var i = 0;
      var len = format.length;
      var allowed = 0;
      for (; i < len; i++) {
        if (format[i] === '\\d') {
          allowed++;
        }
      }
      return allowed;
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onKeydownBound = this._onKeydown.bind(this);
      this._onKeypressBound = this._onKeypress.bind(this);
      this._onFocusBound = this._onFocus.bind(this);
      this._onBlurBound = this._onBlur.bind(this);
      this._onInputBound = this._onInput.bind(this);
      this._onPlaceholderClickBound = this._onPlaceholderClick.bind(this);
    }

    /**
     * Add event listeners to keypress and keydown.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.inputEl.addEventListener('keydown', this._onKeydownBound, false);
      this.inputEl.addEventListener('keypress', this._onKeypressBound, false);
      this.inputEl.addEventListener('focus', this._onFocusBound, false);
      this.inputEl.addEventListener('input', this._onInputBound, false);
      this.placeholderEl.addEventListener('click', this._onPlaceholderClickBound, false);
    }

    /**
     * Add event listeners to keypress and keydown.
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.inputEl.removeEventListener('keydown', this._onKeydownBound);
      this.inputEl.removeEventListener('keypress', this._onKeypressBound);
      this.inputEl.removeEventListener('focus', this._onFocusBound);
      this.inputEl.removeEventListener('input', this._onInputBound);
      this.placeholderEl.removeEventListener('click', this._onPlaceholderClickBound);
      window.removeEventListener('blur', this._onBlurBound);
      this.inputEl.removeEventListener('blur', this._onBlurBound);
    }

    /**
     * Get the position of the caret in the element.
     * @return {Number} The index
     */
  }, {
    key: "_getCaretStart",
    value: function _getCaretStart() {
      return this._maintainFocus(function () {
        var caretPosition;

        // IE support
        if (document.selection) {
          this.inputEl.focus();
          var sel = document.selection.createRange();
          sel.moveStart('character', -this.inputEl.value.length);
          caretPosition = sel.text.length;
        } else if (this.inputEl && this.inputEl.selectionStart || this.inputEl && this.inputEl.selectionStart === 0) {
          caretPosition = this.inputEl.selectionStart;
        }
        return caretPosition;
      });
    }

    /**
     * Get the end position of the caret in the element.
     * @return {Number} The index
     */
  }, {
    key: "_getCaretEnd",
    value: function _getCaretEnd() {
      return this._maintainFocus(function () {
        var caretPosition;

        // IE support
        if (document.selection) {
          this.inputEl.focus();
          var sel = document.selection.createRange();
          sel.moveStart('character', -this.inputEl.value.length);
          caretPosition = sel.text.length;
        } else if (this.inputEl.selectionEnd || this.inputEl.selectionEnd === 0) {
          caretPosition = this.inputEl.selectionEnd;
        }
        return caretPosition;
      });
    }

    /**
     * Is the caret at the end of the input?
     * @return {Boolean}
     */
  }, {
    key: "_caretIsAtEnd",
    value: function _caretIsAtEnd() {
      return this._getCaretStart() === this.maxLength;
    }

    /**
     * Set the position of the caret in the element.
     * @return {Number} The index
     */
  }, {
    key: "_setCaretPosition",
    value: function _setCaretPosition(pos) {
      return this._maintainFocus(function () {
        // IE support
        if (document.selection) {
          this.inputEl.focus();
          var sel = document.selection.createRange();
          sel.moveStart('character', -this.inputEl.value.length);
          sel.moveStart('character', pos);
          sel.moveEnd('character', 0);
          sel.select();
        } else if (this.inputEl.selectionStart || this.inputEl.selectionStart === 0) {
          this.inputEl.selectionStart = pos;
          this.inputEl.selectionEnd = pos;
        }
      });
    }

    /**
     * Get the position of the caret translated to the corresponding index in the
     * characters array. This means ignoring format characters.
     * @param {Number} pos
     * @return {Number}
     */
  }, {
    key: "_getCaretPositionTranslated",
    value: function _getCaretPositionTranslated(pos) {
      var i = 0;
      var skipCount = 0;
      for (; i < pos; i++) {
        // Count non-numbers as a skip.
        // @todo: this needs to work with more than numbers.
        if (this.format[i] !== '\\d') {
          skipCount++;
        }
      }
      return pos - skipCount;
    }

    /**
     * Get the starting position of the caret translated.
     * @return {Number}
     */
  }, {
    key: "_getCaretStartTranslated",
    value: function _getCaretStartTranslated() {
      return this._getCaretPositionTranslated(this._getCaretStart());
    }

    /**
     * Get the ending position of the caret translated.
     * @return {Number}
     */
  }, {
    key: "_getCaretEndTranslated",
    value: function _getCaretEndTranslated() {
      return this._getCaretPositionTranslated(this._getCaretEnd());
    }

    /**
     * Set the position of the caret translated to the corresponding index in the
     * characters array. This means ignoring format characters.
     * @param {Number} pos
     */
  }, {
    key: "_setCaretPositionTranslated",
    value: function _setCaretPositionTranslated(pos) {
      var i = 0;
      var skipCount = 0;
      for (; i < pos + skipCount; i++) {
        // Count non-numbers as a skip.
        // @todo: this needs to work with more than numbers.
        if (this.format[i] !== undefined && this.format[i] !== '\\d') {
          skipCount++;
        }
      }
      this._setCaretPosition(pos + skipCount);
    }

    /**
     * Move the caret position
     * @param  {String} direction The direction of the movement
     * @return {Boolean}           Was the caret actually moved?
     */
  }, {
    key: "_moveCaret",
    value: function _moveCaret(direction) {
      var curPos = this._getCaretStart();
      if (direction === 'left') {
        this._setCaretPosition(curPos - 1);
      } else if (direction === 'right') {
        this._setCaretPosition(curPos + 1);
      }
      return curPos !== this._getCaretStart();
    }

    /**
     * Empty the input when we only have placeholders.
     */
  }, {
    key: "_emptyWhenOnlyPlaceholders",
    value: function _emptyWhenOnlyPlaceholders() {
      if (!this.characters.length) {
        this.clear();
      }
    }

    /**
     * Run a callback function that may change the focus of the document, but
     * make sure focus goes back to where it needs to be. Also, set the state
     * so that blur/focus events don't fire from this instance.
     * @param {Function} callback
     */
  }, {
    key: "_maintainFocus",
    value: function _maintainFocus(callback) {
      this.pause();
      var originalActiveElement = document.activeElement;

      // For IE
      if (!originalActiveElement) {
        originalActiveElement = document.body;
      }
      var output = (callback || noop).call(this);

      // If we didn't have focus, go back to focusing on the original
      if (this.inputEl && originalActiveElement !== this.inputEl) {
        this.inputEl.blur();
        originalActiveElement ? originalActiveElement.focus() : null;
      }
      this.resume();
      return output;
    }

    /**
     * Update the width of the typeahead. If we should be matching the width
     * of the placeholder, do so. Otherwise, take no action.
     */
  }, {
    key: "_updateWidth",
    value: function _updateWidth() {
      if (this.matchPlaceholderSize) {
        this.placeholderEl.style.width = 'auto';

        // Add 2px to account for caret width in IE...
        this.inputEl.style.width = 'auto';
        this.inputEl.style.width = this.placeholderEl.offsetWidth + 2 + 'px';
        this.placeholderEl.style.width = '';
      }
    }

    /**
     * Listen for delete and arrows.
     * @param  {Object} e
     */
  }, {
    key: "_onKeydown",
    value: function _onKeydown(e) {
      var code = e.keyCode || e.which;
      if (code === this.pasteCode && (e.metaKey || e.ctrlKey)) {
        return;
      }
      if (code === this.actionCodes.BACKSPACE) {
        this.removeCharacterAtCaret(-1);
        this._onBackspace();
        e.preventDefault();
      } else if (code === this.actionCodes.DELETE) {
        this.removeCharacterAtCaret(0);
        e.preventDefault();
      } else if (code === this.actionCodes.LEFT) {
        if (!this._getCaretStart()) {
          (this.onBackspace || noop)();
        }
      } else if (code === this.actionCodes.RIGHT) {
        if (this._getCaretStart() === this.characters.length) {
          (this.onEnd || noop)();
        }
      } else {
        if (this.ignoreCodes.indexOf(code) === -1) {
          e.preventDefault();

          // Account for Numpad keys
          if (code >= 96 && code <= 105) {
            code -= 48;
          }
          this.addCharacterAtCaret(String.fromCharCode(code));
        }
      }
    }

    /**
     * When the keypress event fires, validate.
     * @param {Object} e
     */
  }, {
    key: "_onKeypress",
    value: function _onKeypress(e) {
      var code = e.keyCode || e.which;
      if (this.ignoreCodes.indexOf(code) === -1) {
        e.preventDefault();
        this.characters = this._parseCharacters(this.inputEl.value);
        this.run();
        (this.onChange || noop)(this.getValue(), this);
      }
    }

    /**
     * When the input event fires, validate. This happens
     * with a copy+paste.
     * @param {Object} e
     */
  }, {
    key: "_onInput",
    value: function _onInput(e) {
      e.preventDefault();
      this.characters = this._parseCharacters(this.inputEl.value);
      this.run();
      (this.onInput || noop)(this.getValue(), this);
    }

    /**
     * When we focus, run the formatting.
     * @param {Object} e
     */
  }, {
    key: "_onFocus",
    value: function _onFocus() {
      // Fix issue in IE where onFocus is triggered after onBlur for inputs using Typeahead
      if (document.activeElement !== this.inputEl) return;
      window.removeEventListener('blur', this._onBlurBound);
      window.addEventListener('blur', this._onBlurBound, false);
      this.inputEl.removeEventListener('blur', this._onBlurBound);
      this.inputEl.addEventListener('blur', this._onBlurBound, false);
      if (this.isFocused || this.pauseBlurFocus || this.isRunning) return;
      this.run();
      if (typeof this.onFocus === 'function') {
        this.onFocus(this.getValue(), this);
      }
      this.isFocused = true;
      this._oldVal = this.inputEl.value;
    }

    /**
     * When we blur, if we have no characters, remove the placeholders.
     * @param {Object} e
     */
  }, {
    key: "_onBlur",
    value: function _onBlur() {
      window.removeEventListener('blur', this._onBlurBound);
      this.inputEl.removeEventListener('blur', this._onBlurBound);
      this.isFocused = false;
      if (this.pauseBlurFocus || this.isRunning) return;
      this._emptyWhenOnlyPlaceholders();
      if (this._oldVal !== this.inputEl.value) {
        (0, _triggerEvent.default)(this.inputEl, 'change');
      }
      (this.onBlur || noop)(this.getValue(), this);
    }

    /**
     * When the placeholder receives a click event, focus on the input. This happens in IE10 for some
     * reason that I cannot fully fathom, but it has something to do with the explicit width being
     * set on an empty element.
     * @param {Object} e
     */
  }, {
    key: "_onPlaceholderClick",
    value: function _onPlaceholderClick(e) {
      e.preventDefault();
      e.stopPropagation();
      this.inputEl.focus();
    }

    /**
     * When we backspace, if we have no characters left let listeners know.
     * @param {Object} e
     */
  }, {
    key: "_onBackspace",
    value: function _onBackspace() {
      if (!this._getCaretStart()) (this.onBackspace || noop)();
    }
  }]);
  return Typeahead;
}(_base.default);
/**
 * Whitelisted parameters which can be set on construction.
 * @type {Array}
 */
Typeahead.prototype._whitelistedParams = ['format', 'placeholder', 'matchPlaceholderSize', 'onChange', 'onFocus', 'onBlur', 'onInput', 'onBackspace', 'onEnd'];

/**
 * Default values for internal properties we will be setting.
 * These are set on each construction so we don't leak properties
 * into the prototype chain.
 * @type {Object}
 */
Typeahead.prototype.defaults = {
  el: null,
  inputEl: null,
  placeholderEl: null,
  placeholder: null,
  characters: null,
  format: null,
  ignoreCodes: [
  // Tab
  9,
  // Shift
  16,
  // Ctrl
  17,
  // Alt
  18,
  // CAPS
  20,
  // Meta
  91,
  // Alt
  93,
  // F1-F12
  112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123],
  actionCodes: {
    BACKSPACE: 8,
    DELETE: 46,
    LEFT: 37,
    RIGHT: 39
  },
  // v
  pasteCode: 86,
  pauseBlurFocus: 0,
  matchPlaceholderSize: null,
  maxLength: null,
  isFocused: false,
  isRunning: false,
  onChange: null,
  onFocus: null,
  onBlur: null,
  onInput: null,
  onBackspace: null,
  onEnd: null,
  _atEnd: false,
  _oldVal: null,
  _onKeydownBound: null,
  _onKeypressBound: null,
  _onFocusBound: null,
  _onBlurBound: null,
  _onInputBound: null,
  _onPlaceholderClickBound: null
};
var _default = Typeahead;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/parse-attribute":66,"../helpers/dom/trigger-event":69,"./base":3,"@babel/runtime-corejs3/core-js-stable/instance/splice":117,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/get":147,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],51:[function(require,module,exports){
"use strict";

var _Reflect$construct = require("@babel/runtime-corejs3/core-js-stable/reflect/construct");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/defineProperty"));
var _base = _interopRequireDefault(require("./base"));
var _addClass = _interopRequireDefault(require("../helpers/dom/add-class"));
var _hasClass = _interopRequireDefault(require("../helpers/dom/has-class"));
var _makeElement = _interopRequireDefault(require("../helpers/dom/make-element"));
var _removeClass = _interopRequireDefault(require("../helpers/dom/remove-class"));
var _toggleClass = _interopRequireDefault(require("../helpers/dom/toggle-class"));
var _mixin = _interopRequireDefault(require("../helpers/util/mixin"));
var _events = _interopRequireDefault(require("../mixins/events"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /**
                                                                                                                                                                                                                                                                                                                                              * # Underlay
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @example
                                                                                                                                                                                                                                                                                                                                              * new Spark.Underlay();
                                                                                                                                                                                                                                                                                                                                              *
                                                                                                                                                                                                                                                                                                                                              * @module components/underlay.js
                                                                                                                                                                                                                                                                                                                                              * @since 3.3.0
                                                                                                                                                                                                                                                                                                                                              */
/**
 * Underlay
 * @class creates an Underlay
 */
var Underlay = /*#__PURE__*/function (_BaseComponent) {
  (0, _inherits2.default)(Underlay, _BaseComponent);
  var _super = _createSuper(Underlay);
  /**
   * Underlay constructor.
   * @param {Object} params
   * @constructor
   */
  function Underlay() {
    var _this;
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, Underlay);
    if (Underlay.instance) {
      Underlay.instance.config = params;
      return (0, _possibleConstructorReturn2.default)(_this, Underlay.instance);
    } else {
      _this = _super.call(this, undefined, params);
      _this._cacheElements();
      _this._bindEventListenerCallbacks();
      _this._addEventListeners();
      _this.style = params.style ? params.style : 'dark';
      if (params.interactive !== undefined) _this.interactive = params.interactive;
      if (params.display !== undefined) _this.display = params.display;

      // Temporarily fixing `animate` to `false`
      // if (params.animate !== undefined) this.animate = params.animate;
      _this.animate = false;
    }
    return (0, _possibleConstructorReturn2.default)(_this);
  }

  /**
   * Sets up references
   * @private
   */
  (0, _createClass2.default)(Underlay, [{
    key: "_cacheElements",
    value: function _cacheElements() {
      Underlay.instance = this;
      this.el = document.getElementById('spark-underlay');
      if (!this.el) {
        this.el = (0, _makeElement.default)('<div id="spark-underlay" data-interactive hidden></div>');
        document.body.appendChild(this.el);
      }
    }

    /**
     * Create bound versions of event listener callbacks and store them.
     * Otherwise we can't unbind from these events later because the
     * function signatures won't match.
     * @private
     */
  }, {
    key: "_bindEventListenerCallbacks",
    value: function _bindEventListenerCallbacks() {
      this._onMouseDownBound = this._onMouseDown.bind(this);
      this._onTouchMoveBound = this._onTouchMove.bind(this);
      this._onClickBound = this._onClick.bind(this);
      this._onDismissBound = this._onDismiss.bind(this);
    }

    /**
     * Add event listeners for DOM events.
     * @private
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this.el.addEventListener('mousedown', this._onMouseDownBound, true);
      this.el.addEventListener('touchmove', this._onTouchMoveBound, true);
      this.el.addEventListener('click', this._onClickBound, true);
      this.el.addEventListener('dismiss', this._onDismissBound, true);
    }

    /**
     * Remove event listeners for DOM events..
     * @private
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      this.el.removeEventListener('mousedown', this._onMouseDownBound, true);
      this.el.removeEventListener('touchmove', this._onTouchMoveBound, true);
      this.el.removeEventListener('click', this._onClickBound, true);
      this.el.removeEventListener('dismiss', this._onDismissBound, true);
    }

    /**
     * On Mouse Down
     * @param {Object} e
     * @private
     */
  }, {
    key: "_onMouseDown",
    value: function _onMouseDown(e) {
      if (!this.interactive) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    }

    /**
     * On Touch Move, prevent scrolling
     * @param {Object} e
     * @private
     */
  }, {
    key: "_onTouchMove",
    value: function _onTouchMove(e) {
      if ((0, _hasClass.default)(document.body, 'spark-no-scroll')) {
        e.preventDefault();
      }
    }

    /**
     * On Click
     * @param {Object} e
     * @private
     */
  }, {
    key: "_onClick",
    value: function _onClick(e) {
      if (!this.interactive) {
        e.preventDefault();
        e.stopPropagation();
      } else {
        this.trigger('dismiss');
      }
    }

    /**
     * On Dismiss
     * @private
     */
  }, {
    key: "_onDismiss",
    value: function _onDismiss() {
      this.hide().then(function () {
        Underlay.instance.trigger('change', {
          display: Underlay.instance.display
        });
      }).catch(function () {});
    }

    /**
     * Re-configure Underlay
     * @param {Object} params
     * @return {Promise}
     */
  }, {
    key: "configure",
    value: function configure() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new _promise.default(function (resolve, reject) {
        if (params.animate !== undefined) Underlay.instance.animate = params.animate;
        if (params.interactive !== undefined) Underlay.instance.interactive = params.interactive;
        if (params.display !== undefined && params.style !== Underlay.instance.style) {
          if (params.display) {
            Underlay.instance.style = params.style;
            Underlay.instance.show().then(resolve).catch(function () {
              reject(new Error('Underlay not visible'));
            });
          } else {
            Underlay.instance.hide().then(function () {
              Underlay.instance.style = params.style;
              resolve();
            }).catch(function () {
              reject(new Error('Underlay is visible'));
            });
          }
        } else {
          if (params.style) Underlay.instance.style = params.style;
          if (params.display !== undefined && params.display === false) {
            Underlay.instance.hide().then(resolve).catch(function () {
              reject(new Error('Underlay is visible'));
            });
          } else if (params.display === true) {
            Underlay.instance.show().then(resolve).catch(function () {
              reject(new Error('Underlay not visible'));
            });
          }
          resolve();
        }
      });
    }

    /**
     * setter for configuration
     * @param {Object} param
     */
  }, {
    key: "config",
    get:
    /**
     * getter for current configuration
     * @return {Object}
     */
    function get() {
      return {
        animate: this.animate,
        display: this.display,
        interactive: this.interactive,
        style: this.style
      };
    }

    /**
     * show Underlay
     * @param {Object} options
     * @return {Promise}
     */,
    set: function set() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.configure(params).catch(function () {});
    }
  }, {
    key: "show",
    value: function show() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new _promise.default(function (resolve, reject) {
        if (!Underlay.instance.el.hidden && ((0, _hasClass.default)(Underlay.instance.el, 'no-animate') || !(0, _hasClass.default)(Underlay.instance.el, 'hide'))) {
          resolve();
        } else {
          Underlay.instance.trigger('reveal');
          if (options.animate !== undefined) Underlay.instance.animate = options.animate;
          if (Underlay.instance.animate) {
            Underlay.instance.el.addEventListener('animationend', function onVisible(e) {
              Underlay.instance.el.removeEventListener('animationend', onVisible);
              if (e.animationName === 'reveal-underlay') {
                Underlay.instance.trigger('show');
                resolve();
              } else {
                reject(new Error('Underlay was hidden'));
              }
            });
          }
          if (options.style) Underlay.instance.style = options.style;
          if (options.interactive !== undefined) Underlay.instance.interactive = options.interactive;
          (0, _addClass.default)(document.body, 'spark-no-scroll');
          (0, _addClass.default)(document.body, 'spark-no-select');
          Underlay.instance.el.hidden = false;
          if (!Underlay.instance.animate) {
            Underlay.instance.trigger('show');
            resolve();
          }
        }
      });
    }

    /**
     * hide Underlay
     * @return {Promise}
     */
  }, {
    key: "hide",
    value: function hide() {
      return new _promise.default(function (resolve, reject) {
        if (Underlay.instance.el.hidden || (0, _hasClass.default)(Underlay.instance.el, 'hide')) {
          resolve();
        } else {
          if (Underlay.instance.animate) {
            Underlay.instance.el.addEventListener('animationend', function onHidden(e) {
              Underlay.instance.el.removeEventListener('animationend', onHidden);
              if (e.animationName === 'dismiss-underlay') {
                (0, _removeClass.default)(document.body, 'spark-no-scroll');
                (0, _removeClass.default)(document.body, 'spark-no-select');
                Underlay.instance.el.hidden = true;
                (0, _removeClass.default)(Underlay.instance.el, 'hide');
                Underlay.instance.trigger('hide');
                resolve();
              } else {
                reject(new Error('Underlay was shown'));
              }
            });
            (0, _addClass.default)(Underlay.instance.el, 'hide');
          } else {
            (0, _removeClass.default)(document.body, 'spark-no-scroll');
            (0, _removeClass.default)(document.body, 'spark-no-select');
            Underlay.instance.el.hidden = true;
            Underlay.instance.trigger('hide');
            resolve();
          }
        }
      });
    }

    /**
     * get current animation config status
     * @return {Boolean}
     */
  }, {
    key: "animate",
    get: function get() {
      return !(0, _hasClass.default)(this.el, 'no-animate');
    }

    /**
     * enable or disable animations
     * @param {Boolean} animation
     */,
    set: function set(animation) {
      // Temporarily fix `animate` to `false`
      animation = false;
      (0, _toggleClass.default)(this.el, 'no-animate', !animation);
    }

    /**
     * getter for current display value
     * @return {Boolean}
     */
  }, {
    key: "display",
    get: function get() {
      return !this.el.hidden;
    }

    /**
     * setter for display
     * @param {Boolean} visible
     */,
    set: function set(visible) {
      if (visible && this.el.hidden) {
        this.show().then(function () {
          Underlay.instance.trigger('change', {
            display: true
          });
        }).catch(function () {});
      } else if (!this.el.hidden) {
        this.hide().then(function () {
          Underlay.instance.trigger('change', {
            display: false
          });
        }).catch(function () {});
      }
    }

    /**
     * Disable Underlay interactions, disable when you want to force user to resolve popups
     * @return {Promise}
     */
  }, {
    key: "disable",
    value: function disable() {
      if (Underlay.instance.el.hasAttribute('data-interactive')) {
        Underlay.instance.el.removeAttribute('data-interactive');
        Underlay.instance.trigger('change', {
          interactive: false
        });
      }
      return _promise.default.resolve();
    }

    /**
     * Enable Underlay, enable when you want underlay to respond to user interactions, and dismiss content
     * @return {Promise}
     */
  }, {
    key: "enable",
    value: function enable() {
      if (!Underlay.instance.el.hasAttribute('data-interactive')) {
        Underlay.instance.el.attributes.setNamedItem(document.createAttribute('data-interactive'));
        Underlay.instance.trigger('change', {
          interactive: true
        });
      }
      return _promise.default.resolve();
    }

    /**
     * getter for current interactive state
     * @return {Boolean}
     */
  }, {
    key: "interactive",
    get: function get() {
      return this.el.hasAttribute('data-interactive');
    }

    /**
     * setter for current disabled state
     * @param {Boolean} active
     */,
    set: function set(active) {
      if (active) {
        this.enable();
      } else {
        this.disable();
      }
    }

    /**
     * Retrieve the current style name
     * @return {String}
     */
  }, {
    key: "style",
    get: function get() {
      return this.el.dataset.style || 'dark';
    }

    /**
     * set or clear the current style name
     * @param {String} name
     */,
    set: function set(name) {
      if (name && name !== this.el.dataset.style) {
        this.el.dataset.style = name;
        Underlay.instance.trigger('change', {
          style: name
        });
      } else {
        this.el.removeAttribute('data-style');
      }
    }

    /**
     * Returns whether or not the underlay is currently visible
     * @return {Boolean}
     */
  }, {
    key: "active",
    get: function get() {
      return window.getComputedStyle(Underlay.instance.el).display === 'block';
    }
  }]);
  return Underlay;
}(_base.default);
(0, _defineProperty2.default)(Underlay, "instance", void 0);
(0, _mixin.default)(Underlay.prototype, _events.default);
var _default = Underlay;
exports.default = _default;
module.exports = exports.default;


},{"../helpers/dom/add-class":59,"../helpers/dom/has-class":61,"../helpers/dom/make-element":62,"../helpers/dom/remove-class":67,"../helpers/dom/toggle-class":68,"../helpers/util/mixin":96,"../mixins/events":103,"./base":3,"@babel/runtime-corejs3/core-js-stable/promise":124,"@babel/runtime-corejs3/core-js-stable/reflect/construct":125,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/defineProperty":146,"@babel/runtime-corejs3/helpers/getPrototypeOf":148,"@babel/runtime-corejs3/helpers/inherits":149,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/possibleConstructorReturn":155}],52:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _splice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/splice"));
var _outerHeight = _interopRequireDefault(require("../dom/outer-height"));
var _addClass = _interopRequireDefault(require("../dom/add-class"));
var _removeClass = _interopRequireDefault(require("../dom/remove-class"));
var _hasClass = _interopRequireDefault(require("../dom/has-class"));
var _toggleClass = _interopRequireDefault(require("../dom/toggle-class"));
/**
 * # Animate Height
 * Animate the height of an element since we can't do this w/ pure CSS. Sigh.
 *
 * @example
 * animateHeight({
 *   el: ...,
 *   toggleEl: ...,
 *   // Optional params
 *   action: 'collapse'|'expand',
 *   heightAnimationClass: 'spark-animate-height',
 *   opacityAnimationClass: 'spark-animate-opacity',
 *   toggleProperty: 'display'|'overflow'|'visibility',
 *   toggleValue: 'block'|'none'|'visible'|'hidden',
 *   animationDuration: 250
 * });
 *
 * @module helpers/animation/height.js
 */

var noop = function noop() {};
var runningAnimations = {
  els: [],
  completeCallbacks: []
};

/**
 * Get the inverse toggle value
 * @param  {String} property
 * @param  {String} originalValue
 * @return {String}
 */
function getInverseToggleValue(el, property, originalValue) {
  // Get the value to toggle to for the given property
  switch (property) {
    case 'overflow':
    case 'visibility':
      return originalValue === 'visible' ? 'hidden' : 'visible';
    default:
      return originalValue === 'block' || originalValue === 'inline-block' ? 'none' : 'block';
  }
}

/**
 * When an animation is complete, clean up and run the callback.
 * @param  {Object} params
 */
function onComplete(params) {
  var _context, _context2;
  // Reset toggle el visibility
  if (params.toggleClassName) {
    (0, _toggleClass.default)(params.el, params.toggleClassName, !params.collapse);
  } else {
    params.toggleEl.style[params.toggleProperty] = '';
  }

  // Remove the height property
  params.el.style.height = '';
  params.toggleEl.style.height = '';
  params.toggleEl.style.marginBottom = '';
  params.toggleEl.style.marginTop = '';

  // Remove the spark-animate-height class so the transitions no longer apply
  (0, _removeClass.default)(params.el, params.heightAnimationClass);
  (0, _removeClass.default)(params.toggleEl, params.heightAnimationClass);

  // Run the callback
  params.onComplete();

  // Remove the element and callback from their respective arrays
  var runningIndex = runningAnimations.els.indexOf(params.el);
  (0, _splice.default)(_context = runningAnimations.els).call(_context, runningIndex, 1);
  (0, _splice.default)(_context2 = runningAnimations.completeCallbacks).call(_context2, runningIndex, 1);
}

/**
 * @param {Object} params
 */
function animateHeight(params) {
  params = params || {};
  var el = params.el;
  if (!el) {
    return;
  }
  var collapse = params.action && params.action === 'collapse';
  var heightAnimationClass = params.heightAnimationClass || 'spark-animate-height';

  // Allow for elements to be passed or selector strings
  var toggleEl = typeof params.toggleEl === 'string' ? el.querySelector(params.toggleEl) : params.toggleEl;

  // No element to be switching with toggling so we can't determine the desired height to animate to.
  if (!toggleEl || (0, _hasClass.default)(el, 'spark-no-animate')) {
    return;
  }
  var toggleClassName = params.toggleClass;

  // The style property to use when toggling visibility
  var toggleProperty = params.toggleProperty || 'display';
  var toggleStyles = window.getComputedStyle(toggleEl);
  var originalToggleValue = toggleStyles[toggleProperty];
  var toggleValue = params.toggleValue || getInverseToggleValue(toggleProperty, originalToggleValue);

  // If we are already animating, stop now.
  var runningIndex = runningAnimations.els.indexOf(el);
  if (runningIndex !== -1) {
    var completeCallback = runningAnimations.completeCallbacks[runningIndex];
    if (completeCallback) {
      clearTimeout(completeCallback);
    }
    onComplete({
      el: el,
      toggleEl: toggleEl,
      onComplete: params.onComplete || noop,
      collapse: collapse,
      toggleProperty: toggleProperty,
      toggleClassName: toggleClassName,
      toggleValue: toggleValue,
      heightAnimationClass: heightAnimationClass
    });
  }

  // Store the current height
  var originalHeight = (0, _outerHeight.default)(el);

  // Toggle the visible property
  if (toggleClassName) {
    (0, _toggleClass.default)(el, toggleClassName, !collapse);
  } else {
    toggleEl.style[toggleProperty] = toggleValue;
  }

  // When measuring the size for a collapse, we have to wait a tic for it to be
  // accurate. Not sure why. Ugh.
  if (collapse) {
    setTimeout(runAnimation, 0);
  } else {
    runAnimation();
  }
  function runAnimation() {
    // Now that the toggle el is taking up space, get the new height which we will be animating to
    var targetElHeight = (0, _outerHeight.default)(el);

    // We need to store the original and target toggle element heights. They differ depending on
    // whether we are going to expand or collapse.
    var targetToggleElHeight;
    var originalToggleElHeight;

    // If we are collapsing, reset the toggle style and set it when we're done. Set the height so
    // that we can animate down to 0 or up to the target height.
    if (collapse) {
      if (toggleClassName) {
        (0, _removeClass.default)(el, toggleClassName);
      } else {
        toggleEl.style[toggleProperty] = originalToggleValue;
      }
      originalToggleElHeight = (0, _outerHeight.default)(toggleEl, toggleStyles);
      targetToggleElHeight = 0;
    } else {
      targetToggleElHeight = (0, _outerHeight.default)(toggleEl, toggleStyles);
      originalToggleElHeight = 0;
    }

    // Set the original height
    el.style.height = originalHeight + 'px';
    toggleEl.style.height = originalToggleElHeight + 'px';
    toggleEl.style.marginBottom = '0px';
    toggleEl.style.marginTop = '0px';

    // Add the spark-animate-height class which will setup the transition-property and duration
    (0, _addClass.default)(el, heightAnimationClass);
    (0, _addClass.default)(toggleEl, heightAnimationClass);
    runningAnimations.els.push(el);

    // We need to wait a tick to toggle the height or else the animation class won't function
    setTimeout(function () {
      // Set the height to the target height
      el.style.height = targetElHeight + 'px';
      toggleEl.style.height = targetToggleElHeight + 'px';

      // Remove inline styles after the animation is complete
      runningAnimations.completeCallbacks.push(setTimeout(function () {
        onComplete({
          el: el,
          toggleEl: toggleEl,
          onComplete: params.onComplete || noop,
          collapse: collapse,
          toggleProperty: toggleProperty,
          toggleClassName: toggleClassName,
          toggleValue: toggleValue,
          heightAnimationClass: heightAnimationClass
        });
      }, params.animationDuration !== undefined ? params.animationDuration : 201));
    }, 0);
  }
}
var _default = animateHeight;
exports.default = _default;
module.exports = exports.default;


},{"../dom/add-class":59,"../dom/has-class":61,"../dom/outer-height":64,"../dom/remove-class":67,"../dom/toggle-class":68,"@babel/runtime-corejs3/core-js-stable/instance/splice":117,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],53:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # Request Animation
 * Request animation frame polyfill.
 * @module helpers/animation/request.js
 */
var request = window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function () {
  var fps = 60;
  var del = 1000 / fps;
  var start = Date.now();
  var prev = start;
  return function requestAnimationFrame(callback) {
    var requestTime = Date.now();
    var timeout = Math.max(0, del - (requestTime - prev));
    var timeToCall = requestTime + timeout;
    prev = timeToCall;
    return window.setTimeout(function onAnimationFrame() {
      callback(timeToCall - start);
    }, timeout);
  };
}();
var _default = request;
exports.default = _default;
module.exports = exports.default;


},{}],54:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _offset = _interopRequireDefault(require("../dom/offset"));
var _tween = _interopRequireDefault(require("./tween"));
/**
 * # Scroll To
 * Scroll the window to a specific element or position.
 * @param {Object} params
 *
 * @module helpers/animation/scroll-to.js
 */

function scrollTo(params) {
  params = params || {};
  var offset;
  var x;
  var y;
  var target = params.target || window;
  var startX = target !== window ? target.scrollLeft : target.pageXOffset;
  var startY = target !== window ? target.scrollTop : target.pageYOffset;
  if (params instanceof HTMLElement) {
    offset = (0, _offset.default)(params);
    x = offset.left;
    y = offset.top;
    params = arguments[1] || {};
  } else {
    x = params.x || 0;
    y = params.y || 0;
  }
  (0, _tween.default)({
    target: target,
    prop: 'scrollTo',
    start: [startX, startY],
    end: [x, y],
    duration: params.duration,
    callback: params.callback
  });
}
var _default = scrollTo;
exports.default = _default;
module.exports = exports.default;


},{"../dom/offset":63,"./tween":55,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],55:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));
var _request = _interopRequireDefault(require("./request"));
/**
 * # Tween
 * Tween between two values.
 * @module helpers/animation/tween.js
 */

var noop = function noop() {};

/**
 * Tween from one value to another.
 * @param {Object} params
 * @return {Long}
 */
function tween(params) {
  params = params || {};
  var begin;
  var obj = params.target;
  if (!obj) {
    throw new Error('Cannot tween without a target!');
  }
  var prop = typeof params.prop === 'string' ? [params.prop] : params.prop;
  var start = typeof params.start === 'number' ? [params.start] : params.start;
  var end = typeof params.end === 'number' ? [params.end] : params.end;
  var duration = params.duration || 250;
  var callback = params.callback || noop;

  // Ensure we have the same number of start and end properties.
  if (start.length !== end.length) {
    throw new Error('Cannot tween two different sets of parameters!');
  }
  var f = function f(ts) {
    // Keep track of when we start
    if (!begin) begin = ts;

    // Progress
    var prog = ts - begin;

    // Percentage complete
    var per = Math.min(prog / duration, 1);

    // Adjust the values for the percentage complete.
    var args = [];
    var i = 0;
    var len = start.length;
    for (; i < len; i++) {
      args[i] = start[i] + (end[i] - start[i]) * per;
    }

    // Apply the values for each property.
    i = 0;
    len = prop.length;
    var arg;
    for (; i < len; i++) {
      // If this is the last property but we have more arguments, set them all.
      arg = i + 1 === len && args.length - 1 > i ? (0, _slice.default)(args).call(args, i) : args[i];
      if (typeof obj[prop[i]] === 'function') {
        obj[prop[i]].apply(obj, arg);
      } else {
        obj[prop[i]] = arg;
      }
    }

    // Keep going if we have more to do.
    if (prog < duration) (0, _request.default)(f);else callback();
  };
  return (0, _request.default)(f);
}
var _default = tween;
exports.default = _default;
module.exports = exports.default;


},{"./request":53,"@babel/runtime-corejs3/core-js-stable/instance/slice":115,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],56:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/typeof"));
var _each = _interopRequireDefault(require("../util/each"));
/**
 * # Transform
 * Apply a cross-browser transform style.
 *
 * @example
 * transform('translateX', '-100px');
 *
 * @param {String} type
 * @param {String} val
 *
 * @module helpers/css/transform.js
 */

var prefixes = ['-webkit-', '-moz-', '-o-', '-ms-', ''];
function transform(type, val) {
  var str = '';
  (0, _each.default)(prefixes, function (p) {
    if ((0, _typeof2.default)(val) === 'object') {
      str += p + 'transform: ';
      for (var j in val) {
        str += j + '(' + val[j] + '); ';
      }
    } else {
      str += p + 'transform: ' + type + '(' + val + '); ';
    }
  });
  return str;
}
var _default = transform;
exports.default = _default;
module.exports = exports.default;


},{"../util/each":94,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/typeof":162}],57:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));
var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));
/**
 * # Date helper
 * General helpers for working with dates.
 *
 * @module helpers/date/date.js
 */

var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
var monthNamesShort = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June', 'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'];
var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
var dayNamesShort = ['Sun', 'Mon', 'Tues', 'Wed', 'Thur', 'Fri', 'Sat'];
var adjustedDayNames = [];
var adjustedDayNamesShort = [];
var weekStartsOn = 0;
var dateHelper = {
  /**
   * Transform a date into an object of date values.
   * @param {Date} date
   * @return {Object}
   */
  create: function create(date) {
    date = date instanceof Date ? date : new Date(date.year, date.month - 1, date.day);
    var inst = Object.create(dateHelper);
    inst._date = date;
    inst._cache = {};
    return inst;
  },
  /**
   * Get a year.
   * @return {Number}
   */
  get year() {
    this._instanceCheck('year');
    return this._date.getFullYear();
  },
  /**
   * Set a year.
   * @param {Number} y
   */
  set year(y) {
    this._instanceCheck('year');
    this._clearCache();
    return this._date.setFullYear(y);
  },
  /**
   * Get a month.
   * @return {Number} 1-12
   */
  get month() {
    this._instanceCheck('month');
    return this._date.getMonth() + 1;
  },
  /**
   * Set a month.
   * @param {Number} m 1-12
   */
  set month(m) {
    this._instanceCheck('month');
    this._clearCache();
    return this._date.setMonth(m - 1);
  },
  /**
   * Get a day.
   * @return {Number} 1-31
   */
  get day() {
    this._instanceCheck('day');
    return this._date.getDate();
  },
  /**
   * Set a day.
   * @param {Number} d 1-31
   */
  set day(d) {
    this._instanceCheck('day');
    this._clearCache();
    return this._date.setDate(d);
  },
  /**
   * Sets the day, month and year values at once.
   * @param {Object} params
   */
  set: function set(params) {
    params = params || {};
    this.year = params.year || this.year;
    this.month = params.month || this.month;
    this.day = params.day || this.day;
  },
  /**
   * Get the full name of the month.
   * @param {Number} num
   * @return {String}
   */
  getMonthName: function getMonthName(num) {
    return monthNames[num - 1];
  },
  /**
   * Get the month name.
   * @return {String}
   */
  get monthName() {
    this._instanceCheck('monthName');
    return dateHelper.getMonthName(this.month);
  },
  /**
   * Get the list of month names.
   * @return {Array}
   */
  getMonthNames: function getMonthNames() {
    return monthNames;
  },
  /**
   * Get the short name of the month.
   * @param {Number} num
   * @return {String}
   */
  getMonthNameShort: function getMonthNameShort(num) {
    return monthNamesShort[num - 1];
  },
  /**
   * Get the month name.
   * @return {String}
   */
  get monthNameShort() {
    this._instanceCheck('monthName');
    return dateHelper.getMonthNameShort(this.month);
  },
  /**
   * Get the list of short month names.
   * @return {Array}
   */
  getMonthNamesShort: function getMonthNamesShort() {
    return monthNamesShort;
  },
  /**
   * Set the month names.
   * @param {Array} names
   */
  setMonthNames: function setMonthNames(names) {
    if (names.length === 12) monthNames = names;
  },
  /**
   * Set the short month names.
   * @param {Array} names
   */
  setMonthNamesShort: function setMonthNamesShort(names) {
    if (names.length === 12) monthNamesShort = names;
  },
  /**
   * Get the day of the week for a given day.
   * @param {Object} date
   * @return {Number} 1-7
   */
  getDayOfWeek: function getDayOfWeek(date) {
    var day = (date instanceof Date ? date : new Date(date.year, date.month - 1, date.day)).getDay() - weekStartsOn;
    return (day < 0 ? 7 - Math.abs(day) : day) + 1;
  },
  /**
   * Get the day of the week.
   * @return {Number}
   */
  get dayOfWeek() {
    return dateHelper.getDayOfWeek(this._date);
  },
  /**
   * Get the full name of a day of the week.
   * @param {Number} num
   * @return {String}
   */
  getDayName: function getDayName(num) {
    return dayNames[num - 1 + weekStartsOn] || dayNames[dayNames.length - num - 1 + weekStartsOn];
  },
  /**
   * Get the day name.
   * @return {String}
   */
  get dayName() {
    this._instanceCheck('dayName');
    return dateHelper.getDayName(this.dayOfWeek);
  },
  /**
   * Get the full name of the days of the week.
   * @return {Array}
   */
  getDayNames: function getDayNames() {
    return adjustedDayNames.length ? adjustedDayNames : dayNames;
  },
  /**
   * Get the short name of the day.
   * @param {Number} num
   * @return {String}
   */
  getDayNameShort: function getDayNameShort(num) {
    return dayNamesShort[num - 1 + weekStartsOn] || dayNames[dayNames.length - num - 1 + weekStartsOn];
  },
  /**
   * Get the short day name.
   * @return {String}
   */
  get dayNameShort() {
    this._instanceCheck('dayNameShort');
    return dateHelper.getDayNameShort(this.dayOfWeek);
  },
  /**
   * Get the full name of the days of the week.
   * @return {Array}
   */
  getDayNamesShort: function getDayNamesShort() {
    return adjustedDayNamesShort.length ? adjustedDayNamesShort : dayNamesShort;
  },
  /**
   * Set the day names.
   * @param {Array} names
   */
  setDayNames: function setDayNames(names) {
    if (names.length === 7) dayNames = names;
  },
  /**
   * Set the short day names.
   * @param {Array} names
   */
  setDayNamesShort: function setDayNamesShort(names) {
    if (names.length === 7) dayNamesShort = names;
  },
  /**
   * Get the index of the first day of the week.
   * @return {Number}
   */
  getWeekStartsOn: function getWeekStartsOn() {
    return weekStartsOn;
  },
  /**
   * Set the index of the first day of the week.
   * @param {Number} index
   * @return {String}
   */
  setWeekStartsOn: function setWeekStartsOn(number) {
    weekStartsOn = number;
    if (number) {
      adjustedDayNames = (0, _slice.default)(dayNames).call(dayNames, weekStartsOn);
      adjustedDayNames = (0, _concat.default)(adjustedDayNames).call(adjustedDayNames, (0, _slice.default)(dayNames).call(dayNames, 0, weekStartsOn));
      adjustedDayNamesShort = (0, _slice.default)(dayNamesShort).call(dayNamesShort, weekStartsOn);
      adjustedDayNamesShort = (0, _concat.default)(adjustedDayNamesShort).call(adjustedDayNamesShort, (0, _slice.default)(dayNamesShort).call(dayNamesShort, 0, weekStartsOn));
    } else {
      adjustedDayNames = [];
      adjustedDayNamesShort = [];
    }
  },
  /**
   * Get the current date.
   * @return {Object}
   */
  now: function now() {
    return dateHelper.create(new Date());
  },
  /**
   * Get the next year after the given date.
   * This obviously isn't very complicated, but it exists
   * for parity with how we get the week, day and month.
   * @param {Object} date
   * @return {Object}
   */
  getNextYear: function getNextYear(date) {
    return dateHelper.create(new Date(date.year + 1, date.month - 1, date.day));
  },
  /**
   * Get the year following this.
   * @return {Object}
   */
  get nextYear() {
    this._instanceCheck('nextYear');
    return this._cache.nextYear || (this._cache.nextYear = dateHelper.getNextYear(this));
  },
  /**
   * Get the first day of the week for a given date.
   * @param {Object} date
   * @return {Object}
   */
  getWeekStart: function getWeekStart(date) {
    var inst = dateHelper.create(new Date(date.year, date.month - 1, date.day - dateHelper.getDayOfWeek(date) + 1));
    inst.weekStartsOn = weekStartsOn;
    return inst;
  },
  /**
   * Get the start of the week for this date.
   * @return {Object}
   */
  get weekStart() {
    this._instanceCheck('weekStart');
    return this._cache.weekStart && this._cache.weekStart.weekStartsOn === weekStartsOn ? this._cache.weekStart : this._cache.weekStart = dateHelper.getWeekStart(this);
  },
  /**
   * Get the first day of the month for a given date.
   * @param {Object} date
   * @return {Object}
   */
  getMonthStart: function getMonthStart(date) {
    var inst = dateHelper.create(new Date(date.year, date.month - 1, 1));
    return inst;
  },
  /**
   * Get the start of the month for this date.
   * @return {Object}
   */
  get monthStart() {
    this._instanceCheck('monthStart');
    return this._cache.monthStart || (this._cache.monthStart = dateHelper.getMonthStart(this));
  },
  /**
   * Get the next week after the given date.
   * @param {Object} date
   * @return {Object}
   */
  getNextWeek: function getNextWeek(date) {
    var start = dateHelper.getWeekStart(date);
    return dateHelper.create(new Date(start.year, start.month - 1, start.day + 7));
  },
  /**
   * Get the week following this.
   * @return {Object}
   */
  get nextWeek() {
    this._instanceCheck('nextWeek');
    return this._cache.nextWeek || (this._cache.nextWeek = dateHelper.getNextWeek(this));
  },
  /**
   * Get the next day after the given date.
   * @param {Object} date
   * @return {Object}
   */
  getNextDay: function getNextDay(date) {
    return dateHelper.create(new Date(date.year, date.month - 1, date.day + 1));
  },
  /**
   * Get the day following this.
   * @return {Object}
   */
  get nextDay() {
    this._instanceCheck('nextDay');
    return this._cache.nextDay || (this._cache.nextDay = dateHelper.getNextDay(this));
  },
  /**
   * Get the next month after the given date.
   * @param {Object} date
   * @return {Object}
   */
  getNextMonth: function getNextMonth(date) {
    // Date() has a *bug/feature* if last day of month is 31 when calculating the next month.
    // Need to account for that so that it doesn't round up the date/month.

    if (date.day === 31 && date.month !== 1 && date.month !== 7 && date.month !== 12) {
      // Adjust for months ending in 31 followed by months ending in 30
      return dateHelper.create(new Date(date.year, date.month, date.day - 1));
    } else if (date.day > 28 && date.month === 1) {
      // fix for last day of February
      return dateHelper.create(new Date(date.year, date.month + 1, 0));
    } else {
      return dateHelper.create(new Date(date.year, date.month, date.day));
    }
  },
  /**
   * Get the month following this.
   * @return {Object}
   */
  get nextMonth() {
    this._instanceCheck('nextMonth');
    return this._cache.nextMonth || (this._cache.nextMonth = dateHelper.getNextMonth(this));
  },
  /**
   * Get the previous year after the given date.
   * This obviously isn't very complicated, but it exists
   * for parity with how we get the week, day and month.
   * @param {Object} date
   * @return {Object}
   */
  getPreviousYear: function getPreviousYear(date) {
    return dateHelper.create(new Date(date.year - 1, date.month - 1, date.day));
  },
  /**
   * Get the year preceding this.
   * @return {Object}
   */
  get previousYear() {
    this._instanceCheck('previousYear');
    return this._cache.previousYear || (this._cache.previousYear = dateHelper.getPreviousYear(this));
  },
  /**
   * Get the previous week after the given date.
   * @param {Object} date
   * @return {Object}
   */
  getPreviousWeek: function getPreviousWeek(date) {
    var start = dateHelper.getWeekStart(date);
    var inst = dateHelper.create(new Date(start.year, start.month - 1, start.day - 7));
    inst.weekStartsOn = weekStartsOn;
    return inst;
  },
  /**
   * Get the week preceding this.
   * @return {Object}
   */
  get previousWeek() {
    this._instanceCheck('previousWeek');
    return this._cache.previousWeek || (this._cache.previousWeek = dateHelper.getPreviousWeek(this));
  },
  /**
   * Get the previous day after the given date.
   * @param {Object} date
   * @return {Object}
   */
  getPreviousDay: function getPreviousDay(date) {
    return dateHelper.create(new Date(date.year, date.month - 1, date.day - 1));
  },
  /**
   * Get the day preceding this.
   * @return {Object}
   */
  get previousDay() {
    this._instanceCheck('previousDay');
    return this._cache.previousDay || (this._cache.previousDay = dateHelper.getPreviousDay(this));
  },
  /**
   * Get the previous month after the given date.
   * @param {Object} date
   * @return {Object}
   */
  getPreviousMonth: function getPreviousMonth(date) {
    // Date() has a *bug/feature* if last day of month is 31 when calculating the previous month.
    // Need to account for that so that it doesn't round up the date/month.

    if (date.day === 31 && date.month !== 1 && date.month !== 3 && date.month !== 8) {
      // Adjust for months ending in 31 that follow months ending in 30
      return dateHelper.create(new Date(date.year, date.month - 2, date.day - 1));
    } else if (date.day > 28 && date.month === 3) {
      // Adjust for last day of February
      return dateHelper.create(new Date(date.year, date.month - 1, 0));
    } else {
      return dateHelper.create(new Date(date.year, date.month - 2, date.day));
    }
  },
  /**
   * Get the month preceding this.
   * @return {Object}
   */
  get previousMonth() {
    this._instanceCheck('previousMonth');
    return this._cache.previousMonth || (this._cache.previousMonth = dateHelper.getPreviousMonth(this));
  },
  /**
   * Get the last day of the month.
   * @param {Object} date
   * @return {Object}
   */
  getMonthEnd: function getMonthEnd(date) {
    return dateHelper.create(new Date(date.year, date.month, 0));
  },
  /**
   * Get the last day of the month.
   * @return {Object}
   */
  get monthEnd() {
    this._instanceCheck('monthEnd');
    return this._cache.monthEnd || (this._cache.monthEnd = dateHelper.getMonthEnd(this));
  },
  /**
   * Does a given day equal another? Or is it present in a list of others?
   * @param {Object} date
   * @param {Object|Array} compare
   * @param {Boolean} full Return a successful match only if all matches are found.
   * @return {Boolean}
   */
  equal: function equal(date, compare, full) {
    return this.equalDay(date, compare, full);
  },
  /**
   * Does a given day equal another? Or is it present in a list of others?
   * @param {Object} date
   * @param {Object|Array} compare
   * @param {Boolean} full Return a successful match only if all matches are found.
   * @return {Boolean}
   */
  equalDay: function equalDay(date, compare, full) {
    var args = this._checkComparisonArgs(date, compare, full);
    date = args[0];
    compare = args[1];
    full = args[2];
    var i = 0;
    var len = compare.length;
    var matches = 0;
    for (; i < len; i++) {
      if (compare[i] && date.year === compare[i].year && date.month === compare[i].month && date.day === compare[i].day) matches++;
    }
    return full ? matches === len : !!matches;
  },
  /**
   * Is a week equal to another?
   * @param {Object} date
   * @param {Object|Array} compare
   * @param {Boolean} full Return a successful match only if all matches are found.
   * @return {Boolean}
   */
  equalWeek: function equalWeek(date, compare, full) {
    var args = this._checkComparisonArgs(date, compare, full);
    date = args[0];
    compare = args[1];
    full = args[2];
    var i = 0;
    var len = compare.length;
    var matches = 0;
    for (; i < len; i++) {
      if (!compare[i] || !date.weekStart.equalDay(compare[i].weekStart)) continue;else matches++;
    }
    return full ? matches === len : !!matches;
  },
  /**
   * Is a month equal to another?
   * @param {Object} date
   * @param {Object|Array} compare
   * @param {Boolean} full Return a successful match only if all matches are found.
   * @return {Boolean}
   */
  equalMonth: function equalMonth(date, compare, full) {
    var args = this._checkComparisonArgs(date, compare, full);
    date = args[0];
    compare = args[1];
    full = args[2];
    var i = 0;
    var len = compare.length;
    var matches = 0;
    for (; i < len; i++) {
      if (!compare[i] || date.year !== compare[i].year || date.year === compare[i].year && date.month !== compare[i].month) continue;else matches++;
    }
    return full ? matches === len : !!matches;
  },
  /**
   * Is a year equal to another?
   * @param {Object} date
   * @param {Object|Array} compare
   * @param {Boolean} full Return a successful match only if all matches are found.
   * @return {Boolean}
   */
  equalYear: function equalYear(date, compare, full) {
    var args = this._checkComparisonArgs(date, compare, full);
    date = args[0];
    compare = args[1];
    full = args[2];
    var i = 0;
    var len = compare.length;
    var matches = 0;
    for (; i < len; i++) {
      if (!compare[i] || date.year !== compare[i].year) continue;else matches++;
    }
    return full ? matches === len : !!matches;
  },
  /**
   * Is a date before another?
   * @param {Object} date
   * @param {Object|Array} compare
   * @param {Boolean} full Return a successful match only if all matches are found.
   * @return {Boolean}
   */
  before: function before(date, compare, full) {
    return this.beforeDay(date, compare, full);
  },
  /**
   * Is a given date before another?
   * @param {Object} date
   * @param {Object|Array} compare
   * @param {Boolean} full Return a successful match only if all matches are found.
   * @return {Boolean}
   */
  beforeDay: function beforeDay(date, compare, full) {
    var args = this._checkComparisonArgs(date, compare, full);
    date = args[0];
    compare = args[1];
    full = args[2];
    var i = 0;
    var len = compare.length;
    var matches = 0;
    for (; i < len; i++) {
      if (!compare[i] || date._date >= compare[i]._date) continue;else matches++;
    }
    return full ? matches === len : !!matches;
  },
  /**
   * Is a week before another?
   * @param {Object} date
   * @param {Object|Array} compare
   * @param {Boolean} full Return a successful match only if all matches are found.
   * @return {Boolean}
   */
  beforeWeek: function beforeWeek(date, compare, full) {
    var args = this._checkComparisonArgs(date, compare, full);
    date = args[0];
    compare = args[1];
    full = args[2];
    var i = 0;
    var len = compare.length;
    var matches = 0;
    for (; i < len; i++) {
      if (!compare[i] || !date.weekStart.beforeDay(compare[i].weekStart)) continue;else matches++;
    }
    return full ? matches === len : !!matches;
  },
  /**
   * Is a month before another?
   * @param {Object} date
   * @param {Object|Array} compare
   * @param {Boolean} full Return a successful match only if all matches are found.
   * @return {Boolean}
   */
  beforeMonth: function beforeMonth(date, compare, full) {
    var args = this._checkComparisonArgs(date, compare, full);
    date = args[0];
    compare = args[1];
    full = args[2];
    var i = 0;
    var len = compare.length;
    var matches = 0;
    for (; i < len; i++) {
      if (!compare[i] || date.year > compare[i].year || date.year === compare[i].year && date.month >= compare[i].month) continue;else matches++;
    }
    return full ? matches === len : !!matches;
  },
  /**
   * Is a year before another?
   * @param {Object} date
   * @param {Object|Array} compare
   * @param {Boolean} full Return a successful match only if all matches are found.
   * @return {Boolean}
   */
  beforeYear: function beforeYear(date, compare, full) {
    var args = this._checkComparisonArgs(date, compare, full);
    date = args[0];
    compare = args[1];
    full = args[2];
    var i = 0;
    var len = compare.length;
    var matches = 0;
    for (; i < len; i++) {
      if (!compare[i] || date.year >= compare[i].year) continue;else matches++;
    }
    return full ? matches === len : !!matches;
  },
  /**
   * Is a date after another?
   * @param {Object} date
   * @param {Object|Array} compare
   * @param {Boolean} full Return a successful match only if all matches are found.
   * @return {Boolean}
   */
  after: function after(date, compare, full) {
    return this.afterDay(date, compare, full);
  },
  /**
   * Is a given date after another?
   * @param {Object} date
   * @param {Object|Array} compare
   * @param {Boolean} full Return a successful match only if all matches are found.
   * @return {Boolean}
   */
  afterDay: function afterDay(date, compare, full) {
    var args = this._checkComparisonArgs(date, compare, full);
    date = args[0];
    compare = args[1];
    full = args[2];
    var i = 0;
    var len = compare.length;
    var matches = 0;
    for (; i < len; i++) {
      if (!compare[i] || date._date <= compare[i]._date) continue;else matches++;
    }
    return full ? matches === len : !!matches;
  },
  /**
   * Is a week after another?
   * @param {Object} date
   * @param {Object|Array} compare
   * @param {Boolean} full Return a successful match only if all matches are found.
   * @return {Boolean}
   */
  afterWeek: function afterWeek(date, compare, full) {
    var args = this._checkComparisonArgs(date, compare, full);
    date = args[0];
    compare = args[1];
    full = args[2];
    var i = 0;
    var len = compare.length;
    var matches = 0;
    for (; i < len; i++) {
      if (!compare[i] || !date.weekStart.afterDay(compare[i].weekStart)) continue;else matches++;
    }
    return full ? matches === len : !!matches;
  },
  /**
   * Is a month after another?
   * @param {Object} date
   * @param {Object|Array} compare
   * @param {Boolean} full Return a successful match only if all matches are found.
   * @return {Boolean}
   */
  afterMonth: function afterMonth(date, compare, full) {
    var args = this._checkComparisonArgs(date, compare, full);
    date = args[0];
    compare = args[1];
    full = args[2];
    var i = 0;
    var len = compare.length;
    var matches = 0;
    for (; i < len; i++) {
      if (!compare[i] || date.year < compare[i].year || date.year === compare[i].year && date.month <= compare[i].month) continue;else matches++;
    }
    return full ? matches === len : !!matches;
  },
  /**
   * Is a year after another?
   * @param {Object} date
   * @param {Object|Array} compare
   * @param {Boolean} full Return a successful match only if all matches are found.
   * @return {Boolean}
   */
  afterYear: function afterYear(date, compare, full) {
    var args = this._checkComparisonArgs(date, compare, full);
    date = args[0];
    compare = args[1];
    full = args[2];
    var i = 0;
    var len = compare.length;
    var matches = 0;
    for (; i < len; i++) {
      if (!compare[i] || date.year <= compare[i].year) continue;else matches++;
    }
    return full ? matches === len : !!matches;
  },
  /**
   * Get the earliest date in an array.
   * @return {Object}
   */
  earliest: function earliest(arr) {
    var i = 0;
    var len = arr.length;
    var e;
    for (; i < len; i++) {
      if (!e || arr[i].before(e)) e = arr[i];
    }
    return e;
  },
  /**
   * Get the latest date in an array.
   * @return {Object}
   */
  latest: function latest(arr) {
    var i = 0;
    var len = arr.length;
    var l;
    for (; i < len; i++) {
      if (!l || arr[i].after(l)) l = arr[i];
    }
    return l;
  },
  /**
   * Clone a date instance.
   * @param {Object} date
   * @return {Object}
   */
  clone: function clone(date) {
    // If we weren't passed a date, use this instance.
    if (!date && this._date && this._date instanceof Date && dateHelper.isPrototypeOf(this)) {
      date = this;
    }

    // No date, can't clone.
    if (!date) {
      throw new Error('Must pass a date to clone or call on an instance.');
    }
    return dateHelper.create(new Date(date._date.valueOf()));
  },
  /**
   * If a comparison function is called on an instance, properly
   * assign the vars.
   * @param {Object} date
   * @param {Object|Array} compare
   * @param {Boolean} full
   */
  _checkComparisonArgs: function _checkComparisonArgs(date, compare, full) {
    if (compare === undefined || typeof compare === 'boolean') {
      if (!dateHelper.isPrototypeOf(this)) {
        throw new Error('Cannot compare only one date!');
      }
      full = compare;
      compare = date;
      date = this;
    }
    compare = compare instanceof Array ? compare : [compare];
    return [date, compare, full];
  },
  /**
   * Check to see if we have an instance of the date object.
   * @param  {String} prop
   */
  _instanceCheck: function _instanceCheck(prop) {
    if (!this._date || !(this._date instanceof Date) || !dateHelper.isPrototypeOf(this)) throw new Error('Cannot access the property "' + prop + '" of the date helper with creating an instance!');
  },
  /**
   * Clear the cache.
   */
  _clearCache: function _clearCache() {
    this._instanceCheck('clearCache');
    this._cache = {};
  }
};
var _default = dateHelper;
exports.default = _default;
module.exports = exports.default;


},{"@babel/runtime-corejs3/core-js-stable/instance/concat":108,"@babel/runtime-corejs3/core-js-stable/instance/slice":115,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],58:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _pad = _interopRequireDefault(require("../util/pad"));
var _date = _interopRequireDefault(require("./date"));
/**
 * # Parse Date Format
 * Given a date format string, break it down into pieces.
 *
 * @example
 * parseDateFormat('MM-DD-YYYY');
 *
 * @module helpers/date/parse-format.js
 */

/**
 * Map characters to their special meanings.
 * @type {Object}
 */
var map = {
  d: 'day',
  m: 'month',
  y: 'year',
  '-': 'divider',
  '/': 'divider',
  ' ': 'space'
};

/**
 * Given a format and a string, get the day, month and year values from that string.
 * @param {Object} format
 * @return {Function}
 */
function getValues(format) {
  return function (value) {
    var i = 0;
    var index = 0;
    var len = format.length;
    var values = {};

    // Loop through all format pieces
    for (; i < len; i++) {
      // Only worry about date values
      if (['day', 'month', 'year'].indexOf(format[i].name) !== -1) {
        // If the passed value doesn't contain a format piece, it's invalid.
        if (value.length < index + format[i].length) return;
        values[format[i].name] = parseInt(value.substr(index, format[i].length), 10);
      }
      index += format[i].length;
    }
    return _date.default.create(values);
  };
}

/**
 * Create a formatted date string given an object of values.
 * @param {Object} format
 * @return {Function}
 */
function getString(format) {
  /**
   * @param {Object} vals
   * @return {String}
   */
  return function (vals) {
    var i = 0;
    var len = format.length;
    var str = '';
    for (; i < len; i++) {
      // Numbers
      if (vals[format[i].name]) {
        str += (0, _pad.default)(vals[format[i].name], format[i].length);

        // Dividers
      } else {
        str += format[i].value;
      }
    }
    return str;
  };
}

/**
 * @param {String} format
 * @return {Object}
 */
function parseDateFormat(format) {
  var f = format.toLowerCase();
  var i = 0;
  var len = f.length;
  var obj = {
    parts: []
  };
  for (; i < len; i++) {
    // If there is a matching character mapping and the last part was of the same name, increment its length
    // and add to its content.
    if (map[f[i]] && obj.parts.length && obj.parts[obj.parts.length - 1].name === map[f[i]]) {
      obj.parts[obj.parts.length - 1].length++;
      obj.parts[obj.parts.length - 1].value += format[i];
      continue;
    }
    obj.parts.push({
      name: map[f[i]] ? map[f[i]] : '',
      value: format[i],
      length: 1
    });
  }

  // Add a way to convert the parsed date into a regex-ish string that works with the Typeahead implementation.
  obj.getValues = getValues(obj.parts);
  obj.getString = getString(obj.parts);
  return obj;
}
var _default = parseDateFormat;
exports.default = _default;
module.exports = exports.default;


},{"../util/pad":98,"./date":57,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],59:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));
var _trim = _interopRequireDefault(require("../util/trim"));
var _hasClass = _interopRequireDefault(require("./has-class"));
/**
 * # Add Class
 * Add a class on an element.
 *
 * @param {Element|Array} el An element or array of elements to update.
 * @param {String} name
 * @return {Element}
 *
 * @module helpers/dom/add-class.js
 */

var ws = /\s+/;
var cleanup = /\s{2,}/g;
function addClass(el, name) {
  if (!el) {
    return;
  }
  if (arguments.length === 2 && typeof name === 'string') {
    name = (0, _trim.default)(name).split(ws);
  } else {
    name = name instanceof Array ? name : (0, _slice.default)(Array.prototype).call(arguments, 1);
  }

  // optimize for best, most common case
  if (name.length === 1 && el.classList) {
    if (name[0]) {
      el.classList.add(name[0]);
    }
    return el;
  }
  var toAdd = [];
  var i = 0;
  var l = name.length;
  var item;
  var clsName = typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '';

  // see if we have anything to add
  for (; i < l; i++) {
    item = name[i];
    if (item && !(0, _hasClass.default)(clsName, item)) {
      toAdd.push(item);
    }
  }
  if (toAdd.length) {
    if (typeof el.className === 'string') {
      el.className = (0, _trim.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' '));
    } else if (el.setAttribute) {
      el.setAttribute('class', (0, _trim.default)((clsName + ' ' + toAdd.join(' ')).replace(cleanup, ' ')));
    }
  }
  return el;
}
var _default = addClass;
exports.default = _default;
module.exports = exports.default;


},{"../util/trim":102,"./has-class":61,"@babel/runtime-corejs3/core-js-stable/instance/slice":115,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],60:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.get = get;
/**
 * # Breakpoint Helpers
 * Find the active breakpoint.
 *
 * @param {Number} width
 *
 * @module helpers/dom/breakpoint.js
 */

/**
 * Breakpoints being used in the CSS.
 * @type {Object}
 */
var defaultBreakpoints = {
  xs: {
    min: 0,
    max: 543
  },
  sm: {
    min: 544,
    max: 795
  },
  md: {
    min: 796,
    max: 1047
  },
  lg: {
    min: 1048,
    max: 1799
  },
  xl: {
    min: 1800,
    max: Infinity
  }
};
function get(width, breakpoints) {
  breakpoints = breakpoints || defaultBreakpoints;
  var i;
  for (i in breakpoints) {
    if (width >= breakpoints[i].min && width <= breakpoints[i].max) {
      return i;
    }
  }
}


},{}],61:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/typeof"));
/**
 * # Has Class
 * See if an element has a class.
 *
 * @param {Element|String} el
 * @param {String} name
 * @return {Boolean}
 *
 * @module helpers/dom/has-class.js
 */
function hasClass(el, name) {
  var cName = ((0, _typeof2.default)(el) === 'object' ? el.className || el.getAttribute && el.getAttribute('class') || '' : el || '').replace(/[\t\r\n\f]/g, ' ');
  return (' ' + cName + ' ').indexOf(' ' + name + ' ') !== -1;
}
var _default = hasClass;
exports.default = _default;
module.exports = exports.default;


},{"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/typeof":162}],62:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = _default;
/**
 * # Make Element
 * Make en element using a string of HTML.
 *
 * @example
 * makeElement('<div></div>');
 *
 * @module helpers/make-element.js
 *
 * @param {String} html
 * @return {Element}
 */
function _default(html) {
  if (!html) {
    throw new Error('Cannot create element with no HTML!');
  }
  var el = document.createElement('div');
  el.innerHTML = html;
  var el2 = el.children[0];
  el2.parentNode.removeChild(el2);
  return el2;
}
module.exports = exports.default;


},{}],63:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # Offset Position
 * Get the offset position of the element.
 *
 * @param {Element} el
 * @param {Boolean} viewPortOffset The offset relative to the viewport, not page.
 * @return {Object}
 *
 * @module helpers/dom/offset.js
 */
function offset(el, viewPortOffset) {
  var rect = {
    top: 0,
    left: 0
  };

  // Native implementation
  if (el.getBoundingClientRect) {
    var bounding = el.getBoundingClientRect();
    rect.left = bounding.left;
    rect.top = bounding.top;
    if (!viewPortOffset) {
      rect.left += typeof window.scrollX !== 'undefined' ? window.scrollX : window.pageXOffset;
      rect.top += typeof window.scrollY !== 'undefined' ? window.scrollY : window.pageYOffset;
    }
  } else {
    var x = 0,
      y = 0;
    do {
      x += el.offsetLeft - (!viewPortOffset ? el.scrollLeft : 0);
      y += el.offsetTop - (!viewPortOffset ? el.scrollTop : 0);
    } while (el = el.offsetParent);
    rect.left = x;
    rect.top = y;
  }
  return rect;
}
var _default = offset;
exports.default = _default;
module.exports = exports.default;


},{}],64:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _each = _interopRequireDefault(require("../util/each"));
/**
 * # Outer Height
 * Get the outer height of an element (including margin and border)
 *
 * @param {Element} el
 * @param {Object} styles Optional Already have computed styles? Pass them in.
 *
 * @example
 * outerHeight(el, computedStyles);
 *
 * @module helpers/outer-height.js
 */

var props = ['marginTop', 'marginBottom', 'borderTop', 'borderBottom'];
function outerHeight(el, styles) {
  styles = styles || window.getComputedStyle(el);
  var height = el.clientHeight;
  (0, _each.default)(props, function (prop) {
    height += parseInt(styles[prop] || 0, 10);
  });
  return height;
}
var _default = outerHeight;
exports.default = _default;
module.exports = exports.default;


},{"../util/each":94,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],65:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _each = _interopRequireDefault(require("../util/each"));
/**
 * # Outer Width
 * Get the outer width of an element (including margin and border)
 *
 * @param {Element} el
 * @param {Object} styles Optional Already have computed styles? Pass them in.
 *
 * @example
 * outerWidth(el, computedStyles);
 *
 * @module helpers/outer-width.js
 */

var props = ['marginLeft', 'marginRight', 'borderLeft', 'borderRight'];
function outerWidth(el, styles) {
  styles = styles || window.getComputedStyle(el);
  var width = el.clientWidth;
  (0, _each.default)(props, function (prop) {
    width += parseInt(styles[prop] || 0, 10);
  });
  return width;
}
var _default = outerWidth;
exports.default = _default;
module.exports = exports.default;


},{"../util/each":94,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],66:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.boolean = boolean;
exports.number = number;
exports.string = string;
/**
 * # Parse DOM attributes
 * Given an element and an attribute name, parse that attribute
 * if it exists or return a default.
 *
 * @module helpers/dom/parse-attribute.js
 */

/**
 * Get the boolean value of an attribute on an element,
 * falling back to the default value.
 * @param  {Element} el
 * @param  {String} name
 * @param  {Boolean} def
 * @return {Boolean}
 */
function boolean(el, name, def) {
  var val = el.getAttribute(name);
  if (val === null) return def;
  return val === 'true' || val === '' ? true : false;
}

/**
 * Get the numeric value of an attribute on an element,
 * falling back to the default value.
 * @param  {Element} el
 * @param  {String} name
 * @param  {Boolean} def
 * @return {Boolean}
 */
function number(el, name, def) {
  var val = el.getAttribute(name);
  if (val === null) return def;
  return parseInt(val, 10);
}

/**
 * Get the string value of an attribute on an element,
 * falling back to the default value.
 * @param  {Element} el
 * @param  {String} name
 * @param  {Boolean} def
 * @return {Boolean}
 */
function string(el, name, def) {
  var val = el.getAttribute(name);
  if (val === null) return def;
  return val;
}


},{}],67:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));
var _trim = _interopRequireDefault(require("../util/trim"));
/**
 * # Remove Class
 * Remove a class on an element.
 *
 * @param {Element|Array} el An element or array of elements to update.
 * @param {String} name
 * @return {Element}
 *
 * @module helpers/dom/remove-class.js
 */

var ws = /\s+/;
var cleanup = /\s{2,}/g;
function removeClass(el, name) {
  if (!el) {
    return;
  }
  if (arguments.length === 2 && typeof name === 'string') {
    name = (0, _trim.default)(name).split(ws);
  } else {
    name = name instanceof Array ? name : (0, _slice.default)(Array.prototype).call(arguments, 1);
  }

  // optimize for best, most common case
  if (name.length === 1 && el.classList) {
    if (name[0]) el.classList.remove(name[0]);
    return el;
  }

  // store two copies
  var clsName = ' ' + (typeof el.className === 'string' ? el.className : el.getAttribute ? el.getAttribute('class') : '') + ' ';
  var result = clsName;
  var current;
  var start;
  for (var i = 0, l = name.length; i < l; i++) {
    current = name[i];
    start = current ? result.indexOf(' ' + current + ' ') : -1;
    if (start !== -1) {
      start += 1;
      result = (0, _slice.default)(result).call(result, 0, start) + (0, _slice.default)(result).call(result, start + current.length);
    }
  }

  // only write if modified
  if (clsName !== result) {
    if (typeof el.className === 'string') {
      el.className = (0, _trim.default)(result.replace(cleanup, ' '));
    } else if (el.setAttribute) {
      el.setAttribute('class', (0, _trim.default)(result.replace(cleanup, ' ')));
    }
  }
  return el;
}
var _default = removeClass;
exports.default = _default;
module.exports = exports.default;


},{"../util/trim":102,"@babel/runtime-corejs3/core-js-stable/instance/slice":115,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],68:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _hasClass = _interopRequireDefault(require("./has-class"));
var _addClass = _interopRequireDefault(require("./add-class"));
var _removeClass = _interopRequireDefault(require("./remove-class"));
/**
 * # Toggle Class
 * Toggle a class on an element given a condition.
 *
 * @param {Element|Array} el An element or array of elements to update.
 * @param {String} name
 * @param {Boolean} enable
 * @return {Element}
 *
 * @module  helpers/dom/toggle-class.js
 */

function toggleClass(el, name, enable) {
  if (!el) {
    return;
  }

  // If we're passed an array, toggle the class on each.
  if (el instanceof NodeList || el instanceof Array) {
    for (var i = 0, len = el.length; i < len; i++) {
      toggleClass(el[i], name, enable);
    }
    return;
  }
  var action;
  if (enable !== undefined) {
    enable = typeof enable === 'function' ? enable.call(null, el) : enable;
    action = enable ? 'add' : 'remove';
  } else {
    action = (0, _hasClass.default)(el, name) ? 'remove' : 'add';
  }
  return (action === 'add' ? _addClass.default : _removeClass.default)(el, name);
}
var _default = toggleClass;
exports.default = _default;
module.exports = exports.default;


},{"./add-class":59,"./has-class":61,"./remove-class":67,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],69:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # Trigger Event
 * Trigger a DOM event on an element.
 *
 * @param {Element} el
 * @param {String} name
 *
 * @module helpers/dom/trigger-event.js
 */
function triggerEvent(el, name) {
  var event;
  if (document.createEvent) {
    event = document.createEvent('HTMLEvents');
    event.initEvent(name, true, true);
    event.eventName = name;
    el.dispatchEvent(event);
  } else {
    event = document.createEventObject();
    event.eventType = name;
    event.eventName = name;
    el.fireEvent('on' + event.eventType, event);
  }
}
var _default = triggerEvent;
exports.default = _default;
module.exports = exports.default;


},{}],70:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/typeof"));
/**
 * # Build Select
 * Build a select input.
 *
 * @param {Object} params
 *
 * @example
 * buildSelect({
 *   attributes: {
 *     name: 'test',
 *     class: 'spark-select__field'
 *   },
 *   options: [1, 2, 3, 4, 5, 6]
 * });
 *
 * @example
 * buildSelect({
 *   attributes: {
 *     name: 'test',
 *     class: 'spark-select__field',
 *     'data-attr': 'thing',
 *      multiple: true
 *   },
 *   selected: [2, 4],
 *   options: [
 *     {text: 'One', value: 1},
 *     {text: 'Two', value: 2},
 *     {text: 'Three', value: 3},
 *     {text: 'Four', value: 4},
 *     {text: 'Five', value: 5},
 *   ]
 * });
 *
 * @module helpers/form/build-select.js
 */

function buildSelect(params) {
  var el = document.createElement('select');
  var html = '';
  var attrs = params.attributes;
  var selected = params.selected instanceof Array ? params.selected : params.selected ? [params.selected] : [];
  var opts = params.options;
  var i;
  var len = opts.length;

  // Set attributes
  for (i in attrs) {
    el.setAttribute(i, attrs[i]);
  }

  // Add options
  for (i = 0; i < len; i++) {
    if ((0, _typeof2.default)(opts[i]) === 'object') {
      html += '<option value="' + opts[i].value + '" ' + (selected.indexOf(opts[i].value) !== -1 ? 'selected' : '') + '>' + opts[i].text + '</option>';
    } else {
      html += '<option value="' + opts[i] + '" ' + (selected.indexOf(opts[i]) !== -1 ? 'selected' : '') + '>' + opts[i] + '</option>';
    }
  }
  el.innerHTML = html;
  return el;
}
var _default = buildSelect;
exports.default = _default;
module.exports = exports.default;


},{"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/typeof":162}],71:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.clear = clear;
exports.restore = restore;
exports.store = store;
var _each = _interopRequireDefault(require("../util/each"));
/**
 * # Form Data
 * Store and restore the data of form fields inline so it can be reverted.
 *
 * @example
 * formData.store(el);
 * formData.revert(el);
 *
 * @module helpers/form/form-data.js
 */

/**
 * Find all the form elements inside a given element and run a callback on each.
 * @param  {Element} el
 * @param  {Function} cb
 */
function findAll(el, cb) {
  (0, _each.default)(el.querySelectorAll('input, select, textarea'), function (i) {
    cb(i);
  });
}

/**
 * Find all the form elements inside a given element and store their current
 * value as a data attribute.
 * @param {Element} el
 */
function store(el) {
  findAll(el, function (input) {
    var name = input.nodeName.toLowerCase();
    var value;
    switch (name) {
      case 'select':
        value = input.selectedIndex;
        break;
      default:
        value = encodeURI(input.value);
        break;
    }
    input.setAttribute('data-stored-value', value);
  });
}

/**
 * Revert all the form elements inside of a given element.
 * @param {Element} el
 */
function restore(el) {
  findAll(el, function (input) {
    var name = input.nodeName.toLowerCase();
    var value = input.getAttribute('data-stored-value');

    // No stored value
    if (!value && value !== '') {
      return;
    }
    switch (name) {
      case 'select':
        input.options[value].selected = true;
        break;
      default:
        input.value = decodeURI(value);
        break;
    }
    input.removeAttribute('data-stored-value');
  });
}

/**
 * Clear the stored data on all the form elements inside of a given element.
 * @param {Element} el
 */
function clear(el) {
  findAll(el, function (input) {
    input.removeAttribute('data-stored-value');
  });
}


},{"../util/each":94,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],72:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # Set Caret
 * Set the caret position in an input.
 *
 * @param {Element} el
 * @param {Number} start
 * @param {Number} end
 *
 * @example
 * setCaret(el, -1);
 * setCaret(el, 2);
 *
 * @module helpers/form/set-caret.js
 */
function setCaret(el, start, end) {
  var originalActiveElement = document.activeElement;
  start = start < 0 ? el.value.length + start + 1 : start;
  end = end < 0 ? el.value.length + end + 1 : end;

  // IE support
  if (document.selection) {
    el.focus();
    var sel = document.selection.createRange();
    sel.moveStart('character', -el.value.length);
    sel.moveStart('character', start);
    sel.moveEnd('character', end !== undefined ? end : start);
    sel.select();
  } else if (el.selectionStart || el.selectionStart === 0) {
    el.selectionStart = start;
    el.selectionEnd = end !== undefined ? end : start;
  }

  // If we didn't have focus, go back to focusing on the original
  if (originalActiveElement !== el) {
    el.blur();
    originalActiveElement.focus();
  }
  return {
    start: start,
    end: end
  };
}
var _default = setCaret;
exports.default = _default;
module.exports = exports.default;


},{}],73:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _each = _interopRequireDefault(require("../util/each"));
/**
 * # Append Children
 * Append an array of children to a node.
 *
 * @param {Element} el
 * @param {Array} children
 * @param {Boolean} empty Empty the node before adding children?
 *
 * @module helpers/manipulation/append-children.js
 */

function appendChildren(el, children, empty) {
  empty = empty === undefined ? false : empty;
  if (empty) {
    el.textContent = '';
  }
  var domList = children instanceof window.HTMLCollection;
  if (domList) {
    while (children.length) {
      el.appendChild(children[0]);
    }
  } else {
    (0, _each.default)(children, function (c) {
      if (c) {
        el.appendChild(c);
      }
    });
  }
}
var _default = appendChildren;
exports.default = _default;
module.exports = exports.default;


},{"../util/each":94,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],74:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _each = _interopRequireDefault(require("../util/each"));
/**
 * # Copy Attributes
 * Copy all of the attributes from one element to another.
 *
 * @param {Element} a
 * @param {Element} b
 *
 * @module helpers/manipulation/copy-attributes.js
 */

function copyAttributes(a, b) {
  (0, _each.default)(a.attributes, function (attr) {
    b.setAttribute(attr.name, attr.value);
  });
}
var _default = copyAttributes;
exports.default = _default;
module.exports = exports.default;


},{"../util/each":94,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],75:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _each = _interopRequireDefault(require("../util/each"));
/**
 * # Insert Before
 * Insert an array of elements before a node.
 *
 * @param {Element} el
 * @param {Element} beforeEl
 * @param {Array} children
 *
 * @module helpers/manipulation/insert-before.js
 */

function insertBefore(el, beforeEl, children) {
  (0, _each.default)(children, function (c) {
    el.insertBefore(c, beforeEl);
  });
}
var _default = insertBefore;
exports.default = _default;
module.exports = exports.default;


},{"../util/each":94,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],76:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # Wrap Element
 * Wrap an element with another element.
 *
 * @param {Element} el
 * @param {Element} wrapper
 * @return {Element}
 *
 * @module helpers/manipulation/wrap-element.js
 */
function wrapElement(el, wrapper) {
  wrapper = wrapper || document.createElement('div');
  if (el.nextSibling) {
    el.parentNode.insertBefore(wrapper, el.nextSibling);
  } else {
    el.parentNode.appendChild(wrapper);
  }
  return wrapper.appendChild(el);
}
var _default = wrapElement;
exports.default = _default;
module.exports = exports.default;


},{}],77:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # assign
 * Object.assign() polyfill from MDN
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill
 *
 * @param {Object} target
 * @param {Object} varArgs
 * @return {Object}
 *
 * @example
 * assign({a: 1, b: 2}, {c: 3});
 *
 * @module helpers/polyfill/assign.js
 */
function assign(target) {
  if (target === null) {
    // TypeError if undefined or null
    throw new TypeError('Cannot convert undefined or null to object');
  }
  var to = Object(target);
  for (var index = 1; index < arguments.length; index++) {
    var nextSource = arguments[index];

    // Skip over if undefined or null
    if (nextSource !== null) {
      for (var nextKey in nextSource) {
        // Avoid bugs when hasOwnProperty is shadowed
        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
          to[nextKey] = nextSource[nextKey];
        }
      }
    }
  }
  return to;
}
var _default = assign;
exports.default = _default;
module.exports = exports.default;


},{}],78:[function(require,module,exports){
"use strict";

/**
 * # closest
 * Element.closest() polyfill from MDN
 * https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#polyfill
*/

if (typeof window !== "undefined") {
  if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  }
  if (!Element.prototype.closest) {
    Element.prototype.closest = function (s) {
      var el = this;
      do {
        if (Element.prototype.matches.call(el, s)) return el;
        el = el.parentElement || el.parentNode;
      } while (el !== null && el.nodeType === 1);
      return null;
    };
  }
}


},{}],79:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # repeat
 * String.repeat() polyfill from MDN
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat#Polyfill
 *
 * @param {String} string
 * @param {Number} count
 * @return  {String}
 *
 * @example
 * repeat('Hello World!', 5);
 *
 * @module helpers/polyfill/repeat.js
 */
function repeat(string, count) {
  var str = '' + string;
  count = +count;
  if (count !== count) {
    count = 0;
  }
  if (count < 0) {
    throw new RangeError('repeat count must be non-negative');
  }
  if (count === Infinity) {
    throw new RangeError('repeat count must be less than infinity');
  }
  count = Math.floor(count);
  if (str.length === 0 || count === 0) {
    return '';
  }

  // Ensuring count is a 31-bit integer allows us to heavily optimize the
  // main part. But anyway, most current (August 2014) browsers can't handle
  // strings 1 << 28 chars or longer, so:
  if (str.length * count >= 1 << 28) {
    throw new RangeError('repeat count must not overflow maximum string size');
  }
  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));
  while (count) {
    str += str;
    count--;
  }
  str += str.substring(0, maxCount - str.length);
  return str;
}
var _default = repeat;
exports.default = _default;
module.exports = exports.default;


},{}],80:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # startsWith
 * String.startsWith() polyfill from MDN
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill
 *
 * @param {String} string
 * @param {String} search
 * @param {Number} pos
 * @return  {Boolean}
 *
 * @example
 * startsWith('Hello World!', 'Hello');
 *
 * @module helpers/polyfill/starts-with.js
 */
function startsWith(string, search, pos) {
  return string.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}
var _default = startsWith;
exports.default = _default;
module.exports = exports.default;


},{}],81:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));
var _offset2 = _interopRequireDefault(require("../dom/offset"));
var _boxPosition = _interopRequireDefault(require("./box-position"));
var _debounce = _interopRequireDefault(require("../util/debounce"));
require("../polyfill/closest");
/**
 * # Affix
 * Affix one element to another.
 *
 * @example
 * new Affix({
 *   el: el,
 *   targetEl: el2,
 *   caretEl: el3,
 *   anchorY: 'top', // 'middle', 'bottom'
 *   anchorX: 'left', // 'center', 'right'
 * })
 *
 * @module helpers/position/affix.js
 */
var Affix = /*#__PURE__*/function () {
  /**
   * Store the reference elements and position.
   * @param  {Object} params
   */
  function Affix() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, Affix);
    this.el = params.el;
    this.targetEl = params.targetEl;
    this.caretEl = params.caretEl;
    this.anchorY = params.anchorY || 'top';
    this.anchorX = params.anchorX || 'center';
    this.isFixed = params.isFixed || false;
    this.scrollEl = this._setScrollEl();
    this._addEventListeners();
    this._insertEl();
    this._setPosition();
    this._updateDebounced = (0, _debounce.default)(this.update.bind(this), 10);
  }
  (0, _createClass2.default)(Affix, [{
    key: "_setScrollEl",
    value: function _setScrollEl() {
      var parent = this.targetEl;
      return this.scrollEl = parent.closest('.spark-modal__scroll') || window;
    }

    /**
     * Stop listening and clean up event listeners
     * @param {Object} params Optional
     * @return {Object} this
     */
  }, {
    key: "remove",
    value: function remove() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (!params.keepEl) this._removeEl();
      this._removeEventListeners();
      return this;
    }

    /**
     * Update the position.
     * @return {Object} this
     */
  }, {
    key: "update",
    value: function update() {
      this._setPosition();
      return this;
    }

    /**
     * Listen for window resizes to update the position.
     */
  }, {
    key: "_addEventListeners",
    value: function _addEventListeners() {
      this._onResizeBound = this._onResize.bind(this);
      this._onScrollBound = this._onScroll.bind(this);
      window.addEventListener('resize', this._onResizeBound);
      this.scrollEl.addEventListener('scroll', this._onScrollBound);
    }

    /**
     * Remove event listeners
     */
  }, {
    key: "_removeEventListeners",
    value: function _removeEventListeners() {
      window.removeEventListener('resize', this._onResizeBound);
      this.scrollEl.removeEventListener('scroll', this._onScrollBound);
    }

    /**
     * Insert the element into the DOM.
     */
  }, {
    key: "_insertEl",
    value: function _insertEl() {
      this.el.setAttribute('data-affixed', '');
      this._getRootEl().appendChild(this.el);
    }

    /**
     * Remove the element from the DOM.
     */
  }, {
    key: "_removeEl",
    value: function _removeEl() {
      this.el.parentNode.removeChild(this.el);
      this.el.removeAttribute('data-affixed');
    }

    /**
     * Set the position of the target element.
     */
  }, {
    key: "_setPosition",
    value: function _setPosition() {
      // Fixed position
      this.el.style.setProperty('position', this.isFixed ? 'fixed' : 'absolute', 'important');

      // Target element properties
      var _offset = (0, _offset2.default)(this.targetEl, this.isFixed),
        targetTop = _offset.top,
        targetLeft = _offset.left;
      var targetWidth = this.targetEl.offsetWidth;
      var targetHeight = this.targetEl.offsetHeight;

      // Element to affix properties
      var elWidth = this.el.offsetWidth;
      var elHeight = this.el.offsetHeight;

      // Maxes
      var docHeight = document.documentElement.offsetHeight;
      var docWidth = document.documentElement.offsetWidth;

      // Get the values
      var _this$_calculatePosit = this._calculatePosition({
          anchorX: this.anchorX,
          anchorY: this.anchorY,
          targetTop: targetTop,
          targetLeft: targetLeft,
          elHeight: elHeight,
          elWidth: elWidth,
          targetHeight: targetHeight,
          targetWidth: targetWidth,
          minX: 0,
          minY: 0,
          maxX: docWidth - elWidth,
          maxY: Math.max(docHeight - elHeight, 0)
        }),
        elTop = _this$_calculatePosit.elTop,
        elLeft = _this$_calculatePosit.elLeft;

      // Position the caret
      var _this$_positionCaret = this._positionCaret({
          elLeft: elLeft,
          elTop: elTop,
          elWidth: elWidth,
          elHeight: elHeight,
          targetHeight: targetHeight,
          targetWidth: targetWidth,
          targetLeft: targetLeft,
          targetTop: targetTop
        }),
        extraLeft = _this$_positionCaret.extraLeft,
        extraTop = _this$_positionCaret.extraTop;

      // Set the position
      this.el.style.left = elLeft + extraLeft + 'px';
      this.el.style.top = elTop + extraTop + 'px';
    }

    /**
     * Get the proper top position for an anchor direction.
     * @param  {Object} p
     * @return {Object}
     */
  }, {
    key: "_calculatePosition",
    value: function _calculatePosition(p) {
      // Keep track of what we're trying to do here, so on subsequent, nested calls to this
      // method we can see what has already been tried.
      p.previousAttempts = (p.previousAttempts || 0) + 1;
      p.previousChecks = p.previousChecks || [];
      var finalCheck = p.previousAttempts > 3;
      var top;
      var left;

      // Y-axis check
      switch (p.anchorY) {
        case 'bottom':
          top = p.targetTop + p.targetHeight;
          break;
        case 'middle':
          top = p.targetTop - (p.elHeight - p.targetHeight) / 2;
          break;
        default:
          top = p.targetTop - p.elHeight;
          break;
      }

      // Under min
      if (top < p.minY) {
        if (!finalCheck && p.previousChecks.indexOf('overY') === -1) {
          p.previousChecks.push('underY');
          p.anchorY = this._getNewAnchorY(true, p.anchorY, p.anchorX);
          return this._calculatePosition(p);
        } else {
          top = p.targetTop;
          if (p.anchorY === 'top') {
            top = top + p.targetHeight;
          }
        }
      }

      // Over max
      if (top > p.maxY) {
        if (!finalCheck && p.previousChecks.indexOf('underY') === -1) {
          p.previousChecks.push('overY');
          p.anchorY = this._getNewAnchorY(false, p.anchorY, p.anchorX);
          return this._calculatePosition(p);
        } else if (!(finalCheck && p.anchorY === 'bottom')) {
          top = p.targetTop - p.elHeight;
        }
      }

      // X-axis check
      switch (p.anchorX) {
        case 'right':
          left = p.targetLeft + (p.anchorY !== 'middle' && !p.isOverlapping ? 0 : p.targetWidth);
          break;
        case 'center':
          left = p.targetLeft - (p.elWidth - p.targetWidth) / 2;
          break;
        default:
          left = p.targetLeft - p.elWidth + (p.anchorY !== 'middle' ? p.targetWidth : 0);
          break;
      }

      // Under min
      if (left < p.minX) {
        if (!finalCheck && p.previousChecks.indexOf('overX') === -1) {
          p.previousChecks.push('underX');
          p.anchorX = this._getNewAnchorX(true, p.anchorX, p.anchorY);
          return this._calculatePosition(p);
        } else {
          left = p.minX;
        }
      }

      // Over max
      if (left > p.maxX) {
        if (!finalCheck && p.previousChecks.indexOf('underX') === -1) {
          p.previousChecks.push('overX');
          p.anchorX = this._getNewAnchorX(false, p.anchorX, p.anchorY);
          return this._calculatePosition(p);
        } else {
          left = p.maxX;
        }
      }

      // One element is covering another. Try to fix that, but bail out after four tries.
      if ((0, _boxPosition.default)({
        width: p.elWidth,
        height: p.elHeight,
        left: left,
        top: top
      }, {
        width: p.targetWidth,
        height: p.targetHeight,
        left: p.targetLeft,
        top: p.targetTop
      }) === 'overlap') {
        p.isOverlapping = true;

        // Try Y
        if (p.repositionY !== false && p.targetTop > 0) {
          // Will start undefined, then true, then false. This limits us to entering
          // this loop twice, once to try moving in each direction.
          p.repositionY = !p.repositionY;

          // First try to put above, then try to put below.
          p.anchorY = this._getNewAnchorY(p.repositionY, 'middle', p.anchorX);

          // Give us one more shot at positioning
          p.previousAttempts--;
          return this._calculatePosition(p);

          // Try X
        } else if (p.repositionX !== false && p.previousChecks.indexOf('underX') !== -1) {
          // Will start undefined, then true, then false. This limits us to entering
          // this loop twice, once to try moving in each direction.
          p.repositionX = !p.repositionX;

          // First try to put above, then try to put below.
          p.anchorX = this._getNewAnchorX(p.repositionX, 'center', p.anchorY);

          // Give us one more shot at positioning
          p.previousAttempts--;
          return this._calculatePosition(p);
        }
      }
      return {
        elTop: top,
        elLeft: left,
        anchorX: p.anchorX,
        anchorY: p.anchorY
      };
    }

    /**
     * Determine the new y-axis anchor
     * @param  {Boolean} underMin Under the min?
     * @param  {String} anchorY
     * @param  {String} anchorX
     * @return {String}
     */
  }, {
    key: "_getNewAnchorY",
    value: function _getNewAnchorY(underMin, anchorY, anchorX) {
      // If the x-axis is anchored in the center, skip
      // trying to anchor to the middle because then we'd
      // be overlaying the button.
      if (anchorX === 'center' || anchorY === 'middle') {
        return underMin ? 'bottom' : 'top';
      } else {
        return 'middle';
      }
    }

    /**
     * Determine the new y-axis anchor
     * @param  {Boolean} underMin Under the min?
     * @param  {String} anchorY
     * @param  {String} anchorX
     * @return {String}
     */
  }, {
    key: "_getNewAnchorX",
    value: function _getNewAnchorX(underMin, anchorX, anchorY) {
      // If the y-axis is anchored in the center, skip
      // trying to anchor to the middle because then we'd
      // be overlaying the button.
      if (anchorY === 'middle' || anchorX === 'center') {
        return underMin ? 'left' : 'right';
      } else {
        return 'center';
      }
    }

    /**
     * Set the position of the caret.
     * @param {Object} p
     * @return {Object}
     */
  }, {
    key: "_positionCaret",
    value: function _positionCaret() {
      var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (!this.caretEl) return;
      var caretPosition = (0, _boxPosition.default)({
        width: p.elWidth,
        height: p.elHeight,
        left: p.elLeft,
        top: p.elTop
      }, {
        width: p.targetWidth,
        height: p.targetHeight,
        left: p.targetLeft,
        top: p.targetTop
      });
      var caretDimensions = this.caretEl.getBoundingClientRect();
      var caretWidth = caretDimensions.width;
      var caretHeight = caretDimensions.height;
      var left = Math.min(p.elWidth, Math.max(0, p.targetLeft - p.elLeft + p.targetWidth / 2));
      var top = Math.min(p.elHeight, Math.max(0, p.targetTop - p.elTop + p.targetHeight / 2));
      this.caretEl.style.left = Math.round(left) + 'px';
      this.caretEl.style.top = Math.round(top) + 'px';
      var extraLeft = 0;
      var extraTop = 0;
      this.caretEl.setAttribute('data-position', caretPosition);
      switch (caretPosition) {
        case 'above':
          extraTop = -caretWidth / 2;
          break;
        case 'below':
          extraTop = caretWidth / 2;
          break;
        case 'left':
          extraLeft = -caretHeight / 2;
          break;
        default:
          extraLeft = caretHeight / 2;
          break;
      }
      return {
        extraLeft: extraLeft,
        extraTop: extraTop
      };
    }

    /**
     * Get the root element. Want to check if there's a top-level form for working
     * with ASP .NET pages.
     */
  }, {
    key: "_getRootEl",
    value: function _getRootEl() {
      var form = document.querySelector('body > form');
      return form && form.getAttribute('data-affixed') === null ? form : document.body;
    }

    /**
     * On resize, update the position.
     */
  }, {
    key: "_onResize",
    value: function _onResize() {
      this.update();
    }

    /**
     * When the window scrolls, ensure the proper position of the popover.
     */
  }, {
    key: "_onScroll",
    value: function _onScroll() {
      this._updateDebounced();
    }
  }]);
  return Affix;
}();
var _default = Affix;
exports.default = _default;
module.exports = exports.default;


},{"../dom/offset":63,"../polyfill/closest":78,"../util/debounce":93,"./box-position":82,"@babel/runtime-corejs3/helpers/classCallCheck":144,"@babel/runtime-corejs3/helpers/createClass":145,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],82:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = _default;
/**
 * # Box Position
 * How is one element positioned relative to another?
 *
 * @example
 * boxPosition(
 * {width: 100, height: 300, left: 0, top: 0},
 * {width: 200, height: 50, left: 100, top: 40}
 * )
 *
 * @module helpers/position/box-position.js
 *
 * @param {Object} a
 * @param {Object} b
 * @return {String}
 */
function _default(a, b) {
  var aXSpan = a.left + a.width;
  var aYSpan = a.top + a.height;
  var bXSpan = b.left + b.width;
  var bYSpan = b.top + b.height;

  // a is fully left of b
  if (aXSpan <= b.left) return 'left';

  // a is fully right of b
  if (a.left >= bXSpan) return 'right';

  // a is fully above b
  if (aYSpan <= b.top) return 'above';

  // a is fully below b
  if (a.top >= bYSpan) return 'below';

  // boxes overlap
  return 'overlap';
}
module.exports = exports.default;


},{}],83:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.convertMinutesToTime = convertMinutesToTime;
exports.convertTimeTo12Hr = convertTimeTo12Hr;
exports.convertTimeTo24Hr = convertTimeTo24Hr;
exports.convertTimeToMinutes = convertTimeToMinutes;
exports.getTimePeriod = getTimePeriod;
exports.isValidTime = isValidTime;
var _padStart = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/pad-start"));
var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));
var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/includes"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/slicedToArray"));
/**
 * # Time helper
 * General helpers for working with times.
 *
 * @module helpers/time/time.js
 */

/**
 * Check if provided time is valid
 * @param  {String} time
 * @return {Boolean|String}
 */
function isValidTime(time) {
  var timeString = time;
  if (timeString.indexOf(':') === -1) {
    return false;
  }

  // Remove all spaces and periods from the string
  timeString = timeString.replace(/\.|\s/g, '').toLowerCase();
  if (timeString.indexOf('am') === -1 && timeString.indexOf('pm') === -1) {
    // 24-hour clock system
    if (timeString.length !== 5) {
      return false;
    }
    var _timeString$split = timeString.split(':'),
      _timeString$split2 = (0, _slicedToArray2.default)(_timeString$split, 2),
      hours = _timeString$split2[0],
      minutes = _timeString$split2[1];
    if (parseInt(minutes) < 0 || parseInt(minutes) >= 60) {
      return false;
    }
    if (parseInt(hours) >= 0 && parseInt(hours) <= 23) {
      return '24';
    } else {
      return false;
    }
  } else {
    // 12-hour clock system
    if (timeString.length !== 7) {
      return false;
    }
    var _timeString$split3 = timeString.split(':'),
      _timeString$split4 = (0, _slicedToArray2.default)(_timeString$split3, 2),
      _hours = _timeString$split4[0],
      _minutes = _timeString$split4[1];
    if (parseInt(_minutes) < 0 || parseInt(_minutes) >= 60) {
      return false;
    }
    if (parseInt(_hours) >= 1 && parseInt(_hours) <= 12) {
      return '12';
    } else {
      return false;
    }
  }
}

/**
 * Convert 24hr time to 12hr time
 * @param  {String} time
 * @return {String}
 */
function convertTimeTo12Hr(time) {
  var timeString = time.replace(/\.|\s/g, '').toLowerCase();
  var isValid = isValidTime(timeString);
  if (isValid) {
    if (isValid === '24') {
      var _context, _context2, _context3, _context4;
      var _timeString$split5 = timeString.split(':'),
        _timeString$split6 = (0, _slicedToArray2.default)(_timeString$split5, 2),
        hours = _timeString$split6[0],
        minutes = _timeString$split6[1];
      var modifier = 'a.m.';
      hours = Number(hours);
      if (hours >= 12) {
        hours = hours - 12;
        modifier = 'p.m.';
      }
      if (hours === 0) {
        hours = 12;
      }
      hours = (0, _padStart.default)(_context = hours.toString()).call(_context, 2, '0');
      minutes = (0, _padStart.default)(_context2 = minutes.toString()).call(_context2, 2, '0');
      return (0, _concat.default)(_context3 = (0, _concat.default)(_context4 = "".concat(hours, ":")).call(_context4, minutes, " ")).call(_context3, modifier);
    }
    return time;
  }
  return undefined;
}

/**
 * Convert 12hr time to 24hr time
 * @param  {String} time
 * @return {String}
 */
function convertTimeTo24Hr(time) {
  var timeString = time.replace(/\.|\s/g, '').toLowerCase();
  var isValid = isValidTime(timeString);
  if (isValid) {
    if (isValid === '12') {
      var _context5;
      var _timeString$split7 = timeString.split(':'),
        _timeString$split8 = (0, _slicedToArray2.default)(_timeString$split7, 2),
        hours = _timeString$split8[0],
        minutes = _timeString$split8[1];
      var modifier;
      if ((0, _includes.default)(minutes).call(minutes, 'am') || (0, _includes.default)(minutes).call(minutes, 'pm')) {
        modifier = minutes.substr(minutes.length - 2);
        minutes = minutes.substr(0, minutes.length - 2);
      }
      if (hours === '12') {
        hours = '00';
      }
      if (modifier === 'pm') {
        hours = parseInt(hours, 10) + 12;
      }
      return (0, _concat.default)(_context5 = "".concat(hours, ":")).call(_context5, minutes);
    }
    return time;
  }
  return undefined;
}

/**
 * Convert minutes since midnight to 12hr or 24hr time convention
 * @param  {String} minutesAfterMidnight
 * @param  {String} convention
 * @return {String}
 */
function convertMinutesToTime(minutesAfterMidnight, convention) {
  var _context6, _context7, _context9;
  var timeInt = parseInt(minutesAfterMidnight);

  // 0 for midnight, 1439 for 11:59 p.m.
  if (isNaN(timeInt) || timeInt > 1439) {
    return undefined;
  }
  var hours = Math.floor(timeInt / 60);
  hours = (0, _padStart.default)(_context6 = hours.toString()).call(_context6, 2, '0');
  var minutes = timeInt % 60;
  minutes = (0, _padStart.default)(_context7 = minutes.toString()).call(_context7, 2, '0');
  if (convention === '12') {
    var _context8;
    var timeString = (0, _concat.default)(_context8 = "".concat(hours, ":")).call(_context8, minutes);
    var timeIn12Hr = convertTimeTo12Hr(timeString);
    return timeIn12Hr;
  }
  return (0, _concat.default)(_context9 = "".concat(hours, ":")).call(_context9, minutes);
}

/**
 * Convert 12hr or 24hr time to minutes since midnight
 * @param  {String} time
 * @return {Integer}
 */
function convertTimeToMinutes(time) {
  var timeString = time.replace(/\.|\s/g, '').toLowerCase();
  var isValid = isValidTime(timeString);
  if (isValid) {
    if (isValid === '12') {
      timeString = convertTimeTo24Hr(timeString);
    }
    var _timeString$split9 = timeString.split(':'),
      _timeString$split10 = (0, _slicedToArray2.default)(_timeString$split9, 2),
      hours = _timeString$split10[0],
      minutes = _timeString$split10[1];
    minutes = Number(hours) * 60 + Number(minutes);
    return minutes;
  }
  return undefined;
}

/**
 * Get the period (am or pm) from a valid time
 * @param  {String} time
 * @return {String}
 */
function getTimePeriod(time) {
  var timeString = time;
  var isValid = isValidTime(timeString);
  if (isValid) {
    if (isValid === '24') {
      timeString = convertTimeTo12Hr(timeString);
    }
    var minutes = timeString.split(':')[1];
    var period;
    if ((0, _includes.default)(minutes).call(minutes, 'a.m.') || (0, _includes.default)(minutes).call(minutes, 'p.m.')) {
      period = minutes.substr(minutes.length - 4);
      return period;
    }
    return undefined;
  }
  return undefined;
}


},{"@babel/runtime-corejs3/core-js-stable/instance/concat":108,"@babel/runtime-corejs3/core-js-stable/instance/includes":112,"@babel/runtime-corejs3/core-js-stable/instance/pad-start":114,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/slicedToArray":157}],84:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _matches = _interopRequireDefault(require("./matches"));
/**
 * # Get Child
 * Get a child that matches the selector.
 *
 * @param {Element} el
 * @param {String} query
 * @return {Element|Null}
 *
 * @module helpers/traversal/get-child.js
 */

function getChild(el, query) {
  var i = 0;
  var len = el.children.length;
  for (; i < len; i++) {
    if ((0, _matches.default)(el.children[i], query)) {
      return el.children[i];
    }
  }
  return null;
}
var _default = getChild;
exports.default = _default;
module.exports = exports.default;


},{"./matches":92,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],85:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _matches = _interopRequireDefault(require("./matches"));
/**
 * # Get Children
 * See if an element has children which match a query.
 *
 * @param {Element} el
 * @param {String} query
 * @return {List}
 *
 * @module helpers/traversal/get-children.js
 */

function getChildren(el, query) {
  var list = [];
  var i = 0;
  var len = el.children.length;
  for (; i < len; i++) {
    if ((0, _matches.default)(el.children[i], query)) {
      list.push(el.children[i]);
    }
  }
  return list;
}
var _default = getChildren;
exports.default = _default;
module.exports = exports.default;


},{"./matches":92,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],86:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # Get Index
 * Get the index of an element in a nodelist.
 *
 * @param {NodeList} els
 * @param {Node} el
 * @return {Number}
 *
 * @module helpers/traversal/get-index.js
 */
function getIndex(els, el) {
  return Array.prototype.indexOf.call(els, el);
}
var _default = getIndex;
exports.default = _default;
module.exports = exports.default;


},{}],87:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _matches = _interopRequireDefault(require("./matches"));
/**
 * # Get Parent
 * See if an element has another element for a parent.
 *
 * @param {Element} parent
 * @param {String} query
 * @param {Array|Element} limitEl The last element we should check.
 * @return {Boolean|Element}
 *
 * @module helpers/traversal/get-parent.js
 */

function getParent(parent, query, limitEl) {
  limitEl = limitEl instanceof Array ? limitEl : [limitEl || document.body];
  while (parent) {
    if ((0, _matches.default)(parent, query)) {
      return parent;
    }
    if (limitEl.indexOf(parent) !== -1) {
      return false;
    }
    parent = parent.parentNode;
  }
  return false;
}
var _default = getParent;
exports.default = _default;
module.exports = exports.default;


},{"./matches":92,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],88:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _getParent = _interopRequireDefault(require("./get-parent"));
/**
 * # Get Parents
 * See if an element has parents which match a query.
 *
 * @param {Element} parent
 * @param {String} query
 * @param {Element} limitEl The last element we should check.
 * @return {Boolean|Array}
 *
 * @module helpers/traversal/get-parents.js
 */

function getParents(parent, query, limitEl) {
  var list = [];
  while (parent = (0, _getParent.default)(parent.parentNode, query, limitEl)) {
    list.push(parent);
  }
  return list;
}
var _default = getParents;
exports.default = _default;
module.exports = exports.default;


},{"./get-parent":87,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],89:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _matches = _interopRequireDefault(require("./matches"));
/**
 * # Get Sibling After
 * Get a nearest sibling after the given element which matches
 * the given query selector.
 *
 * @param {Element} el
 * @param {String} query
 * @return {Element|Null}
 *
 * @module helpers/traversal/get-sibling-after.js
 */

function getSiblingAfter(el, query) {
  while (el = el.nextElementSibling) {
    if ((0, _matches.default)(el, query)) {
      return el;
    }
  }
  return null;
}
var _default = getSiblingAfter;
exports.default = _default;
module.exports = exports.default;


},{"./matches":92,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],90:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _matches = _interopRequireDefault(require("./matches"));
/**
 * # Get Sibling Before
 * Get a nearest sibling before the given element which matches
 * the given query selector.
 *
 * @param {Element} el
 * @param {String} query
 * @return {Element|Null}
 *
 * @module helpers/traversal/get-sibling-before.js
 */

function getSiblingBefore(el, query) {
  while (el = el.previousElementSibling) {
    if ((0, _matches.default)(el, query)) {
      return el;
    }
  }
  return null;
}
var _default = getSiblingBefore;
exports.default = _default;
module.exports = exports.default;


},{"./matches":92,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],91:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # Has Parent
 * See if an element has another element for a parent.
 *
 * @param {Element} child
 * @param {Element} possibleParent
 * @return {Boolean}
 *
 * @module helpers/traversal/has-parent.js
 */
function hasParent(child, possibleParent) {
  var parent = child.parentNode;
  while (parent) {
    if (parent === possibleParent) {
      return true;
    }
    parent = parent.parentNode;
  }
  return false;
}
var _default = hasParent;
exports.default = _default;
module.exports = exports.default;


},{}],92:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # Matches
 * See if an element matches a query selector.
 *
 * @param {Element} el
 * @param {String} query
 * @return {Boolean}
 *
 * @module helpers/traversal/matches.js
 */
var vendorMatch = typeof Element !== 'undefined' && (Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector);
function matches(el, query) {
  if (vendorMatch) return vendorMatch.call(el, query);
  var nodes = el.parentNode ? el.parentNode.querySelectorAll(query) : [];
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i] === el) return true;
  }
  return false;
}
var _default = matches;
exports.default = _default;
module.exports = exports.default;


},{}],93:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # Debounce
 * Debounce a function call
 *
 * @param {Function} func
 * @param {Integer} delay
 *
 * @module helpers/util/debounce.js
 */
function debounce(func, delay) {
  var timer;
  return function () {
    var args = arguments;
    if (timer) window.clearTimeout(timer);
    timer = window.setTimeout(function () {
      func.apply(this, args);
    }, delay);
  };
}
var _default = debounce;
exports.default = _default;
module.exports = exports.default;


},{}],94:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # Each
 * Apply a callback function to a list of any kind: Array, NodeList, HTMLCollection or Object.
 *
 * @param {Array|NodeList|HTMLCollection|Object} list
 * @param {Function} cb
 *
 * @example
 * each([], callback);
 * each(el.children, callback);
 * each(el.childNodes, callback);
 * each({}, callback);
 *
 * @module helpers/util/each.js
 */
function each(list, cb) {
  if (!list) {
    return;
  }
  if (typeof cb !== 'function') {
    throw new Error('Cannot invoke `each` without a callback!');
  }
  var i = 0;
  var len = list.length;

  // Object
  if (len === undefined) {
    for (i in list) {
      if (i !== 'prototype' && list.hasOwnProperty(i)) {
        cb(i, list[i]);
      }
    }

    // Array-like
  } else {
    for (; i < len; i++) {
      cb(list[i]);
    }
  }
}
var _default = each;
exports.default = _default;
module.exports = exports.default;


},{}],95:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # isInteger
 * Number.isInteger() polyfill from MDN
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger#Polyfill
 *
 * @param {Number} value
 * @return  {Boolean}
 *
 * @example
 * isInteger(4);
 *
 * @module helpers/util/is-integer.js
 */
function isInteger(value) {
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
}
var _default = isInteger;
exports.default = _default;
module.exports = exports.default;


},{}],96:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = _default;
var _each = _interopRequireDefault(require("./each"));
/**
 * # Mixin
 * Apply a mixin, or mixins, to an Object
 *
 * @example
 * mixin(proto, mix, mix2)
 *
 * @module helpers/util/mixin.js
 */

function _default(proto) {
  for (var _len = arguments.length, mixins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    mixins[_key - 1] = arguments[_key];
  }
  (0, _each.default)(mixins, function (mixin) {
    for (var i in mixin) {
      if (mixin.hasOwnProperty(i) && !proto[i]) proto[i] = mixin[i];
    }
  });
}
module.exports = exports.default;


},{"./each":94,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],97:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # Modulo
 * Float safe modulo call. Based off just-modulo, but made float safe. Math with floats can have unexpected results in JS
 *
 * @param {Function} func
 * @param {Integer} delay
 *
 * @see http://www.codeavenger.com/2017/05/19/JavaScript-Modulo-operation-and-the-Caesar-Cipher.html
 * @see https://github.com/angus-c/just#just-modulo
 */

function modulo(val, step) {
  val = Number(val);
  step = Number(step);

  // step needs to be > 0
  if (step <= 0) {
    return NaN;
  }
  var valDecCount = (val.toString().split('.')[1] || '').length;
  var stepDecCount = (step.toString().split('.')[1] || '').length;
  var decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  var valInt = parseInt(val.toFixed(decCount).replace('.', ''));
  var stepInt = parseInt(step.toFixed(decCount).replace('.', ''));
  return (valInt % stepInt + stepInt) % stepInt / Math.pow(10, decCount);
}
var _default = modulo;
exports.default = _default;
module.exports = exports.default;


},{}],98:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # Pad
 * Pad a number with leading zeros
 *
 * @param {Number} n
 * @param {Number} w
 * @param {String} c Optional String to pad with
 *
 * @example
 * pad(4, 2);
 *
 * @module helpers/util/pad.js
 */
function pad(n, w, c) {
  c = c || '0';
  n = n + '';
  return n.length >= w ? n : new Array(w - n.length + 1).join(c) + n;
}
var _default = pad;
exports.default = _default;
module.exports = exports.default;


},{}],99:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # Passive Events
 * Detect whether passive events are supported by a browser
 * Adapted from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
 *
 *
 * @module helpers/util/passive-events.js
 */

function supportsPassiveEvents() {
  var supportsPassive = false;
  try {
    var opts = Object.defineProperty({}, 'passive', {
      get: function get() {
        supportsPassive = true;
        return false;
      }
    });
    window.addEventListener('testPassive', null, opts);
    window.removeEventListener('testPassive', null, opts);
  } catch (e) {
    // Catch errors
  }
  return supportsPassive;
}
var _default = supportsPassiveEvents;
exports.default = _default;
module.exports = exports.default;


},{}],100:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # Range
 * Create a range of numbers.
 *
 * @param {Number} start
 * @param {Number} stop
 * @param {Number} step Optional
 * @return {Array}
 *
 * @module helpers/util/range.js
 */
function createRange(start, stop, step) {
  if (stop === null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }
  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range = new Array(length);
  for (var idx = 0; idx < length; idx++, start += step) {
    range[idx] = start;
  }
  return range;
}
var _default = createRange;
exports.default = _default;
module.exports = exports.default;


},{}],101:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # Round
 * Round to a given number of decimal places.
 *
 * @param {Number} num
 * @param {Number} len
 * @return {Number}
 *
 * @module helpers/util/round.js
 */
function round(num, len) {
  len = len !== undefined ? len : 2;
  var x = Math.pow(10, len);
  return Math.round(num * x) / x;
}
var _default = round;
exports.default = _default;
module.exports = exports.default;


},{}],102:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # Trim
 * Trim whitespace on a string.
 *
 * @param {String} str
 *
 * @module helpers/util/trim.js
 */

var trimRE = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
function trim(str) {
  return str.replace(trimRE, '');
}
var _default = trim;
exports.default = _default;
module.exports = exports.default;


},{}],103:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/typeof"));
var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));
var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));
var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));
/**
 * # Events Mixin
 * Add events to Spark Components
 *
 * @example
 * mixin(Component, events);
 *
 * @module mixin/events.js
 * @since 3.2.1
 */
var _default = {
  /**
   * on
   * @param {String} event
   * @param {Function} callback
   * @param {Object} data
   */
  on: function on(event, callback) {
    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (!Array.isArray(this._events)) {
      this._events = [];
    }
    if (!this._events.some(function (subscription) {
      return subscription.name === event.toLowerCase() && subscription.method === callback;
    })) {
      this._events.push({
        name: event.toLowerCase(),
        method: callback,
        data: data
      });
    }
  },
  /**
   * off
   * @param {String} event
   * @param {Function} callback
   */
  off: function off(event, callback) {
    if (!Array.isArray(this._events)) {
      this._events = [];
    } else {
      var _context;
      this._events = (0, _filter.default)(_context = this._events).call(_context, function (subscription) {
        return subscription.name !== event.toLowerCase() && subscription.method !== callback;
      });
    }
  },
  /**
   * trigger
   * @param {String} event
   * @param {*} params
   * @return {Promise}
   */
  trigger: function trigger(event) {
    var _context2;
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    if (!Array.isArray(this._events)) {
      this._events = [];
    }
    var registeredCallbacks = (0, _filter.default)(_context2 = this._events).call(_context2, function (subscription) {
      return subscription.name === event;
    });
    var callbackEvent = document.createEvent('Event');
    callbackEvent.initEvent(event.toLowerCase(), true, true);
    callbackEvent.component = this;
    if (params && (0, _typeof2.default)(params[0]) === 'object' && (0, _typeof2.default)(params[0].event) === 'object') (0, _assign.default)(callbackEvent, params[0].event);
    if (this.el) this.el.dispatchEvent(callbackEvent);
    registeredCallbacks.forEach(function (subscription) {
      var _context3;
      callbackEvent.data = subscription.data;
      subscription['method'].apply(subscription, (0, _concat.default)(_context3 = [callbackEvent]).call(_context3, params));
    });
  }
};
exports.default = _default;
module.exports = exports.default;


},{"@babel/runtime-corejs3/core-js-stable/instance/concat":108,"@babel/runtime-corejs3/core-js-stable/instance/filter":110,"@babel/runtime-corejs3/core-js-stable/object/assign":122,"@babel/runtime-corejs3/helpers/interopRequireDefault":150,"@babel/runtime-corejs3/helpers/typeof":162}],104:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _height = _interopRequireDefault(require("../helpers/animation/height"));
/**
 * # Messaging Mixin
 * Add functionality for showing messages related to a form field.
 *
 * @example
 * mixin(Component, messaging);
 *
 * @module mixin/messaging.js
 */
var _default = {
  /**
   * Set the error state.
   * @param {String} message Optional
   */
  setError: function setError(message) {
    // Animate down
    if (!this._isMessageVisible()) {
      this._showMessage();
    }
    this.clearWarning();
    this.clearSuccess();
    this.clearInfo();
    this.el.setAttribute('data-error', true);
    if (message) {
      this.setMessage(message);
    }
    return this;
  },
  /**
   * Set the error state.
   */
  clearError: function clearError() {
    this.el.removeAttribute('data-error', true);
    return this;
  },
  /**
   * Set the warning state.
   * @param {String} message Optional
   */
  setWarning: function setWarning(message) {
    // Animate down
    if (!this._isMessageVisible()) {
      this._showMessage();
    }
    this.clearError();
    this.clearSuccess();
    this.clearInfo();
    this.el.setAttribute('data-warning', true);
    if (message) {
      this.setMessage(message);
    }
    return this;
  },
  /**
   * Set the error state.
   */
  clearWarning: function clearWarning() {
    this.el.removeAttribute('data-warning', true);
    return this;
  },
  /**
   * Set the success state.
   * @param {String} message Optional
   */
  setSuccess: function setSuccess(message) {
    // Animate down
    if (!this._isMessageVisible()) {
      this._showMessage();
    }
    this.clearError();
    this.clearWarning();
    this.clearInfo();
    this.el.setAttribute('data-success', true);
    if (message) {
      this.setMessage(message);
    }
    return this;
  },
  /**
   * Set the success state.
   */
  clearSuccess: function clearSuccess() {
    this.el.removeAttribute('data-success', true);
    return this;
  },
  /**
   * Set the info state.
   * @param {String} message Optional
   */
  setInfo: function setInfo(message) {
    // Animate down
    if (!this._isMessageVisible()) {
      this._showMessage();
    }
    this.clearError();
    this.clearWarning();
    this.clearSuccess();
    this.el.setAttribute('data-info', true);
    if (message) {
      this.setMessage(message);
    }
    return this;
  },
  /**
   * Set the info state.
   */
  clearInfo: function clearInfo() {
    this.el.removeAttribute('data-info', true);
    return this;
  },
  /**
   * Clear all messages.
   */
  clearMessages: function clearMessages() {
    this._hideMessage(function () {
      this.clearError();
      this.clearWarning();
      this.clearSuccess();
      this.clearInfo();
    }.bind(this));
    return this;
  },
  /**
   * Set the message text.
   * @param {String} message
   */
  setMessage: function setMessage(message) {
    this.messageEl.innerHTML = message;
    return this;
  },
  /**
   * Show the message
   */
  _showMessage: function _showMessage() {
    if (!this.messageEl.parentNode) {
      this.el.appendChild(this.messageEl);
    }
    (0, _height.default)({
      el: this.el,
      toggleEl: this.messageEl
    });
  },
  /**
   * Hide the message.
   * @param {Function} callback
   */
  _hideMessage: function _hideMessage(callback) {
    (0, _height.default)({
      el: this.el,
      toggleEl: this.messageEl,
      toggleValue: 'none',
      action: 'collapse',
      onComplete: callback
    });
  },
  /**
   * Is the message currently visible?
   * @return {Boolean}
   */
  _isMessageVisible: function _isMessageVisible() {
    return this.el.getAttribute('data-error') || this.el.getAttribute('data-warning') || this.el.getAttribute('data-success');
  }
};
exports.default = _default;
module.exports = exports.default;


},{"../helpers/animation/height":52,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],105:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.default = void 0;
/**
 * # Validation Mixin
 * Add functionality for validating a form field's value.
 *
 * @example
 * mixin(Component, validation);
 *
 * @module mixin/validation.js
 */
var _default = {
  /**
   * Default validate function. This can be overridden by passing a
   * custom validate method as a parameter. This really only helps out
   * of the box for text inputs.
   */
  validate: function validate() {
    var validate = this.validatePattern;

    // Nothing to validate.
    if (!this.onValidate || !validate) {
      return this;
    }
    var re = new RegExp(validate);
    this.onValidate(re.test(this.getValue()), this.getValue(), this);
    return this;
  }
};
exports.default = _default;
module.exports = exports.default;


},{}],106:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");
exports.__esModule = true;
var _base = _interopRequireDefault(require("./components/base"));
exports.Base = _base.default;
var _calendarInline = _interopRequireDefault(require("./components/calendar-inline"));
exports.CalendarInline = _calendarInline.default;
var _calendarPopover = _interopRequireDefault(require("./components/calendar-popover"));
exports.CalendarPopover = _calendarPopover.default;
var _carousel = _interopRequireDefault(require("./components/carousel"));
exports.Carousel = _carousel.default;
var _dateInput = _interopRequireDefault(require("./components/date-input"));
exports.DateInput = _dateInput.default;
var _expand = _interopRequireDefault(require("./components/expand"));
exports.Expand = _expand.default;
var _header = _interopRequireDefault(require("./components/header"));
exports.Header = _header.default;
var _menu = _interopRequireDefault(require("./components/menu"));
exports.Menu = _menu.default;
var _modal = _interopRequireDefault(require("./components/modal"));
exports.Modal = _modal.default;
var _multiSelectInput = _interopRequireDefault(require("./components/multi-select-input"));
exports.MultiSelectInput = _multiSelectInput.default;
var _numberSelector = _interopRequireDefault(require("./components/number-selector"));
exports.NumberSelector = _numberSelector.default;
var _popover = _interopRequireDefault(require("./components/popover"));
exports.Popover = _popover.default;
var _progressIndicator = _interopRequireDefault(require("./components/progress-indicator"));
exports.ProgressIndicator = _progressIndicator.default;
var _rangeSlider = _interopRequireDefault(require("./components/range-slider"));
exports.RangeSlider = _rangeSlider.default;
var _selectInput = _interopRequireDefault(require("./components/select-input"));
exports.SelectInput = _selectInput.default;
var _slider = _interopRequireDefault(require("./components/slider"));
exports.Slider = _slider.default;
var _table = _interopRequireDefault(require("./components/table"));
exports.Table = _table.default;
var _tabs = _interopRequireDefault(require("./components/tabs"));
exports.Tabs = _tabs.default;
var _textInput = _interopRequireDefault(require("./components/text-input"));
exports.TextInput = _textInput.default;
var _timeInput = _interopRequireDefault(require("./components/time-input"));
exports.TimeInput = _timeInput.default;
var _timeRangeSlider = _interopRequireDefault(require("./components/time-range-slider"));
exports.TimeRangeSlider = _timeRangeSlider.default;
var _toggleSwitch = _interopRequireDefault(require("./components/toggle-switch"));
exports.ToggleSwitch = _toggleSwitch.default;
var _toolbar = _interopRequireDefault(require("./components/toolbar"));
exports.Toolbar = _toolbar.default;
var _tooltip = _interopRequireDefault(require("./components/tooltip"));
exports.Tooltip = _tooltip.default;
var _scrollToTop = _interopRequireDefault(require("./components/scroll-to-top"));
exports.ScrollToTop = _scrollToTop.default;
var _stepIndicator = _interopRequireDefault(require("./components/step-indicator"));
exports.StepIndicator = _stepIndicator.default;
var _filter = _interopRequireDefault(require("./components/filter"));
exports.Filter = _filter.default;
var _date = _interopRequireDefault(require("./helpers/date/date"));
exports.DateHelper = _date.default;
var _toast = _interopRequireDefault(require("./components/toast"));
exports.Toast = _toast.default;
var _autoSuggest = _interopRequireDefault(require("./components/auto-suggest"));
exports.AutoSuggest = _autoSuggest.default;
var _fixedPanel = _interopRequireDefault(require("./components/fixed-panel"));
exports.FixedPanel = _fixedPanel.default;
var _kpi = _interopRequireDefault(require("./components/kpi"));
exports.KPI = _kpi.default;
var _panelCarousel = _interopRequireDefault(require("./components/panel-carousel"));
exports.PanelCarousel = _panelCarousel.default;
var _payments = _interopRequireDefault(require("./components/payments"));
exports.Payments = _payments.default;
var _accordion = _interopRequireDefault(require("./components/accordion"));
exports.Accordion = _accordion.default;
var _button = _interopRequireDefault(require("./components/button"));
exports.Button = _button.default;
var _floatingActionButton = _interopRequireDefault(require("./components/floating-action-button"));
exports.FloatingActionButton = _floatingActionButton.default;
var _sideFixedPanel = _interopRequireDefault(require("./components/side-fixed-panel"));
exports.SideFixedPanel = _sideFixedPanel.default;
var _timeSet = _interopRequireDefault(require("./components/time-set"));
exports.TimeSet = _timeSet.default;


},{"./components/accordion":1,"./components/auto-suggest":2,"./components/base":3,"./components/button":4,"./components/calendar-inline":5,"./components/calendar-popover":6,"./components/carousel":7,"./components/date-input":8,"./components/expand":11,"./components/filter":13,"./components/fixed-panel":14,"./components/floating-action-button":15,"./components/header":16,"./components/kpi":17,"./components/menu":18,"./components/modal":19,"./components/multi-select-input":20,"./components/number-selector":21,"./components/panel-carousel":22,"./components/payments":23,"./components/popover":30,"./components/progress-indicator":31,"./components/range-slider":32,"./components/scroll-to-top":33,"./components/select-input":34,"./components/side-fixed-panel":36,"./components/slider":37,"./components/step-indicator":38,"./components/table":39,"./components/tabs":40,"./components/text-input":41,"./components/time-input":42,"./components/time-range-slider":43,"./components/time-set":44,"./components/toast":46,"./components/toggle-switch":47,"./components/toolbar":48,"./components/tooltip":49,"./helpers/date/date":57,"@babel/runtime-corejs3/helpers/interopRequireDefault":150}],107:[function(require,module,exports){
module.exports = require("core-js-pure/stable/array/from");
},{"core-js-pure/stable/array/from":490}],108:[function(require,module,exports){
module.exports = require("core-js-pure/stable/instance/concat");
},{"core-js-pure/stable/instance/concat":495}],109:[function(require,module,exports){
module.exports = require("core-js-pure/stable/instance/fill");
},{"core-js-pure/stable/instance/fill":496}],110:[function(require,module,exports){
module.exports = require("core-js-pure/stable/instance/filter");
},{"core-js-pure/stable/instance/filter":497}],111:[function(require,module,exports){
module.exports = require("core-js-pure/stable/instance/find-index");
},{"core-js-pure/stable/instance/find-index":498}],112:[function(require,module,exports){
module.exports = require("core-js-pure/stable/instance/includes");
},{"core-js-pure/stable/instance/includes":499}],113:[function(require,module,exports){
module.exports = require("core-js-pure/stable/instance/map");
},{"core-js-pure/stable/instance/map":500}],114:[function(require,module,exports){
module.exports = require("core-js-pure/stable/instance/pad-start");
},{"core-js-pure/stable/instance/pad-start":501}],115:[function(require,module,exports){
module.exports = require("core-js-pure/stable/instance/slice");
},{"core-js-pure/stable/instance/slice":502}],116:[function(require,module,exports){
module.exports = require("core-js-pure/stable/instance/sort");
},{"core-js-pure/stable/instance/sort":503}],117:[function(require,module,exports){
module.exports = require("core-js-pure/stable/instance/splice");
},{"core-js-pure/stable/instance/splice":504}],118:[function(require,module,exports){
module.exports = require("core-js-pure/stable/instance/starts-with");
},{"core-js-pure/stable/instance/starts-with":505}],119:[function(require,module,exports){
module.exports = require("core-js-pure/stable/instance/values");
},{"core-js-pure/stable/instance/values":506}],120:[function(require,module,exports){
module.exports = require("core-js-pure/stable/number/is-integer");
},{"core-js-pure/stable/number/is-integer":507}],121:[function(require,module,exports){
module.exports = require("core-js-pure/stable/number/parse-float");
},{"core-js-pure/stable/number/parse-float":508}],122:[function(require,module,exports){
module.exports = require("core-js-pure/stable/object/assign");
},{"core-js-pure/stable/object/assign":509}],123:[function(require,module,exports){
module.exports = require("core-js-pure/stable/object/keys");
},{"core-js-pure/stable/object/keys":514}],124:[function(require,module,exports){
module.exports = require("core-js-pure/stable/promise");
},{"core-js-pure/stable/promise":516}],125:[function(require,module,exports){
module.exports = require("core-js-pure/stable/reflect/construct");
},{"core-js-pure/stable/reflect/construct":517}],126:[function(require,module,exports){
module.exports = require("core-js-pure/features/array/from");
},{"core-js-pure/features/array/from":222}],127:[function(require,module,exports){
module.exports = require("core-js-pure/features/array/is-array");
},{"core-js-pure/features/array/is-array":223}],128:[function(require,module,exports){
module.exports = require("core-js-pure/features/get-iterator-method");
},{"core-js-pure/features/get-iterator-method":224}],129:[function(require,module,exports){
module.exports = require("core-js-pure/features/instance/bind");
},{"core-js-pure/features/instance/bind":225}],130:[function(require,module,exports){
module.exports = require("core-js-pure/features/instance/slice");
},{"core-js-pure/features/instance/slice":226}],131:[function(require,module,exports){
module.exports = require("core-js-pure/features/object/create");
},{"core-js-pure/features/object/create":227}],132:[function(require,module,exports){
module.exports = require("core-js-pure/features/object/define-property");
},{"core-js-pure/features/object/define-property":228}],133:[function(require,module,exports){
module.exports = require("core-js-pure/features/object/get-own-property-descriptor");
},{"core-js-pure/features/object/get-own-property-descriptor":229}],134:[function(require,module,exports){
module.exports = require("core-js-pure/features/object/get-prototype-of");
},{"core-js-pure/features/object/get-prototype-of":230}],135:[function(require,module,exports){
module.exports = require("core-js-pure/features/object/set-prototype-of");
},{"core-js-pure/features/object/set-prototype-of":231}],136:[function(require,module,exports){
module.exports = require("core-js-pure/features/reflect/get");
},{"core-js-pure/features/reflect/get":232}],137:[function(require,module,exports){
module.exports = require("core-js-pure/features/symbol");
},{"core-js-pure/features/symbol":233}],138:[function(require,module,exports){
module.exports = require("core-js-pure/features/symbol/iterator");
},{"core-js-pure/features/symbol/iterator":234}],139:[function(require,module,exports){
module.exports = require("core-js-pure/features/symbol/to-primitive");
},{"core-js-pure/features/symbol/to-primitive":235}],140:[function(require,module,exports){
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],141:[function(require,module,exports){
var _Array$isArray = require("@babel/runtime-corejs3/core-js/array/is-array");
function _arrayWithHoles(arr) {
  if (_Array$isArray(arr)) return arr;
}
module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"@babel/runtime-corejs3/core-js/array/is-array":127}],142:[function(require,module,exports){
var _Array$isArray = require("@babel/runtime-corejs3/core-js/array/is-array");
var arrayLikeToArray = require("./arrayLikeToArray.js");
function _arrayWithoutHoles(arr) {
  if (_Array$isArray(arr)) return arrayLikeToArray(arr);
}
module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./arrayLikeToArray.js":140,"@babel/runtime-corejs3/core-js/array/is-array":127}],143:[function(require,module,exports){
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],144:[function(require,module,exports){
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],145:[function(require,module,exports){
var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var toPropertyKey = require("./toPropertyKey.js");
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    _Object$defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  _Object$defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./toPropertyKey.js":161,"@babel/runtime-corejs3/core-js/object/define-property":132}],146:[function(require,module,exports){
var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var toPropertyKey = require("./toPropertyKey.js");
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    _Object$defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./toPropertyKey.js":161,"@babel/runtime-corejs3/core-js/object/define-property":132}],147:[function(require,module,exports){
var _Reflect$get = require("@babel/runtime-corejs3/core-js/reflect/get");
var _bindInstanceProperty = require("@babel/runtime-corejs3/core-js/instance/bind");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs3/core-js/object/get-own-property-descriptor");
var superPropBase = require("./superPropBase.js");
function _get() {
  if (typeof Reflect !== "undefined" && _Reflect$get) {
    var _context;
    module.exports = _get = _bindInstanceProperty(_context = _Reflect$get).call(_context), module.exports.__esModule = true, module.exports["default"] = module.exports;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = _Object$getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
  return _get.apply(this, arguments);
}
module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./superPropBase.js":158,"@babel/runtime-corejs3/core-js/instance/bind":129,"@babel/runtime-corejs3/core-js/object/get-own-property-descriptor":133,"@babel/runtime-corejs3/core-js/reflect/get":136}],148:[function(require,module,exports){
var _Object$setPrototypeOf = require("@babel/runtime-corejs3/core-js/object/set-prototype-of");
var _bindInstanceProperty = require("@babel/runtime-corejs3/core-js/instance/bind");
var _Object$getPrototypeOf = require("@babel/runtime-corejs3/core-js/object/get-prototype-of");
function _getPrototypeOf(o) {
  var _context;
  module.exports = _getPrototypeOf = _Object$setPrototypeOf ? _bindInstanceProperty(_context = _Object$getPrototypeOf).call(_context) : function _getPrototypeOf(o) {
    return o.__proto__ || _Object$getPrototypeOf(o);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _getPrototypeOf(o);
}
module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"@babel/runtime-corejs3/core-js/instance/bind":129,"@babel/runtime-corejs3/core-js/object/get-prototype-of":134,"@babel/runtime-corejs3/core-js/object/set-prototype-of":135}],149:[function(require,module,exports){
var _Object$create = require("@babel/runtime-corejs3/core-js/object/create");
var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var setPrototypeOf = require("./setPrototypeOf.js");
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = _Object$create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  _Object$defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}
module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./setPrototypeOf.js":156,"@babel/runtime-corejs3/core-js/object/create":131,"@babel/runtime-corejs3/core-js/object/define-property":132}],150:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],151:[function(require,module,exports){
var _Symbol = require("@babel/runtime-corejs3/core-js/symbol");
var _getIteratorMethod = require("@babel/runtime-corejs3/core-js/get-iterator-method");
var _Array$from = require("@babel/runtime-corejs3/core-js/array/from");
function _iterableToArray(iter) {
  if (typeof _Symbol !== "undefined" && _getIteratorMethod(iter) != null || iter["@@iterator"] != null) return _Array$from(iter);
}
module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"@babel/runtime-corejs3/core-js/array/from":126,"@babel/runtime-corejs3/core-js/get-iterator-method":128,"@babel/runtime-corejs3/core-js/symbol":137}],152:[function(require,module,exports){
var _Symbol = require("@babel/runtime-corejs3/core-js/symbol");
var _getIteratorMethod = require("@babel/runtime-corejs3/core-js/get-iterator-method");
function _iterableToArrayLimit(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof _Symbol && _getIteratorMethod(arr) || arr["@@iterator"];
  if (null != _i) {
    var _s,
      _e,
      _x,
      _r,
      _arr = [],
      _n = !0,
      _d = !1;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i) return;
        _n = !1;
      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return;
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"@babel/runtime-corejs3/core-js/get-iterator-method":128,"@babel/runtime-corejs3/core-js/symbol":137}],153:[function(require,module,exports){
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],154:[function(require,module,exports){
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{}],155:[function(require,module,exports){
var _typeof = require("./typeof.js")["default"];
var assertThisInitialized = require("./assertThisInitialized.js");
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return assertThisInitialized(self);
}
module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./assertThisInitialized.js":143,"./typeof.js":162}],156:[function(require,module,exports){
var _Object$setPrototypeOf = require("@babel/runtime-corejs3/core-js/object/set-prototype-of");
var _bindInstanceProperty = require("@babel/runtime-corejs3/core-js/instance/bind");
function _setPrototypeOf(o, p) {
  var _context;
  module.exports = _setPrototypeOf = _Object$setPrototypeOf ? _bindInstanceProperty(_context = _Object$setPrototypeOf).call(_context) : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _setPrototypeOf(o, p);
}
module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"@babel/runtime-corejs3/core-js/instance/bind":129,"@babel/runtime-corejs3/core-js/object/set-prototype-of":135}],157:[function(require,module,exports){
var arrayWithHoles = require("./arrayWithHoles.js");
var iterableToArrayLimit = require("./iterableToArrayLimit.js");
var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");
var nonIterableRest = require("./nonIterableRest.js");
function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}
module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./arrayWithHoles.js":141,"./iterableToArrayLimit.js":152,"./nonIterableRest.js":153,"./unsupportedIterableToArray.js":163}],158:[function(require,module,exports){
var getPrototypeOf = require("./getPrototypeOf.js");
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }
  return object;
}
module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./getPrototypeOf.js":148}],159:[function(require,module,exports){
var arrayWithoutHoles = require("./arrayWithoutHoles.js");
var iterableToArray = require("./iterableToArray.js");
var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");
var nonIterableSpread = require("./nonIterableSpread.js");
function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}
module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./arrayWithoutHoles.js":142,"./iterableToArray.js":151,"./nonIterableSpread.js":154,"./unsupportedIterableToArray.js":163}],160:[function(require,module,exports){
var _Symbol$toPrimitive = require("@babel/runtime-corejs3/core-js/symbol/to-primitive");
var _typeof = require("./typeof.js")["default"];
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[_Symbol$toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./typeof.js":162,"@babel/runtime-corejs3/core-js/symbol/to-primitive":139}],161:[function(require,module,exports){
var _typeof = require("./typeof.js")["default"];
var toPrimitive = require("./toPrimitive.js");
function _toPropertyKey(arg) {
  var key = toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./toPrimitive.js":160,"./typeof.js":162}],162:[function(require,module,exports){
var _Symbol = require("@babel/runtime-corejs3/core-js/symbol");
var _Symbol$iterator = require("@babel/runtime-corejs3/core-js/symbol/iterator");
function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof _Symbol && "symbol" == typeof _Symbol$iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof _Symbol && obj.constructor === _Symbol && obj !== _Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"@babel/runtime-corejs3/core-js/symbol":137,"@babel/runtime-corejs3/core-js/symbol/iterator":138}],163:[function(require,module,exports){
var _sliceInstanceProperty = require("@babel/runtime-corejs3/core-js/instance/slice");
var _Array$from = require("@babel/runtime-corejs3/core-js/array/from");
var arrayLikeToArray = require("./arrayLikeToArray.js");
function _unsupportedIterableToArray(o, minLen) {
  var _context;
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = _sliceInstanceProperty(_context = Object.prototype.toString.call(o)).call(_context, 8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return _Array$from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},{"./arrayLikeToArray.js":140,"@babel/runtime-corejs3/core-js/array/from":126,"@babel/runtime-corejs3/core-js/instance/slice":130}],164:[function(require,module,exports){
var parent = require('../../stable/array/from');

module.exports = parent;

},{"../../stable/array/from":490}],165:[function(require,module,exports){
var parent = require('../../stable/array/is-array');

module.exports = parent;

},{"../../stable/array/is-array":491}],166:[function(require,module,exports){
var parent = require('../stable/get-iterator-method');

module.exports = parent;

},{"../stable/get-iterator-method":493}],167:[function(require,module,exports){
var parent = require('../../stable/instance/bind');

module.exports = parent;

},{"../../stable/instance/bind":494}],168:[function(require,module,exports){
var parent = require('../../stable/instance/slice');

module.exports = parent;

},{"../../stable/instance/slice":502}],169:[function(require,module,exports){
var parent = require('../../stable/object/create');

module.exports = parent;

},{"../../stable/object/create":510}],170:[function(require,module,exports){
var parent = require('../../stable/object/define-property');

module.exports = parent;

},{"../../stable/object/define-property":511}],171:[function(require,module,exports){
var parent = require('../../stable/object/get-own-property-descriptor');

module.exports = parent;

},{"../../stable/object/get-own-property-descriptor":512}],172:[function(require,module,exports){
var parent = require('../../stable/object/get-prototype-of');

module.exports = parent;

},{"../../stable/object/get-prototype-of":513}],173:[function(require,module,exports){
var parent = require('../../stable/object/set-prototype-of');

module.exports = parent;

},{"../../stable/object/set-prototype-of":515}],174:[function(require,module,exports){
var parent = require('../../stable/reflect/get');

module.exports = parent;

},{"../../stable/reflect/get":518}],175:[function(require,module,exports){
var parent = require('../../stable/symbol');

require('../../modules/esnext.symbol.dispose');

module.exports = parent;

},{"../../modules/esnext.symbol.dispose":480,"../../stable/symbol":519}],176:[function(require,module,exports){
var parent = require('../../stable/symbol/iterator');

module.exports = parent;

},{"../../stable/symbol/iterator":520}],177:[function(require,module,exports){
var parent = require('../../stable/symbol/to-primitive');

module.exports = parent;

},{"../../stable/symbol/to-primitive":521}],178:[function(require,module,exports){
require('../../modules/es.string.iterator');
require('../../modules/es.array.from');
var path = require('../../internals/path');

module.exports = path.Array.from;

},{"../../internals/path":372,"../../modules/es.array.from":420,"../../modules/es.string.iterator":458}],179:[function(require,module,exports){
require('../../modules/es.array.is-array');
var path = require('../../internals/path');

module.exports = path.Array.isArray;

},{"../../internals/path":372,"../../modules/es.array.is-array":422}],180:[function(require,module,exports){
require('../../../modules/es.array.concat');
var entryVirtual = require('../../../internals/entry-virtual');

module.exports = entryVirtual('Array').concat;

},{"../../../internals/entry-virtual":299,"../../../modules/es.array.concat":416}],181:[function(require,module,exports){
require('../../../modules/es.array.fill');
var entryVirtual = require('../../../internals/entry-virtual');

module.exports = entryVirtual('Array').fill;

},{"../../../internals/entry-virtual":299,"../../../modules/es.array.fill":417}],182:[function(require,module,exports){
require('../../../modules/es.array.filter');
var entryVirtual = require('../../../internals/entry-virtual');

module.exports = entryVirtual('Array').filter;

},{"../../../internals/entry-virtual":299,"../../../modules/es.array.filter":418}],183:[function(require,module,exports){
require('../../../modules/es.array.find-index');
var entryVirtual = require('../../../internals/entry-virtual');

module.exports = entryVirtual('Array').findIndex;

},{"../../../internals/entry-virtual":299,"../../../modules/es.array.find-index":419}],184:[function(require,module,exports){
require('../../../modules/es.array.includes');
var entryVirtual = require('../../../internals/entry-virtual');

module.exports = entryVirtual('Array').includes;

},{"../../../internals/entry-virtual":299,"../../../modules/es.array.includes":421}],185:[function(require,module,exports){
require('../../../modules/es.array.map');
var entryVirtual = require('../../../internals/entry-virtual');

module.exports = entryVirtual('Array').map;

},{"../../../internals/entry-virtual":299,"../../../modules/es.array.map":424}],186:[function(require,module,exports){
require('../../../modules/es.array.slice');
var entryVirtual = require('../../../internals/entry-virtual');

module.exports = entryVirtual('Array').slice;

},{"../../../internals/entry-virtual":299,"../../../modules/es.array.slice":425}],187:[function(require,module,exports){
require('../../../modules/es.array.sort');
var entryVirtual = require('../../../internals/entry-virtual');

module.exports = entryVirtual('Array').sort;

},{"../../../internals/entry-virtual":299,"../../../modules/es.array.sort":426}],188:[function(require,module,exports){
require('../../../modules/es.array.splice');
var entryVirtual = require('../../../internals/entry-virtual');

module.exports = entryVirtual('Array').splice;

},{"../../../internals/entry-virtual":299,"../../../modules/es.array.splice":427}],189:[function(require,module,exports){
require('../../../modules/es.array.iterator');
require('../../../modules/es.object.to-string');
var entryVirtual = require('../../../internals/entry-virtual');

module.exports = entryVirtual('Array').values;

},{"../../../internals/entry-virtual":299,"../../../modules/es.array.iterator":423,"../../../modules/es.object.to-string":443}],190:[function(require,module,exports){
require('../../../modules/es.function.bind');
var entryVirtual = require('../../../internals/entry-virtual');

module.exports = entryVirtual('Function').bind;

},{"../../../internals/entry-virtual":299,"../../../modules/es.function.bind":429}],191:[function(require,module,exports){
require('../modules/es.array.iterator');
require('../modules/es.string.iterator');
var getIteratorMethod = require('../internals/get-iterator-method');

module.exports = getIteratorMethod;

},{"../internals/get-iterator-method":316,"../modules/es.array.iterator":423,"../modules/es.string.iterator":458}],192:[function(require,module,exports){
var isPrototypeOf = require('../../internals/object-is-prototype-of');
var method = require('../function/virtual/bind');

var FunctionPrototype = Function.prototype;

module.exports = function (it) {
  var own = it.bind;
  return it === FunctionPrototype || (isPrototypeOf(FunctionPrototype, it) && own === FunctionPrototype.bind) ? method : own;
};

},{"../../internals/object-is-prototype-of":364,"../function/virtual/bind":190}],193:[function(require,module,exports){
var isPrototypeOf = require('../../internals/object-is-prototype-of');
var method = require('../array/virtual/concat');

var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  var own = it.concat;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.concat) ? method : own;
};

},{"../../internals/object-is-prototype-of":364,"../array/virtual/concat":180}],194:[function(require,module,exports){
var isPrototypeOf = require('../../internals/object-is-prototype-of');
var method = require('../array/virtual/fill');

var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  var own = it.fill;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.fill) ? method : own;
};

},{"../../internals/object-is-prototype-of":364,"../array/virtual/fill":181}],195:[function(require,module,exports){
var isPrototypeOf = require('../../internals/object-is-prototype-of');
var method = require('../array/virtual/filter');

var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  var own = it.filter;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.filter) ? method : own;
};

},{"../../internals/object-is-prototype-of":364,"../array/virtual/filter":182}],196:[function(require,module,exports){
var isPrototypeOf = require('../../internals/object-is-prototype-of');
var method = require('../array/virtual/find-index');

var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  var own = it.findIndex;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.findIndex) ? method : own;
};

},{"../../internals/object-is-prototype-of":364,"../array/virtual/find-index":183}],197:[function(require,module,exports){
var isPrototypeOf = require('../../internals/object-is-prototype-of');
var arrayMethod = require('../array/virtual/includes');
var stringMethod = require('../string/virtual/includes');

var ArrayPrototype = Array.prototype;
var StringPrototype = String.prototype;

module.exports = function (it) {
  var own = it.includes;
  if (it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.includes)) return arrayMethod;
  if (typeof it == 'string' || it === StringPrototype || (isPrototypeOf(StringPrototype, it) && own === StringPrototype.includes)) {
    return stringMethod;
  } return own;
};

},{"../../internals/object-is-prototype-of":364,"../array/virtual/includes":184,"../string/virtual/includes":216}],198:[function(require,module,exports){
var isPrototypeOf = require('../../internals/object-is-prototype-of');
var method = require('../array/virtual/map');

var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  var own = it.map;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.map) ? method : own;
};

},{"../../internals/object-is-prototype-of":364,"../array/virtual/map":185}],199:[function(require,module,exports){
var isPrototypeOf = require('../../internals/object-is-prototype-of');
var method = require('../string/virtual/pad-start');

var StringPrototype = String.prototype;

module.exports = function (it) {
  var own = it.padStart;
  return typeof it == 'string' || it === StringPrototype
    || (isPrototypeOf(StringPrototype, it) && own === StringPrototype.padStart) ? method : own;
};

},{"../../internals/object-is-prototype-of":364,"../string/virtual/pad-start":217}],200:[function(require,module,exports){
var isPrototypeOf = require('../../internals/object-is-prototype-of');
var method = require('../array/virtual/slice');

var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  var own = it.slice;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.slice) ? method : own;
};

},{"../../internals/object-is-prototype-of":364,"../array/virtual/slice":186}],201:[function(require,module,exports){
var isPrototypeOf = require('../../internals/object-is-prototype-of');
var method = require('../array/virtual/sort');

var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  var own = it.sort;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.sort) ? method : own;
};

},{"../../internals/object-is-prototype-of":364,"../array/virtual/sort":187}],202:[function(require,module,exports){
var isPrototypeOf = require('../../internals/object-is-prototype-of');
var method = require('../array/virtual/splice');

var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  var own = it.splice;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.splice) ? method : own;
};

},{"../../internals/object-is-prototype-of":364,"../array/virtual/splice":188}],203:[function(require,module,exports){
var isPrototypeOf = require('../../internals/object-is-prototype-of');
var method = require('../string/virtual/starts-with');

var StringPrototype = String.prototype;

module.exports = function (it) {
  var own = it.startsWith;
  return typeof it == 'string' || it === StringPrototype
    || (isPrototypeOf(StringPrototype, it) && own === StringPrototype.startsWith) ? method : own;
};

},{"../../internals/object-is-prototype-of":364,"../string/virtual/starts-with":218}],204:[function(require,module,exports){
require('../../modules/es.number.is-integer');
var path = require('../../internals/path');

module.exports = path.Number.isInteger;

},{"../../internals/path":372,"../../modules/es.number.is-integer":433}],205:[function(require,module,exports){
require('../../modules/es.number.parse-float');
var path = require('../../internals/path');

module.exports = path.Number.parseFloat;

},{"../../internals/path":372,"../../modules/es.number.parse-float":434}],206:[function(require,module,exports){
require('../../modules/es.object.assign');
var path = require('../../internals/path');

module.exports = path.Object.assign;

},{"../../internals/path":372,"../../modules/es.object.assign":435}],207:[function(require,module,exports){
require('../../modules/es.object.create');
var path = require('../../internals/path');

var Object = path.Object;

module.exports = function create(P, D) {
  return Object.create(P, D);
};

},{"../../internals/path":372,"../../modules/es.object.create":436}],208:[function(require,module,exports){
require('../../modules/es.object.define-property');
var path = require('../../internals/path');

var Object = path.Object;

var defineProperty = module.exports = function defineProperty(it, key, desc) {
  return Object.defineProperty(it, key, desc);
};

if (Object.defineProperty.sham) defineProperty.sham = true;

},{"../../internals/path":372,"../../modules/es.object.define-property":437}],209:[function(require,module,exports){
require('../../modules/es.object.get-own-property-descriptor');
var path = require('../../internals/path');

var Object = path.Object;

var getOwnPropertyDescriptor = module.exports = function getOwnPropertyDescriptor(it, key) {
  return Object.getOwnPropertyDescriptor(it, key);
};

if (Object.getOwnPropertyDescriptor.sham) getOwnPropertyDescriptor.sham = true;

},{"../../internals/path":372,"../../modules/es.object.get-own-property-descriptor":438}],210:[function(require,module,exports){
require('../../modules/es.object.get-prototype-of');
var path = require('../../internals/path');

module.exports = path.Object.getPrototypeOf;

},{"../../internals/path":372,"../../modules/es.object.get-prototype-of":440}],211:[function(require,module,exports){
require('../../modules/es.object.keys');
var path = require('../../internals/path');

module.exports = path.Object.keys;

},{"../../internals/path":372,"../../modules/es.object.keys":441}],212:[function(require,module,exports){
require('../../modules/es.object.set-prototype-of');
var path = require('../../internals/path');

module.exports = path.Object.setPrototypeOf;

},{"../../internals/path":372,"../../modules/es.object.set-prototype-of":442}],213:[function(require,module,exports){
require('../../modules/es.aggregate-error');
require('../../modules/es.array.iterator');
require('../../modules/es.object.to-string');
require('../../modules/es.promise');
require('../../modules/es.promise.all-settled');
require('../../modules/es.promise.any');
require('../../modules/es.promise.finally');
require('../../modules/es.string.iterator');
var path = require('../../internals/path');

module.exports = path.Promise;

},{"../../internals/path":372,"../../modules/es.aggregate-error":415,"../../modules/es.array.iterator":423,"../../modules/es.object.to-string":443,"../../modules/es.promise":450,"../../modules/es.promise.all-settled":444,"../../modules/es.promise.any":446,"../../modules/es.promise.finally":449,"../../modules/es.string.iterator":458}],214:[function(require,module,exports){
require('../../modules/es.reflect.construct');
var path = require('../../internals/path');

module.exports = path.Reflect.construct;

},{"../../internals/path":372,"../../modules/es.reflect.construct":454}],215:[function(require,module,exports){
require('../../modules/es.reflect.get');
var path = require('../../internals/path');

module.exports = path.Reflect.get;

},{"../../internals/path":372,"../../modules/es.reflect.get":455}],216:[function(require,module,exports){
require('../../../modules/es.string.includes');
var entryVirtual = require('../../../internals/entry-virtual');

module.exports = entryVirtual('String').includes;

},{"../../../internals/entry-virtual":299,"../../../modules/es.string.includes":457}],217:[function(require,module,exports){
require('../../../modules/es.string.pad-start');
var entryVirtual = require('../../../internals/entry-virtual');

module.exports = entryVirtual('String').padStart;

},{"../../../internals/entry-virtual":299,"../../../modules/es.string.pad-start":459}],218:[function(require,module,exports){
require('../../../modules/es.string.starts-with');
var entryVirtual = require('../../../internals/entry-virtual');

module.exports = entryVirtual('String').startsWith;

},{"../../../internals/entry-virtual":299,"../../../modules/es.string.starts-with":460}],219:[function(require,module,exports){
require('../../modules/es.array.concat');
require('../../modules/es.object.to-string');
require('../../modules/es.symbol');
require('../../modules/es.symbol.async-iterator');
require('../../modules/es.symbol.description');
require('../../modules/es.symbol.has-instance');
require('../../modules/es.symbol.is-concat-spreadable');
require('../../modules/es.symbol.iterator');
require('../../modules/es.symbol.match');
require('../../modules/es.symbol.match-all');
require('../../modules/es.symbol.replace');
require('../../modules/es.symbol.search');
require('../../modules/es.symbol.species');
require('../../modules/es.symbol.split');
require('../../modules/es.symbol.to-primitive');
require('../../modules/es.symbol.to-string-tag');
require('../../modules/es.symbol.unscopables');
require('../../modules/es.json.to-string-tag');
require('../../modules/es.math.to-string-tag');
require('../../modules/es.reflect.to-string-tag');
var path = require('../../internals/path');

module.exports = path.Symbol;

},{"../../internals/path":372,"../../modules/es.array.concat":416,"../../modules/es.json.to-string-tag":431,"../../modules/es.math.to-string-tag":432,"../../modules/es.object.to-string":443,"../../modules/es.reflect.to-string-tag":456,"../../modules/es.symbol":468,"../../modules/es.symbol.async-iterator":461,"../../modules/es.symbol.description":463,"../../modules/es.symbol.has-instance":465,"../../modules/es.symbol.is-concat-spreadable":466,"../../modules/es.symbol.iterator":467,"../../modules/es.symbol.match":471,"../../modules/es.symbol.match-all":470,"../../modules/es.symbol.replace":472,"../../modules/es.symbol.search":473,"../../modules/es.symbol.species":474,"../../modules/es.symbol.split":475,"../../modules/es.symbol.to-primitive":476,"../../modules/es.symbol.to-string-tag":477,"../../modules/es.symbol.unscopables":478}],220:[function(require,module,exports){
require('../../modules/es.array.iterator');
require('../../modules/es.object.to-string');
require('../../modules/es.string.iterator');
require('../../modules/es.symbol.iterator');
var WrappedWellKnownSymbolModule = require('../../internals/well-known-symbol-wrapped');

module.exports = WrappedWellKnownSymbolModule.f('iterator');

},{"../../internals/well-known-symbol-wrapped":411,"../../modules/es.array.iterator":423,"../../modules/es.object.to-string":443,"../../modules/es.string.iterator":458,"../../modules/es.symbol.iterator":467}],221:[function(require,module,exports){
require('../../modules/es.date.to-primitive');
require('../../modules/es.symbol.to-primitive');
var WrappedWellKnownSymbolModule = require('../../internals/well-known-symbol-wrapped');

module.exports = WrappedWellKnownSymbolModule.f('toPrimitive');

},{"../../internals/well-known-symbol-wrapped":411,"../../modules/es.date.to-primitive":428,"../../modules/es.symbol.to-primitive":476}],222:[function(require,module,exports){
module.exports = require('../../full/array/from');

},{"../../full/array/from":236}],223:[function(require,module,exports){
module.exports = require('../../full/array/is-array');

},{"../../full/array/is-array":237}],224:[function(require,module,exports){
module.exports = require('../full/get-iterator-method');

},{"../full/get-iterator-method":238}],225:[function(require,module,exports){
module.exports = require('../../full/instance/bind');

},{"../../full/instance/bind":239}],226:[function(require,module,exports){
module.exports = require('../../full/instance/slice');

},{"../../full/instance/slice":240}],227:[function(require,module,exports){
module.exports = require('../../full/object/create');

},{"../../full/object/create":241}],228:[function(require,module,exports){
module.exports = require('../../full/object/define-property');

},{"../../full/object/define-property":242}],229:[function(require,module,exports){
module.exports = require('../../full/object/get-own-property-descriptor');

},{"../../full/object/get-own-property-descriptor":243}],230:[function(require,module,exports){
module.exports = require('../../full/object/get-prototype-of');

},{"../../full/object/get-prototype-of":244}],231:[function(require,module,exports){
module.exports = require('../../full/object/set-prototype-of');

},{"../../full/object/set-prototype-of":245}],232:[function(require,module,exports){
module.exports = require('../../full/reflect/get');

},{"../../full/reflect/get":246}],233:[function(require,module,exports){
module.exports = require('../../full/symbol');

},{"../../full/symbol":247}],234:[function(require,module,exports){
module.exports = require('../../full/symbol/iterator');

},{"../../full/symbol/iterator":248}],235:[function(require,module,exports){
module.exports = require('../../full/symbol/to-primitive');

},{"../../full/symbol/to-primitive":249}],236:[function(require,module,exports){
var parent = require('../../actual/array/from');

module.exports = parent;

},{"../../actual/array/from":164}],237:[function(require,module,exports){
var parent = require('../../actual/array/is-array');

module.exports = parent;

},{"../../actual/array/is-array":165}],238:[function(require,module,exports){
var parent = require('../actual/get-iterator-method');

module.exports = parent;

},{"../actual/get-iterator-method":166}],239:[function(require,module,exports){
var parent = require('../../actual/instance/bind');

module.exports = parent;

},{"../../actual/instance/bind":167}],240:[function(require,module,exports){
var parent = require('../../actual/instance/slice');

module.exports = parent;

},{"../../actual/instance/slice":168}],241:[function(require,module,exports){
var parent = require('../../actual/object/create');

module.exports = parent;

},{"../../actual/object/create":169}],242:[function(require,module,exports){
var parent = require('../../actual/object/define-property');

module.exports = parent;

},{"../../actual/object/define-property":170}],243:[function(require,module,exports){
var parent = require('../../actual/object/get-own-property-descriptor');

module.exports = parent;

},{"../../actual/object/get-own-property-descriptor":171}],244:[function(require,module,exports){
var parent = require('../../actual/object/get-prototype-of');

module.exports = parent;

},{"../../actual/object/get-prototype-of":172}],245:[function(require,module,exports){
var parent = require('../../actual/object/set-prototype-of');

module.exports = parent;

},{"../../actual/object/set-prototype-of":173}],246:[function(require,module,exports){
var parent = require('../../actual/reflect/get');

module.exports = parent;

},{"../../actual/reflect/get":174}],247:[function(require,module,exports){
var parent = require('../../actual/symbol');
require('../../modules/esnext.symbol.async-dispose');
require('../../modules/esnext.symbol.is-registered');
require('../../modules/esnext.symbol.is-well-known');
require('../../modules/esnext.symbol.matcher');
require('../../modules/esnext.symbol.metadata-key');
require('../../modules/esnext.symbol.observable');
// TODO: Remove from `core-js@4`
require('../../modules/esnext.symbol.metadata');
require('../../modules/esnext.symbol.pattern-match');
require('../../modules/esnext.symbol.replace-all');

module.exports = parent;

},{"../../actual/symbol":175,"../../modules/esnext.symbol.async-dispose":479,"../../modules/esnext.symbol.is-registered":481,"../../modules/esnext.symbol.is-well-known":482,"../../modules/esnext.symbol.matcher":483,"../../modules/esnext.symbol.metadata":485,"../../modules/esnext.symbol.metadata-key":484,"../../modules/esnext.symbol.observable":486,"../../modules/esnext.symbol.pattern-match":487,"../../modules/esnext.symbol.replace-all":488}],248:[function(require,module,exports){
var parent = require('../../actual/symbol/iterator');

module.exports = parent;

},{"../../actual/symbol/iterator":176}],249:[function(require,module,exports){
var parent = require('../../actual/symbol/to-primitive');

module.exports = parent;

},{"../../actual/symbol/to-primitive":177}],250:[function(require,module,exports){
var isCallable = require('../internals/is-callable');
var tryToString = require('../internals/try-to-string');

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a function');
};

},{"../internals/is-callable":332,"../internals/try-to-string":404}],251:[function(require,module,exports){
var isConstructor = require('../internals/is-constructor');
var tryToString = require('../internals/try-to-string');

var $TypeError = TypeError;

// `Assert: IsConstructor(argument) is true`
module.exports = function (argument) {
  if (isConstructor(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a constructor');
};

},{"../internals/is-constructor":333,"../internals/try-to-string":404}],252:[function(require,module,exports){
var isCallable = require('../internals/is-callable');

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (typeof argument == 'object' || isCallable(argument)) return argument;
  throw $TypeError("Can't set " + $String(argument) + ' as a prototype');
};

},{"../internals/is-callable":332}],253:[function(require,module,exports){
module.exports = function () { /* empty */ };

},{}],254:[function(require,module,exports){
var isPrototypeOf = require('../internals/object-is-prototype-of');

var $TypeError = TypeError;

module.exports = function (it, Prototype) {
  if (isPrototypeOf(Prototype, it)) return it;
  throw $TypeError('Incorrect invocation');
};

},{"../internals/object-is-prototype-of":364}],255:[function(require,module,exports){
var isObject = require('../internals/is-object');

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw $TypeError($String(argument) + ' is not an object');
};

},{"../internals/is-object":338}],256:[function(require,module,exports){
'use strict';
var toObject = require('../internals/to-object');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var lengthOfArrayLike = require('../internals/length-of-array-like');

// `Array.prototype.fill` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = lengthOfArrayLike(O);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"../internals/length-of-array-like":348,"../internals/to-absolute-index":395,"../internals/to-object":399}],257:[function(require,module,exports){
'use strict';
var bind = require('../internals/function-bind-context');
var call = require('../internals/function-call');
var toObject = require('../internals/to-object');
var callWithSafeIterationClosing = require('../internals/call-with-safe-iteration-closing');
var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
var isConstructor = require('../internals/is-constructor');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var createProperty = require('../internals/create-property');
var getIterator = require('../internals/get-iterator');
var getIteratorMethod = require('../internals/get-iterator-method');

var $Array = Array;

// `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var IS_CONSTRUCTOR = isConstructor(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = getIterator(O, iteratorMethod);
    next = iterator.next;
    result = IS_CONSTRUCTOR ? new this() : [];
    for (;!(step = call(next, iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = lengthOfArrayLike(O);
    result = IS_CONSTRUCTOR ? new this(length) : $Array(length);
    for (;length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};

},{"../internals/call-with-safe-iteration-closing":268,"../internals/create-property":278,"../internals/function-bind-context":307,"../internals/function-call":310,"../internals/get-iterator":317,"../internals/get-iterator-method":316,"../internals/is-array-iterator-method":330,"../internals/is-constructor":333,"../internals/length-of-array-like":348,"../internals/to-object":399}],258:[function(require,module,exports){
var toIndexedObject = require('../internals/to-indexed-object');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var lengthOfArrayLike = require('../internals/length-of-array-like');

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};

},{"../internals/length-of-array-like":348,"../internals/to-absolute-index":395,"../internals/to-indexed-object":396}],259:[function(require,module,exports){
var bind = require('../internals/function-bind-context');
var uncurryThis = require('../internals/function-uncurry-this');
var IndexedObject = require('../internals/indexed-object');
var toObject = require('../internals/to-object');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var arraySpeciesCreate = require('../internals/array-species-create');

var push = uncurryThis([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that);
    var length = lengthOfArrayLike(self);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push(target, value);      // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push(target, value);      // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod(7)
};

},{"../internals/array-species-create":267,"../internals/function-bind-context":307,"../internals/function-uncurry-this":314,"../internals/indexed-object":326,"../internals/length-of-array-like":348,"../internals/to-object":399}],260:[function(require,module,exports){
var fails = require('../internals/fails');
var wellKnownSymbol = require('../internals/well-known-symbol');
var V8_VERSION = require('../internals/engine-v8-version');

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};

},{"../internals/engine-v8-version":297,"../internals/fails":305,"../internals/well-known-symbol":412}],261:[function(require,module,exports){
'use strict';
var fails = require('../internals/fails');

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call -- required for testing
    method.call(null, argument || function () { return 1; }, 1);
  });
};

},{"../internals/fails":305}],262:[function(require,module,exports){
'use strict';
var DESCRIPTORS = require('../internals/descriptors');
var isArray = require('../internals/is-array');

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Safari < 13 does not throw an error in this case
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {
  // makes no sense without proper strict mode support
  if (this !== undefined) return true;
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).length = 1;
  } catch (error) {
    return error instanceof TypeError;
  }
}();

module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {
  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {
    throw $TypeError('Cannot set read only .length');
  } return O.length = length;
} : function (O, length) {
  return O.length = length;
};

},{"../internals/descriptors":283,"../internals/is-array":331}],263:[function(require,module,exports){
var toAbsoluteIndex = require('../internals/to-absolute-index');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var createProperty = require('../internals/create-property');

var $Array = Array;
var max = Math.max;

module.exports = function (O, start, end) {
  var length = lengthOfArrayLike(O);
  var k = toAbsoluteIndex(start, length);
  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
  var result = $Array(max(fin - k, 0));
  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
  result.length = n;
  return result;
};

},{"../internals/create-property":278,"../internals/length-of-array-like":348,"../internals/to-absolute-index":395}],264:[function(require,module,exports){
var uncurryThis = require('../internals/function-uncurry-this');

module.exports = uncurryThis([].slice);

},{"../internals/function-uncurry-this":314}],265:[function(require,module,exports){
var arraySlice = require('../internals/array-slice-simple');

var floor = Math.floor;

var mergeSort = function (array, comparefn) {
  var length = array.length;
  var middle = floor(length / 2);
  return length < 8 ? insertionSort(array, comparefn) : merge(
    array,
    mergeSort(arraySlice(array, 0, middle), comparefn),
    mergeSort(arraySlice(array, middle), comparefn),
    comparefn
  );
};

var insertionSort = function (array, comparefn) {
  var length = array.length;
  var i = 1;
  var element, j;

  while (i < length) {
    j = i;
    element = array[i];
    while (j && comparefn(array[j - 1], element) > 0) {
      array[j] = array[--j];
    }
    if (j !== i++) array[j] = element;
  } return array;
};

var merge = function (array, left, right, comparefn) {
  var llength = left.length;
  var rlength = right.length;
  var lindex = 0;
  var rindex = 0;

  while (lindex < llength || rindex < rlength) {
    array[lindex + rindex] = (lindex < llength && rindex < rlength)
      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]
      : lindex < llength ? left[lindex++] : right[rindex++];
  } return array;
};

module.exports = mergeSort;

},{"../internals/array-slice-simple":263}],266:[function(require,module,exports){
var isArray = require('../internals/is-array');
var isConstructor = require('../internals/is-constructor');
var isObject = require('../internals/is-object');
var wellKnownSymbol = require('../internals/well-known-symbol');

var SPECIES = wellKnownSymbol('species');
var $Array = Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? $Array : C;
};

},{"../internals/is-array":331,"../internals/is-constructor":333,"../internals/is-object":338,"../internals/well-known-symbol":412}],267:[function(require,module,exports){
var arraySpeciesConstructor = require('../internals/array-species-constructor');

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};

},{"../internals/array-species-constructor":266}],268:[function(require,module,exports){
var anObject = require('../internals/an-object');
var iteratorClose = require('../internals/iterator-close');

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose(iterator, 'throw', error);
  }
};

},{"../internals/an-object":255,"../internals/iterator-close":343}],269:[function(require,module,exports){
var wellKnownSymbol = require('../internals/well-known-symbol');

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};

},{"../internals/well-known-symbol":412}],270:[function(require,module,exports){
var uncurryThis = require('../internals/function-uncurry-this');

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};

},{"../internals/function-uncurry-this":314}],271:[function(require,module,exports){
var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
var isCallable = require('../internals/is-callable');
var classofRaw = require('../internals/classof-raw');
var wellKnownSymbol = require('../internals/well-known-symbol');

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};

},{"../internals/classof-raw":270,"../internals/is-callable":332,"../internals/to-string-tag-support":402,"../internals/well-known-symbol":412}],272:[function(require,module,exports){
var hasOwn = require('../internals/has-own-property');
var ownKeys = require('../internals/own-keys');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var definePropertyModule = require('../internals/object-define-property');

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};

},{"../internals/has-own-property":321,"../internals/object-define-property":358,"../internals/object-get-own-property-descriptor":359,"../internals/own-keys":371}],273:[function(require,module,exports){
var wellKnownSymbol = require('../internals/well-known-symbol');

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) { /* empty */ }
  } return false;
};

},{"../internals/well-known-symbol":412}],274:[function(require,module,exports){
var fails = require('../internals/fails');

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});

},{"../internals/fails":305}],275:[function(require,module,exports){
// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
module.exports = function (value, done) {
  return { value: value, done: done };
};

},{}],276:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var definePropertyModule = require('../internals/object-define-property');
var createPropertyDescriptor = require('../internals/create-property-descriptor');

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"../internals/create-property-descriptor":277,"../internals/descriptors":283,"../internals/object-define-property":358}],277:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],278:[function(require,module,exports){
'use strict';
var toPropertyKey = require('../internals/to-property-key');
var definePropertyModule = require('../internals/object-define-property');
var createPropertyDescriptor = require('../internals/create-property-descriptor');

module.exports = function (object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};

},{"../internals/create-property-descriptor":277,"../internals/object-define-property":358,"../internals/to-property-key":401}],279:[function(require,module,exports){
var defineProperty = require('../internals/object-define-property');

module.exports = function (target, name, descriptor) {
  return defineProperty.f(target, name, descriptor);
};

},{"../internals/object-define-property":358}],280:[function(require,module,exports){
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');

module.exports = function (target, key, value, options) {
  if (options && options.enumerable) target[key] = value;
  else createNonEnumerableProperty(target, key, value);
  return target;
};

},{"../internals/create-non-enumerable-property":276}],281:[function(require,module,exports){
var global = require('../internals/global');

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};

},{"../internals/global":320}],282:[function(require,module,exports){
'use strict';
var tryToString = require('../internals/try-to-string');

var $TypeError = TypeError;

module.exports = function (O, P) {
  if (!delete O[P]) throw $TypeError('Cannot delete property ' + tryToString(P) + ' of ' + tryToString(O));
};

},{"../internals/try-to-string":404}],283:[function(require,module,exports){
var fails = require('../internals/fails');

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});

},{"../internals/fails":305}],284:[function(require,module,exports){
var documentAll = typeof document == 'object' && document.all;

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
var IS_HTMLDDA = typeof documentAll == 'undefined' && documentAll !== undefined;

module.exports = {
  all: documentAll,
  IS_HTMLDDA: IS_HTMLDDA
};

},{}],285:[function(require,module,exports){
var global = require('../internals/global');
var isObject = require('../internals/is-object');

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};

},{"../internals/global":320,"../internals/is-object":338}],286:[function(require,module,exports){
var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};

},{}],287:[function(require,module,exports){
// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};

},{}],288:[function(require,module,exports){
var userAgent = require('../internals/engine-user-agent');

var firefox = userAgent.match(/firefox\/(\d+)/i);

module.exports = !!firefox && +firefox[1];

},{"../internals/engine-user-agent":296}],289:[function(require,module,exports){
var IS_DENO = require('../internals/engine-is-deno');
var IS_NODE = require('../internals/engine-is-node');

module.exports = !IS_DENO && !IS_NODE
  && typeof window == 'object'
  && typeof document == 'object';

},{"../internals/engine-is-deno":290,"../internals/engine-is-node":294}],290:[function(require,module,exports){
/* global Deno -- Deno case */
module.exports = typeof Deno == 'object' && Deno && typeof Deno.version == 'object';

},{}],291:[function(require,module,exports){
var UA = require('../internals/engine-user-agent');

module.exports = /MSIE|Trident/.test(UA);

},{"../internals/engine-user-agent":296}],292:[function(require,module,exports){
var userAgent = require('../internals/engine-user-agent');

module.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != 'undefined';

},{"../internals/engine-user-agent":296}],293:[function(require,module,exports){
var userAgent = require('../internals/engine-user-agent');

// eslint-disable-next-line redos/no-vulnerable -- safe
module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);

},{"../internals/engine-user-agent":296}],294:[function(require,module,exports){
(function (process){(function (){
var classof = require('../internals/classof-raw');

module.exports = typeof process != 'undefined' && classof(process) == 'process';

}).call(this)}).call(this,require('_process'))
},{"../internals/classof-raw":270,"_process":522}],295:[function(require,module,exports){
var userAgent = require('../internals/engine-user-agent');

module.exports = /web0s(?!.*chrome)/i.test(userAgent);

},{"../internals/engine-user-agent":296}],296:[function(require,module,exports){
module.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';

},{}],297:[function(require,module,exports){
var global = require('../internals/global');
var userAgent = require('../internals/engine-user-agent');

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;

},{"../internals/engine-user-agent":296,"../internals/global":320}],298:[function(require,module,exports){
var userAgent = require('../internals/engine-user-agent');

var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);

module.exports = !!webkit && +webkit[1];

},{"../internals/engine-user-agent":296}],299:[function(require,module,exports){
var path = require('../internals/path');

module.exports = function (CONSTRUCTOR) {
  return path[CONSTRUCTOR + 'Prototype'];
};

},{"../internals/path":372}],300:[function(require,module,exports){
// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];

},{}],301:[function(require,module,exports){
var uncurryThis = require('../internals/function-uncurry-this');

var $Error = Error;
var replace = uncurryThis(''.replace);

var TEST = (function (arg) { return String($Error(arg).stack); })('zxcasd');
// eslint-disable-next-line redos/no-vulnerable -- safe
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);

module.exports = function (stack, dropEntries) {
  if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string' && !$Error.prepareStackTrace) {
    while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
  } return stack;
};

},{"../internals/function-uncurry-this":314}],302:[function(require,module,exports){
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var clearErrorStack = require('../internals/error-stack-clear');
var ERROR_STACK_INSTALLABLE = require('../internals/error-stack-installable');

// non-standard V8
var captureStackTrace = Error.captureStackTrace;

module.exports = function (error, C, stack, dropEntries) {
  if (ERROR_STACK_INSTALLABLE) {
    if (captureStackTrace) captureStackTrace(error, C);
    else createNonEnumerableProperty(error, 'stack', clearErrorStack(stack, dropEntries));
  }
};

},{"../internals/create-non-enumerable-property":276,"../internals/error-stack-clear":301,"../internals/error-stack-installable":303}],303:[function(require,module,exports){
var fails = require('../internals/fails');
var createPropertyDescriptor = require('../internals/create-property-descriptor');

module.exports = !fails(function () {
  var error = Error('a');
  if (!('stack' in error)) return true;
  // eslint-disable-next-line es/no-object-defineproperty -- safe
  Object.defineProperty(error, 'stack', createPropertyDescriptor(1, 7));
  return error.stack !== 7;
});

},{"../internals/create-property-descriptor":277,"../internals/fails":305}],304:[function(require,module,exports){
'use strict';
var global = require('../internals/global');
var apply = require('../internals/function-apply');
var uncurryThis = require('../internals/function-uncurry-this-clause');
var isCallable = require('../internals/is-callable');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var isForced = require('../internals/is-forced');
var path = require('../internals/path');
var bind = require('../internals/function-bind-context');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var hasOwn = require('../internals/has-own-property');

var wrapConstructor = function (NativeConstructor) {
  var Wrapper = function (a, b, c) {
    if (this instanceof Wrapper) {
      switch (arguments.length) {
        case 0: return new NativeConstructor();
        case 1: return new NativeConstructor(a);
        case 2: return new NativeConstructor(a, b);
      } return new NativeConstructor(a, b, c);
    } return apply(NativeConstructor, this, arguments);
  };
  Wrapper.prototype = NativeConstructor.prototype;
  return Wrapper;
};

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var PROTO = options.proto;

  var nativeSource = GLOBAL ? global : STATIC ? global[TARGET] : (global[TARGET] || {}).prototype;

  var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];
  var targetPrototype = target.prototype;

  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

  for (key in source) {
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contains in native
    USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);

    targetProperty = target[key];

    if (USE_NATIVE) if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(nativeSource, key);
      nativeProperty = descriptor && descriptor.value;
    } else nativeProperty = nativeSource[key];

    // export native or implementation
    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];

    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty) continue;

    // bind methods to global for calling from export context
    if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, global);
    // wrap global constructors for prevent changes in this version
    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
    // make static versions for prototype methods
    else if (PROTO && isCallable(sourceProperty)) resultProperty = uncurryThis(sourceProperty);
    // default case
    else resultProperty = sourceProperty;

    // add a flag to not completely full polyfills
    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(resultProperty, 'sham', true);
    }

    createNonEnumerableProperty(target, key, resultProperty);

    if (PROTO) {
      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';
      if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {
        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});
      }
      // export virtual prototype methods
      createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty);
      // export real prototype methods
      if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) {
        createNonEnumerableProperty(targetPrototype, key, sourceProperty);
      }
    }
  }
};

},{"../internals/create-non-enumerable-property":276,"../internals/function-apply":306,"../internals/function-bind-context":307,"../internals/function-uncurry-this-clause":313,"../internals/global":320,"../internals/has-own-property":321,"../internals/is-callable":332,"../internals/is-forced":335,"../internals/object-get-own-property-descriptor":359,"../internals/path":372}],305:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

},{}],306:[function(require,module,exports){
var NATIVE_BIND = require('../internals/function-bind-native');

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});

},{"../internals/function-bind-native":308}],307:[function(require,module,exports){
var uncurryThis = require('../internals/function-uncurry-this-clause');
var aCallable = require('../internals/a-callable');
var NATIVE_BIND = require('../internals/function-bind-native');

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"../internals/a-callable":250,"../internals/function-bind-native":308,"../internals/function-uncurry-this-clause":313}],308:[function(require,module,exports){
var fails = require('../internals/fails');

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});

},{"../internals/fails":305}],309:[function(require,module,exports){
'use strict';
var uncurryThis = require('../internals/function-uncurry-this');
var aCallable = require('../internals/a-callable');
var isObject = require('../internals/is-object');
var hasOwn = require('../internals/has-own-property');
var arraySlice = require('../internals/array-slice');
var NATIVE_BIND = require('../internals/function-bind-native');

var $Function = Function;
var concat = uncurryThis([].concat);
var join = uncurryThis([].join);
var factories = {};

var construct = function (C, argsLength, args) {
  if (!hasOwn(factories, argsLength)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
    factories[argsLength] = $Function('C,a', 'return new C(' + join(list, ',') + ')');
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind
// eslint-disable-next-line es/no-function-prototype-bind -- detection
module.exports = NATIVE_BIND ? $Function.bind : function bind(that /* , ...args */) {
  var F = aCallable(this);
  var Prototype = F.prototype;
  var partArgs = arraySlice(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = concat(partArgs, arraySlice(arguments));
    return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
  };
  if (isObject(Prototype)) boundFunction.prototype = Prototype;
  return boundFunction;
};

},{"../internals/a-callable":250,"../internals/array-slice":264,"../internals/function-bind-native":308,"../internals/function-uncurry-this":314,"../internals/has-own-property":321,"../internals/is-object":338}],310:[function(require,module,exports){
var NATIVE_BIND = require('../internals/function-bind-native');

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};

},{"../internals/function-bind-native":308}],311:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var hasOwn = require('../internals/has-own-property');

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};

},{"../internals/descriptors":283,"../internals/has-own-property":321}],312:[function(require,module,exports){
var uncurryThis = require('../internals/function-uncurry-this');
var aCallable = require('../internals/a-callable');

module.exports = function (object, key, method) {
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) { /* empty */ }
};

},{"../internals/a-callable":250,"../internals/function-uncurry-this":314}],313:[function(require,module,exports){
var classofRaw = require('../internals/classof-raw');
var uncurryThis = require('../internals/function-uncurry-this');

module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};

},{"../internals/classof-raw":270,"../internals/function-uncurry-this":314}],314:[function(require,module,exports){
var NATIVE_BIND = require('../internals/function-bind-native');

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};

},{"../internals/function-bind-native":308}],315:[function(require,module,exports){
var path = require('../internals/path');
var global = require('../internals/global');
var isCallable = require('../internals/is-callable');

var aFunction = function (variable) {
  return isCallable(variable) ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};

},{"../internals/global":320,"../internals/is-callable":332,"../internals/path":372}],316:[function(require,module,exports){
var classof = require('../internals/classof');
var getMethod = require('../internals/get-method');
var isNullOrUndefined = require('../internals/is-null-or-undefined');
var Iterators = require('../internals/iterators');
var wellKnownSymbol = require('../internals/well-known-symbol');

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR)
    || getMethod(it, '@@iterator')
    || Iterators[classof(it)];
};

},{"../internals/classof":271,"../internals/get-method":319,"../internals/is-null-or-undefined":337,"../internals/iterators":347,"../internals/well-known-symbol":412}],317:[function(require,module,exports){
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var anObject = require('../internals/an-object');
var tryToString = require('../internals/try-to-string');
var getIteratorMethod = require('../internals/get-iterator-method');

var $TypeError = TypeError;

module.exports = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
  throw $TypeError(tryToString(argument) + ' is not iterable');
};

},{"../internals/a-callable":250,"../internals/an-object":255,"../internals/function-call":310,"../internals/get-iterator-method":316,"../internals/try-to-string":404}],318:[function(require,module,exports){
var uncurryThis = require('../internals/function-uncurry-this');
var isArray = require('../internals/is-array');
var isCallable = require('../internals/is-callable');
var classof = require('../internals/classof-raw');
var toString = require('../internals/to-string');

var push = uncurryThis([].push);

module.exports = function (replacer) {
  if (isCallable(replacer)) return replacer;
  if (!isArray(replacer)) return;
  var rawLength = replacer.length;
  var keys = [];
  for (var i = 0; i < rawLength; i++) {
    var element = replacer[i];
    if (typeof element == 'string') push(keys, element);
    else if (typeof element == 'number' || classof(element) == 'Number' || classof(element) == 'String') push(keys, toString(element));
  }
  var keysLength = keys.length;
  var root = true;
  return function (key, value) {
    if (root) {
      root = false;
      return value;
    }
    if (isArray(this)) return value;
    for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
  };
};

},{"../internals/classof-raw":270,"../internals/function-uncurry-this":314,"../internals/is-array":331,"../internals/is-callable":332,"../internals/to-string":403}],319:[function(require,module,exports){
var aCallable = require('../internals/a-callable');
var isNullOrUndefined = require('../internals/is-null-or-undefined');

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};

},{"../internals/a-callable":250,"../internals/is-null-or-undefined":337}],320:[function(require,module,exports){
(function (global){(function (){
var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof global == 'object' && global) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],321:[function(require,module,exports){
var uncurryThis = require('../internals/function-uncurry-this');
var toObject = require('../internals/to-object');

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};

},{"../internals/function-uncurry-this":314,"../internals/to-object":399}],322:[function(require,module,exports){
module.exports = {};

},{}],323:[function(require,module,exports){
module.exports = function (a, b) {
  try {
    // eslint-disable-next-line no-console -- safe
    arguments.length == 1 ? console.error(a) : console.error(a, b);
  } catch (error) { /* empty */ }
};

},{}],324:[function(require,module,exports){
var getBuiltIn = require('../internals/get-built-in');

module.exports = getBuiltIn('document', 'documentElement');

},{"../internals/get-built-in":315}],325:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var fails = require('../internals/fails');
var createElement = require('../internals/document-create-element');

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});

},{"../internals/descriptors":283,"../internals/document-create-element":285,"../internals/fails":305}],326:[function(require,module,exports){
var uncurryThis = require('../internals/function-uncurry-this');
var fails = require('../internals/fails');
var classof = require('../internals/classof-raw');

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split(it, '') : $Object(it);
} : $Object;

},{"../internals/classof-raw":270,"../internals/fails":305,"../internals/function-uncurry-this":314}],327:[function(require,module,exports){
var uncurryThis = require('../internals/function-uncurry-this');
var isCallable = require('../internals/is-callable');
var store = require('../internals/shared-store');

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;

},{"../internals/function-uncurry-this":314,"../internals/is-callable":332,"../internals/shared-store":383}],328:[function(require,module,exports){
var isObject = require('../internals/is-object');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');

// `InstallErrorCause` abstract operation
// https://tc39.es/proposal-error-cause/#sec-errorobjects-install-error-cause
module.exports = function (O, options) {
  if (isObject(options) && 'cause' in options) {
    createNonEnumerableProperty(O, 'cause', options.cause);
  }
};

},{"../internals/create-non-enumerable-property":276,"../internals/is-object":338}],329:[function(require,module,exports){
var NATIVE_WEAK_MAP = require('../internals/weak-map-basic-detection');
var global = require('../internals/global');
var isObject = require('../internals/is-object');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var hasOwn = require('../internals/has-own-property');
var shared = require('../internals/shared-store');
var sharedKey = require('../internals/shared-key');
var hiddenKeys = require('../internals/hidden-keys');

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

},{"../internals/create-non-enumerable-property":276,"../internals/global":320,"../internals/has-own-property":321,"../internals/hidden-keys":322,"../internals/is-object":338,"../internals/shared-key":382,"../internals/shared-store":383,"../internals/weak-map-basic-detection":409}],330:[function(require,module,exports){
var wellKnownSymbol = require('../internals/well-known-symbol');
var Iterators = require('../internals/iterators');

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};

},{"../internals/iterators":347,"../internals/well-known-symbol":412}],331:[function(require,module,exports){
var classof = require('../internals/classof-raw');

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) == 'Array';
};

},{"../internals/classof-raw":270}],332:[function(require,module,exports){
var $documentAll = require('../internals/document-all');

var documentAll = $documentAll.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = $documentAll.IS_HTMLDDA ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};

},{"../internals/document-all":284}],333:[function(require,module,exports){
var uncurryThis = require('../internals/function-uncurry-this');
var fails = require('../internals/fails');
var isCallable = require('../internals/is-callable');
var classof = require('../internals/classof');
var getBuiltIn = require('../internals/get-built-in');
var inspectSource = require('../internals/inspect-source');

var noop = function () { /* empty */ };
var empty = [];
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;

},{"../internals/classof":271,"../internals/fails":305,"../internals/function-uncurry-this":314,"../internals/get-built-in":315,"../internals/inspect-source":327,"../internals/is-callable":332}],334:[function(require,module,exports){
var hasOwn = require('../internals/has-own-property');

module.exports = function (descriptor) {
  return descriptor !== undefined && (hasOwn(descriptor, 'value') || hasOwn(descriptor, 'writable'));
};

},{"../internals/has-own-property":321}],335:[function(require,module,exports){
var fails = require('../internals/fails');
var isCallable = require('../internals/is-callable');

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;

},{"../internals/fails":305,"../internals/is-callable":332}],336:[function(require,module,exports){
var isObject = require('../internals/is-object');

var floor = Math.floor;

// `IsIntegralNumber` abstract operation
// https://tc39.es/ecma262/#sec-isintegralnumber
// eslint-disable-next-line es/no-number-isinteger -- safe
module.exports = Number.isInteger || function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"../internals/is-object":338}],337:[function(require,module,exports){
// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};

},{}],338:[function(require,module,exports){
var isCallable = require('../internals/is-callable');
var $documentAll = require('../internals/document-all');

var documentAll = $documentAll.all;

module.exports = $documentAll.IS_HTMLDDA ? function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it) || it === documentAll;
} : function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};

},{"../internals/document-all":284,"../internals/is-callable":332}],339:[function(require,module,exports){
module.exports = true;

},{}],340:[function(require,module,exports){
var isObject = require('../internals/is-object');
var classof = require('../internals/classof-raw');
var wellKnownSymbol = require('../internals/well-known-symbol');

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};

},{"../internals/classof-raw":270,"../internals/is-object":338,"../internals/well-known-symbol":412}],341:[function(require,module,exports){
var getBuiltIn = require('../internals/get-built-in');
var isCallable = require('../internals/is-callable');
var isPrototypeOf = require('../internals/object-is-prototype-of');
var USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};

},{"../internals/get-built-in":315,"../internals/is-callable":332,"../internals/object-is-prototype-of":364,"../internals/use-symbol-as-uid":406}],342:[function(require,module,exports){
var bind = require('../internals/function-bind-context');
var call = require('../internals/function-call');
var anObject = require('../internals/an-object');
var tryToString = require('../internals/try-to-string');
var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var isPrototypeOf = require('../internals/object-is-prototype-of');
var getIterator = require('../internals/get-iterator');
var getIteratorMethod = require('../internals/get-iterator-method');
var iteratorClose = require('../internals/iterator-close');

var $TypeError = TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw $TypeError(tryToString(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf(ResultPrototype, result)) return result;
      } return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }

  next = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = call(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
  } return new Result(false);
};

},{"../internals/an-object":255,"../internals/function-bind-context":307,"../internals/function-call":310,"../internals/get-iterator":317,"../internals/get-iterator-method":316,"../internals/is-array-iterator-method":330,"../internals/iterator-close":343,"../internals/length-of-array-like":348,"../internals/object-is-prototype-of":364,"../internals/try-to-string":404}],343:[function(require,module,exports){
var call = require('../internals/function-call');
var anObject = require('../internals/an-object');
var getMethod = require('../internals/get-method');

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};

},{"../internals/an-object":255,"../internals/function-call":310,"../internals/get-method":319}],344:[function(require,module,exports){
'use strict';
var IteratorPrototype = require('../internals/iterators-core').IteratorPrototype;
var create = require('../internals/object-create');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var setToStringTag = require('../internals/set-to-string-tag');
var Iterators = require('../internals/iterators');

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};

},{"../internals/create-property-descriptor":277,"../internals/iterators":347,"../internals/iterators-core":346,"../internals/object-create":356,"../internals/set-to-string-tag":381}],345:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var call = require('../internals/function-call');
var IS_PURE = require('../internals/is-pure');
var FunctionName = require('../internals/function-name');
var isCallable = require('../internals/is-callable');
var createIteratorConstructor = require('../internals/iterator-create-constructor');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var setToStringTag = require('../internals/set-to-string-tag');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var defineBuiltIn = require('../internals/define-built-in');
var wellKnownSymbol = require('../internals/well-known-symbol');
var Iterators = require('../internals/iterators');
var IteratorsCore = require('../internals/iterators-core');

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
          defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() { return call(nativeIterator, this); };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
  }
  Iterators[NAME] = defaultIterator;

  return methods;
};

},{"../internals/create-non-enumerable-property":276,"../internals/define-built-in":280,"../internals/export":304,"../internals/function-call":310,"../internals/function-name":311,"../internals/is-callable":332,"../internals/is-pure":339,"../internals/iterator-create-constructor":344,"../internals/iterators":347,"../internals/iterators-core":346,"../internals/object-get-prototype-of":363,"../internals/object-set-prototype-of":368,"../internals/set-to-string-tag":381,"../internals/well-known-symbol":412}],346:[function(require,module,exports){
'use strict';
var fails = require('../internals/fails');
var isCallable = require('../internals/is-callable');
var isObject = require('../internals/is-object');
var create = require('../internals/object-create');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var defineBuiltIn = require('../internals/define-built-in');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};

},{"../internals/define-built-in":280,"../internals/fails":305,"../internals/is-callable":332,"../internals/is-object":338,"../internals/is-pure":339,"../internals/object-create":356,"../internals/object-get-prototype-of":363,"../internals/well-known-symbol":412}],347:[function(require,module,exports){
arguments[4][322][0].apply(exports,arguments)
},{"dup":322}],348:[function(require,module,exports){
var toLength = require('../internals/to-length');

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};

},{"../internals/to-length":398}],349:[function(require,module,exports){
var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};

},{}],350:[function(require,module,exports){
var global = require('../internals/global');
var bind = require('../internals/function-bind-context');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var macrotask = require('../internals/task').set;
var Queue = require('../internals/queue');
var IS_IOS = require('../internals/engine-is-ios');
var IS_IOS_PEBBLE = require('../internals/engine-is-ios-pebble');
var IS_WEBOS_WEBKIT = require('../internals/engine-is-webos-webkit');
var IS_NODE = require('../internals/engine-is-node');

var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var document = global.document;
var process = global.process;
var Promise = global.Promise;
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var microtask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var notify, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!microtask) {
  var queue = new Queue();

  var flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (fn = queue.get()) try {
      fn();
    } catch (error) {
      if (queue.head) notify();
      throw error;
    }
    if (parent) parent.enter();
  };

  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
  if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true });
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (!IS_IOS_PEBBLE && Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    // workaround of WebKit ~ iOS Safari 10.1 bug
    promise.constructor = Promise;
    then = bind(promise.then, promise);
    notify = function () {
      then(flush);
    };
  // Node.js without promises
  } else if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessage
  // - onreadystatechange
  // - setTimeout
  } else {
    // `webpack` dev server bug on IE global methods - use bind(fn, global)
    macrotask = bind(macrotask, global);
    notify = function () {
      macrotask(flush);
    };
  }

  microtask = function (fn) {
    if (!queue.head) notify();
    queue.add(fn);
  };
}

module.exports = microtask;

},{"../internals/engine-is-ios":293,"../internals/engine-is-ios-pebble":292,"../internals/engine-is-node":294,"../internals/engine-is-webos-webkit":295,"../internals/function-bind-context":307,"../internals/global":320,"../internals/object-get-own-property-descriptor":359,"../internals/queue":378,"../internals/task":394}],351:[function(require,module,exports){
'use strict';
var aCallable = require('../internals/a-callable');

var $TypeError = TypeError;

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw $TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aCallable(resolve);
  this.reject = aCallable(reject);
};

// `NewPromiseCapability` abstract operation
// https://tc39.es/ecma262/#sec-newpromisecapability
module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"../internals/a-callable":250}],352:[function(require,module,exports){
var toString = require('../internals/to-string');

module.exports = function (argument, $default) {
  return argument === undefined ? arguments.length < 2 ? '' : $default : toString(argument);
};

},{"../internals/to-string":403}],353:[function(require,module,exports){
var isRegExp = require('../internals/is-regexp');

var $TypeError = TypeError;

module.exports = function (it) {
  if (isRegExp(it)) {
    throw $TypeError("The method doesn't accept regular expressions");
  } return it;
};

},{"../internals/is-regexp":340}],354:[function(require,module,exports){
var global = require('../internals/global');
var fails = require('../internals/fails');
var uncurryThis = require('../internals/function-uncurry-this');
var toString = require('../internals/to-string');
var trim = require('../internals/string-trim').trim;
var whitespaces = require('../internals/whitespaces');

var charAt = uncurryThis(''.charAt);
var $parseFloat = global.parseFloat;
var Symbol = global.Symbol;
var ITERATOR = Symbol && Symbol.iterator;
var FORCED = 1 / $parseFloat(whitespaces + '-0') !== -Infinity
  // MS Edge 18- broken with boxed symbols
  || (ITERATOR && !fails(function () { $parseFloat(Object(ITERATOR)); }));

// `parseFloat` method
// https://tc39.es/ecma262/#sec-parsefloat-string
module.exports = FORCED ? function parseFloat(string) {
  var trimmedString = trim(toString(string));
  var result = $parseFloat(trimmedString);
  return result === 0 && charAt(trimmedString, 0) == '-' ? -0 : result;
} : $parseFloat;

},{"../internals/fails":305,"../internals/function-uncurry-this":314,"../internals/global":320,"../internals/string-trim":390,"../internals/to-string":403,"../internals/whitespaces":413}],355:[function(require,module,exports){
'use strict';
var DESCRIPTORS = require('../internals/descriptors');
var uncurryThis = require('../internals/function-uncurry-this');
var call = require('../internals/function-call');
var fails = require('../internals/fails');
var objectKeys = require('../internals/object-keys');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
var toObject = require('../internals/to-object');
var IndexedObject = require('../internals/indexed-object');

// eslint-disable-next-line es/no-object-assign -- safe
var $assign = Object.assign;
// eslint-disable-next-line es/no-object-defineproperty -- required for testing
var defineProperty = Object.defineProperty;
var concat = uncurryThis([].concat);

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
module.exports = !$assign || fails(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1) return true;
  // should work with symbols and should have deterministic property order (V8 bug)
  var A = {};
  var B = {};
  // eslint-disable-next-line es/no-symbol -- safe
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || call(propertyIsEnumerable, S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;

},{"../internals/descriptors":283,"../internals/fails":305,"../internals/function-call":310,"../internals/function-uncurry-this":314,"../internals/indexed-object":326,"../internals/object-get-own-property-symbols":362,"../internals/object-keys":366,"../internals/object-property-is-enumerable":367,"../internals/to-object":399}],356:[function(require,module,exports){
/* global ActiveXObject -- old IE, WSH */
var anObject = require('../internals/an-object');
var definePropertiesModule = require('../internals/object-define-properties');
var enumBugKeys = require('../internals/enum-bug-keys');
var hiddenKeys = require('../internals/hidden-keys');
var html = require('../internals/html');
var documentCreateElement = require('../internals/document-create-element');
var sharedKey = require('../internals/shared-key');

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};

},{"../internals/an-object":255,"../internals/document-create-element":285,"../internals/enum-bug-keys":300,"../internals/hidden-keys":322,"../internals/html":324,"../internals/object-define-properties":357,"../internals/shared-key":382}],357:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var V8_PROTOTYPE_DEFINE_BUG = require('../internals/v8-prototype-define-bug');
var definePropertyModule = require('../internals/object-define-property');
var anObject = require('../internals/an-object');
var toIndexedObject = require('../internals/to-indexed-object');
var objectKeys = require('../internals/object-keys');

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};

},{"../internals/an-object":255,"../internals/descriptors":283,"../internals/object-define-property":358,"../internals/object-keys":366,"../internals/to-indexed-object":396,"../internals/v8-prototype-define-bug":407}],358:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var IE8_DOM_DEFINE = require('../internals/ie8-dom-define');
var V8_PROTOTYPE_DEFINE_BUG = require('../internals/v8-prototype-define-bug');
var anObject = require('../internals/an-object');
var toPropertyKey = require('../internals/to-property-key');

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"../internals/an-object":255,"../internals/descriptors":283,"../internals/ie8-dom-define":325,"../internals/to-property-key":401,"../internals/v8-prototype-define-bug":407}],359:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var call = require('../internals/function-call');
var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var toIndexedObject = require('../internals/to-indexed-object');
var toPropertyKey = require('../internals/to-property-key');
var hasOwn = require('../internals/has-own-property');
var IE8_DOM_DEFINE = require('../internals/ie8-dom-define');

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};

},{"../internals/create-property-descriptor":277,"../internals/descriptors":283,"../internals/function-call":310,"../internals/has-own-property":321,"../internals/ie8-dom-define":325,"../internals/object-property-is-enumerable":367,"../internals/to-indexed-object":396,"../internals/to-property-key":401}],360:[function(require,module,exports){
/* eslint-disable es/no-object-getownpropertynames -- safe */
var classof = require('../internals/classof-raw');
var toIndexedObject = require('../internals/to-indexed-object');
var $getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
var arraySlice = require('../internals/array-slice-simple');

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return arraySlice(windowNames);
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && classof(it) == 'Window'
    ? getWindowNames(it)
    : $getOwnPropertyNames(toIndexedObject(it));
};

},{"../internals/array-slice-simple":263,"../internals/classof-raw":270,"../internals/object-get-own-property-names":361,"../internals/to-indexed-object":396}],361:[function(require,module,exports){
var internalObjectKeys = require('../internals/object-keys-internal');
var enumBugKeys = require('../internals/enum-bug-keys');

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};

},{"../internals/enum-bug-keys":300,"../internals/object-keys-internal":365}],362:[function(require,module,exports){
// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;

},{}],363:[function(require,module,exports){
var hasOwn = require('../internals/has-own-property');
var isCallable = require('../internals/is-callable');
var toObject = require('../internals/to-object');
var sharedKey = require('../internals/shared-key');
var CORRECT_PROTOTYPE_GETTER = require('../internals/correct-prototype-getter');

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};

},{"../internals/correct-prototype-getter":274,"../internals/has-own-property":321,"../internals/is-callable":332,"../internals/shared-key":382,"../internals/to-object":399}],364:[function(require,module,exports){
var uncurryThis = require('../internals/function-uncurry-this');

module.exports = uncurryThis({}.isPrototypeOf);

},{"../internals/function-uncurry-this":314}],365:[function(require,module,exports){
var uncurryThis = require('../internals/function-uncurry-this');
var hasOwn = require('../internals/has-own-property');
var toIndexedObject = require('../internals/to-indexed-object');
var indexOf = require('../internals/array-includes').indexOf;
var hiddenKeys = require('../internals/hidden-keys');

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};

},{"../internals/array-includes":258,"../internals/function-uncurry-this":314,"../internals/has-own-property":321,"../internals/hidden-keys":322,"../internals/to-indexed-object":396}],366:[function(require,module,exports){
var internalObjectKeys = require('../internals/object-keys-internal');
var enumBugKeys = require('../internals/enum-bug-keys');

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};

},{"../internals/enum-bug-keys":300,"../internals/object-keys-internal":365}],367:[function(require,module,exports){
'use strict';
var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;

},{}],368:[function(require,module,exports){
/* eslint-disable no-proto -- safe */
var uncurryThisAccessor = require('../internals/function-uncurry-this-accessor');
var anObject = require('../internals/an-object');
var aPossiblePrototype = require('../internals/a-possible-prototype');

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);

},{"../internals/a-possible-prototype":252,"../internals/an-object":255,"../internals/function-uncurry-this-accessor":312}],369:[function(require,module,exports){
'use strict';
var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
var classof = require('../internals/classof');

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};

},{"../internals/classof":271,"../internals/to-string-tag-support":402}],370:[function(require,module,exports){
var call = require('../internals/function-call');
var isCallable = require('../internals/is-callable');
var isObject = require('../internals/is-object');

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw $TypeError("Can't convert object to primitive value");
};

},{"../internals/function-call":310,"../internals/is-callable":332,"../internals/is-object":338}],371:[function(require,module,exports){
var getBuiltIn = require('../internals/get-built-in');
var uncurryThis = require('../internals/function-uncurry-this');
var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var anObject = require('../internals/an-object');

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};

},{"../internals/an-object":255,"../internals/function-uncurry-this":314,"../internals/get-built-in":315,"../internals/object-get-own-property-names":361,"../internals/object-get-own-property-symbols":362}],372:[function(require,module,exports){
arguments[4][322][0].apply(exports,arguments)
},{"dup":322}],373:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};

},{}],374:[function(require,module,exports){
var global = require('../internals/global');
var NativePromiseConstructor = require('../internals/promise-native-constructor');
var isCallable = require('../internals/is-callable');
var isForced = require('../internals/is-forced');
var inspectSource = require('../internals/inspect-source');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_BROWSER = require('../internals/engine-is-browser');
var IS_DENO = require('../internals/engine-is-deno');
var IS_PURE = require('../internals/is-pure');
var V8_VERSION = require('../internals/engine-v8-version');

var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
var SPECIES = wellKnownSymbol('species');
var SUBCLASSING = false;
var NATIVE_PROMISE_REJECTION_EVENT = isCallable(global.PromiseRejectionEvent);

var FORCED_PROMISE_CONSTRUCTOR = isForced('Promise', function () {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
  // We can't detect it synchronously, so just check versions
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
  // We need Promise#{ catch, finally } in the pure version for preventing prototype pollution
  if (IS_PURE && !(NativePromisePrototype['catch'] && NativePromisePrototype['finally'])) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
    // Detect correctness of subclassing with @@species support
    var promise = new NativePromiseConstructor(function (resolve) { resolve(1); });
    var FakePromise = function (exec) {
      exec(function () { /* empty */ }, function () { /* empty */ });
    };
    var constructor = promise.constructor = {};
    constructor[SPECIES] = FakePromise;
    SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;
    if (!SUBCLASSING) return true;
  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
  } return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER || IS_DENO) && !NATIVE_PROMISE_REJECTION_EVENT;
});

module.exports = {
  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
  SUBCLASSING: SUBCLASSING
};

},{"../internals/engine-is-browser":289,"../internals/engine-is-deno":290,"../internals/engine-v8-version":297,"../internals/global":320,"../internals/inspect-source":327,"../internals/is-callable":332,"../internals/is-forced":335,"../internals/is-pure":339,"../internals/promise-native-constructor":375,"../internals/well-known-symbol":412}],375:[function(require,module,exports){
var global = require('../internals/global');

module.exports = global.Promise;

},{"../internals/global":320}],376:[function(require,module,exports){
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var newPromiseCapability = require('../internals/new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"../internals/an-object":255,"../internals/is-object":338,"../internals/new-promise-capability":351}],377:[function(require,module,exports){
var NativePromiseConstructor = require('../internals/promise-native-constructor');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
var FORCED_PROMISE_CONSTRUCTOR = require('../internals/promise-constructor-detection').CONSTRUCTOR;

module.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function (iterable) {
  NativePromiseConstructor.all(iterable).then(undefined, function () { /* empty */ });
});

},{"../internals/check-correctness-of-iteration":269,"../internals/promise-constructor-detection":374,"../internals/promise-native-constructor":375}],378:[function(require,module,exports){
var Queue = function () {
  this.head = null;
  this.tail = null;
};

Queue.prototype = {
  add: function (item) {
    var entry = { item: item, next: null };
    var tail = this.tail;
    if (tail) tail.next = entry;
    else this.head = entry;
    this.tail = entry;
  },
  get: function () {
    var entry = this.head;
    if (entry) {
      var next = this.head = entry.next;
      if (next === null) this.tail = null;
      return entry.item;
    }
  }
};

module.exports = Queue;

},{}],379:[function(require,module,exports){
var isNullOrUndefined = require('../internals/is-null-or-undefined');

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw $TypeError("Can't call method on " + it);
  return it;
};

},{"../internals/is-null-or-undefined":337}],380:[function(require,module,exports){
'use strict';
var getBuiltIn = require('../internals/get-built-in');
var defineBuiltInAccessor = require('../internals/define-built-in-accessor');
var wellKnownSymbol = require('../internals/well-known-symbol');
var DESCRIPTORS = require('../internals/descriptors');

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineBuiltInAccessor(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};

},{"../internals/define-built-in-accessor":279,"../internals/descriptors":283,"../internals/get-built-in":315,"../internals/well-known-symbol":412}],381:[function(require,module,exports){
var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
var defineProperty = require('../internals/object-define-property').f;
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var hasOwn = require('../internals/has-own-property');
var toString = require('../internals/object-to-string');
var wellKnownSymbol = require('../internals/well-known-symbol');

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC, SET_METHOD) {
  if (it) {
    var target = STATIC ? it : it.prototype;
    if (!hasOwn(target, TO_STRING_TAG)) {
      defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
    }
    if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
      createNonEnumerableProperty(target, 'toString', toString);
    }
  }
};

},{"../internals/create-non-enumerable-property":276,"../internals/has-own-property":321,"../internals/object-define-property":358,"../internals/object-to-string":369,"../internals/to-string-tag-support":402,"../internals/well-known-symbol":412}],382:[function(require,module,exports){
var shared = require('../internals/shared');
var uid = require('../internals/uid');

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};

},{"../internals/shared":384,"../internals/uid":405}],383:[function(require,module,exports){
var global = require('../internals/global');
var defineGlobalProperty = require('../internals/define-global-property');

var SHARED = '__core-js_shared__';
var store = global[SHARED] || defineGlobalProperty(SHARED, {});

module.exports = store;

},{"../internals/define-global-property":281,"../internals/global":320}],384:[function(require,module,exports){
var IS_PURE = require('../internals/is-pure');
var store = require('../internals/shared-store');

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.30.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2023 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.30.1/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});

},{"../internals/is-pure":339,"../internals/shared-store":383}],385:[function(require,module,exports){
var anObject = require('../internals/an-object');
var aConstructor = require('../internals/a-constructor');
var isNullOrUndefined = require('../internals/is-null-or-undefined');
var wellKnownSymbol = require('../internals/well-known-symbol');

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || isNullOrUndefined(S = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S);
};

},{"../internals/a-constructor":251,"../internals/an-object":255,"../internals/is-null-or-undefined":337,"../internals/well-known-symbol":412}],386:[function(require,module,exports){
var uncurryThis = require('../internals/function-uncurry-this');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var toString = require('../internals/to-string');
var requireObjectCoercible = require('../internals/require-object-coercible');

var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var stringSlice = uncurryThis(''.slice);

var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString(requireObjectCoercible($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};

},{"../internals/function-uncurry-this":314,"../internals/require-object-coercible":379,"../internals/to-integer-or-infinity":397,"../internals/to-string":403}],387:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/280
var userAgent = require('../internals/engine-user-agent');

module.exports = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(userAgent);

},{"../internals/engine-user-agent":296}],388:[function(require,module,exports){
// https://github.com/tc39/proposal-string-pad-start-end
var uncurryThis = require('../internals/function-uncurry-this');
var toLength = require('../internals/to-length');
var toString = require('../internals/to-string');
var $repeat = require('../internals/string-repeat');
var requireObjectCoercible = require('../internals/require-object-coercible');

var repeat = uncurryThis($repeat);
var stringSlice = uncurryThis(''.slice);
var ceil = Math.ceil;

// `String.prototype.{ padStart, padEnd }` methods implementation
var createMethod = function (IS_END) {
  return function ($this, maxLength, fillString) {
    var S = toString(requireObjectCoercible($this));
    var intMaxLength = toLength(maxLength);
    var stringLength = S.length;
    var fillStr = fillString === undefined ? ' ' : toString(fillString);
    var fillLen, stringFiller;
    if (intMaxLength <= stringLength || fillStr == '') return S;
    fillLen = intMaxLength - stringLength;
    stringFiller = repeat(fillStr, ceil(fillLen / fillStr.length));
    if (stringFiller.length > fillLen) stringFiller = stringSlice(stringFiller, 0, fillLen);
    return IS_END ? S + stringFiller : stringFiller + S;
  };
};

module.exports = {
  // `String.prototype.padStart` method
  // https://tc39.es/ecma262/#sec-string.prototype.padstart
  start: createMethod(false),
  // `String.prototype.padEnd` method
  // https://tc39.es/ecma262/#sec-string.prototype.padend
  end: createMethod(true)
};

},{"../internals/function-uncurry-this":314,"../internals/require-object-coercible":379,"../internals/string-repeat":389,"../internals/to-length":398,"../internals/to-string":403}],389:[function(require,module,exports){
'use strict';
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var toString = require('../internals/to-string');
var requireObjectCoercible = require('../internals/require-object-coercible');

var $RangeError = RangeError;

// `String.prototype.repeat` method implementation
// https://tc39.es/ecma262/#sec-string.prototype.repeat
module.exports = function repeat(count) {
  var str = toString(requireObjectCoercible(this));
  var result = '';
  var n = toIntegerOrInfinity(count);
  if (n < 0 || n == Infinity) throw $RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};

},{"../internals/require-object-coercible":379,"../internals/to-integer-or-infinity":397,"../internals/to-string":403}],390:[function(require,module,exports){
var uncurryThis = require('../internals/function-uncurry-this');
var requireObjectCoercible = require('../internals/require-object-coercible');
var toString = require('../internals/to-string');
var whitespaces = require('../internals/whitespaces');

var replace = uncurryThis(''.replace);
var ltrim = RegExp('^[' + whitespaces + ']+');
var rtrim = RegExp('(^|[^' + whitespaces + '])[' + whitespaces + ']+$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = toString(requireObjectCoercible($this));
    if (TYPE & 1) string = replace(string, ltrim, '');
    if (TYPE & 2) string = replace(string, rtrim, '$1');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};

},{"../internals/function-uncurry-this":314,"../internals/require-object-coercible":379,"../internals/to-string":403,"../internals/whitespaces":413}],391:[function(require,module,exports){
/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = require('../internals/engine-v8-version');
var fails = require('../internals/fails');

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});

},{"../internals/engine-v8-version":297,"../internals/fails":305}],392:[function(require,module,exports){
var call = require('../internals/function-call');
var getBuiltIn = require('../internals/get-built-in');
var wellKnownSymbol = require('../internals/well-known-symbol');
var defineBuiltIn = require('../internals/define-built-in');

module.exports = function () {
  var Symbol = getBuiltIn('Symbol');
  var SymbolPrototype = Symbol && Symbol.prototype;
  var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
  var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

  if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
    // `Symbol.prototype[@@toPrimitive]` method
    // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
    // eslint-disable-next-line no-unused-vars -- required for .length
    defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function (hint) {
      return call(valueOf, this);
    }, { arity: 1 });
  }
};

},{"../internals/define-built-in":280,"../internals/function-call":310,"../internals/get-built-in":315,"../internals/well-known-symbol":412}],393:[function(require,module,exports){
var NATIVE_SYMBOL = require('../internals/symbol-constructor-detection');

/* eslint-disable es/no-symbol -- safe */
module.exports = NATIVE_SYMBOL && !!Symbol['for'] && !!Symbol.keyFor;

},{"../internals/symbol-constructor-detection":391}],394:[function(require,module,exports){
var global = require('../internals/global');
var apply = require('../internals/function-apply');
var bind = require('../internals/function-bind-context');
var isCallable = require('../internals/is-callable');
var hasOwn = require('../internals/has-own-property');
var fails = require('../internals/fails');
var html = require('../internals/html');
var arraySlice = require('../internals/array-slice');
var createElement = require('../internals/document-create-element');
var validateArgumentsLength = require('../internals/validate-arguments-length');
var IS_IOS = require('../internals/engine-is-ios');
var IS_NODE = require('../internals/engine-is-node');

var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var Dispatch = global.Dispatch;
var Function = global.Function;
var MessageChannel = global.MessageChannel;
var String = global.String;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var $location, defer, channel, port;

fails(function () {
  // Deno throws a ReferenceError on `location` access without `--location` flag
  $location = global.location;
});

var run = function (id) {
  if (hasOwn(queue, id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var eventListener = function (event) {
  run(event.data);
};

var globalPostMessageDefer = function (id) {
  // old engines have not location.origin
  global.postMessage(String(id), $location.protocol + '//' + $location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(handler) {
    validateArgumentsLength(arguments.length, 1);
    var fn = isCallable(handler) ? handler : Function(handler);
    var args = arraySlice(arguments, 1);
    queue[++counter] = function () {
      apply(fn, undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (IS_NODE) {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = eventListener;
    defer = bind(port.postMessage, port);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    global.addEventListener &&
    isCallable(global.postMessage) &&
    !global.importScripts &&
    $location && $location.protocol !== 'file:' &&
    !fails(globalPostMessageDefer)
  ) {
    defer = globalPostMessageDefer;
    global.addEventListener('message', eventListener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};

},{"../internals/array-slice":264,"../internals/document-create-element":285,"../internals/engine-is-ios":293,"../internals/engine-is-node":294,"../internals/fails":305,"../internals/function-apply":306,"../internals/function-bind-context":307,"../internals/global":320,"../internals/has-own-property":321,"../internals/html":324,"../internals/is-callable":332,"../internals/validate-arguments-length":408}],395:[function(require,module,exports){
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};

},{"../internals/to-integer-or-infinity":397}],396:[function(require,module,exports){
// toObject with fallback for non-array-like ES3 strings
var IndexedObject = require('../internals/indexed-object');
var requireObjectCoercible = require('../internals/require-object-coercible');

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};

},{"../internals/indexed-object":326,"../internals/require-object-coercible":379}],397:[function(require,module,exports){
var trunc = require('../internals/math-trunc');

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};

},{"../internals/math-trunc":349}],398:[function(require,module,exports){
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

},{"../internals/to-integer-or-infinity":397}],399:[function(require,module,exports){
var requireObjectCoercible = require('../internals/require-object-coercible');

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};

},{"../internals/require-object-coercible":379}],400:[function(require,module,exports){
var call = require('../internals/function-call');
var isObject = require('../internals/is-object');
var isSymbol = require('../internals/is-symbol');
var getMethod = require('../internals/get-method');
var ordinaryToPrimitive = require('../internals/ordinary-to-primitive');
var wellKnownSymbol = require('../internals/well-known-symbol');

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};

},{"../internals/function-call":310,"../internals/get-method":319,"../internals/is-object":338,"../internals/is-symbol":341,"../internals/ordinary-to-primitive":370,"../internals/well-known-symbol":412}],401:[function(require,module,exports){
var toPrimitive = require('../internals/to-primitive');
var isSymbol = require('../internals/is-symbol');

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};

},{"../internals/is-symbol":341,"../internals/to-primitive":400}],402:[function(require,module,exports){
var wellKnownSymbol = require('../internals/well-known-symbol');

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';

},{"../internals/well-known-symbol":412}],403:[function(require,module,exports){
var classof = require('../internals/classof');

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};

},{"../internals/classof":271}],404:[function(require,module,exports){
var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};

},{}],405:[function(require,module,exports){
var uncurryThis = require('../internals/function-uncurry-this');

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};

},{"../internals/function-uncurry-this":314}],406:[function(require,module,exports){
/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = require('../internals/symbol-constructor-detection');

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';

},{"../internals/symbol-constructor-detection":391}],407:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var fails = require('../internals/fails');

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});

},{"../internals/descriptors":283,"../internals/fails":305}],408:[function(require,module,exports){
var $TypeError = TypeError;

module.exports = function (passed, required) {
  if (passed < required) throw $TypeError('Not enough arguments');
  return passed;
};

},{}],409:[function(require,module,exports){
var global = require('../internals/global');
var isCallable = require('../internals/is-callable');

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));

},{"../internals/global":320,"../internals/is-callable":332}],410:[function(require,module,exports){
var path = require('../internals/path');
var hasOwn = require('../internals/has-own-property');
var wrappedWellKnownSymbolModule = require('../internals/well-known-symbol-wrapped');
var defineProperty = require('../internals/object-define-property').f;

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!hasOwn(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};

},{"../internals/has-own-property":321,"../internals/object-define-property":358,"../internals/path":372,"../internals/well-known-symbol-wrapped":411}],411:[function(require,module,exports){
var wellKnownSymbol = require('../internals/well-known-symbol');

exports.f = wellKnownSymbol;

},{"../internals/well-known-symbol":412}],412:[function(require,module,exports){
var global = require('../internals/global');
var shared = require('../internals/shared');
var hasOwn = require('../internals/has-own-property');
var uid = require('../internals/uid');
var NATIVE_SYMBOL = require('../internals/symbol-constructor-detection');
var USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');

var Symbol = global.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};

},{"../internals/global":320,"../internals/has-own-property":321,"../internals/shared":384,"../internals/symbol-constructor-detection":391,"../internals/uid":405,"../internals/use-symbol-as-uid":406}],413:[function(require,module,exports){
// a string of all valid unicode whitespaces
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

},{}],414:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var isPrototypeOf = require('../internals/object-is-prototype-of');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var copyConstructorProperties = require('../internals/copy-constructor-properties');
var create = require('../internals/object-create');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var installErrorCause = require('../internals/install-error-cause');
var installErrorStack = require('../internals/error-stack-install');
var iterate = require('../internals/iterate');
var normalizeStringArgument = require('../internals/normalize-string-argument');
var wellKnownSymbol = require('../internals/well-known-symbol');

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Error = Error;
var push = [].push;

var $AggregateError = function AggregateError(errors, message /* , options */) {
  var isInstance = isPrototypeOf(AggregateErrorPrototype, this);
  var that;
  if (setPrototypeOf) {
    that = setPrototypeOf($Error(), isInstance ? getPrototypeOf(this) : AggregateErrorPrototype);
  } else {
    that = isInstance ? this : create(AggregateErrorPrototype);
    createNonEnumerableProperty(that, TO_STRING_TAG, 'Error');
  }
  if (message !== undefined) createNonEnumerableProperty(that, 'message', normalizeStringArgument(message));
  installErrorStack(that, $AggregateError, that.stack, 1);
  if (arguments.length > 2) installErrorCause(that, arguments[2]);
  var errorsArray = [];
  iterate(errors, push, { that: errorsArray });
  createNonEnumerableProperty(that, 'errors', errorsArray);
  return that;
};

if (setPrototypeOf) setPrototypeOf($AggregateError, $Error);
else copyConstructorProperties($AggregateError, $Error, { name: true });

var AggregateErrorPrototype = $AggregateError.prototype = create($Error.prototype, {
  constructor: createPropertyDescriptor(1, $AggregateError),
  message: createPropertyDescriptor(1, ''),
  name: createPropertyDescriptor(1, 'AggregateError')
});

// `AggregateError` constructor
// https://tc39.es/ecma262/#sec-aggregate-error-constructor
$({ global: true, constructor: true, arity: 2 }, {
  AggregateError: $AggregateError
});

},{"../internals/copy-constructor-properties":272,"../internals/create-non-enumerable-property":276,"../internals/create-property-descriptor":277,"../internals/error-stack-install":302,"../internals/export":304,"../internals/install-error-cause":328,"../internals/iterate":342,"../internals/normalize-string-argument":352,"../internals/object-create":356,"../internals/object-get-prototype-of":363,"../internals/object-is-prototype-of":364,"../internals/object-set-prototype-of":368,"../internals/well-known-symbol":412}],415:[function(require,module,exports){
// TODO: Remove this module from `core-js@4` since it's replaced to module below
require('../modules/es.aggregate-error.constructor');

},{"../modules/es.aggregate-error.constructor":414}],416:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var fails = require('../internals/fails');
var isArray = require('../internals/is-array');
var isObject = require('../internals/is-object');
var toObject = require('../internals/to-object');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var doesNotExceedSafeInteger = require('../internals/does-not-exceed-safe-integer');
var createProperty = require('../internals/create-property');
var arraySpeciesCreate = require('../internals/array-species-create');
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var wellKnownSymbol = require('../internals/well-known-symbol');
var V8_VERSION = require('../internals/engine-v8-version');

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport('concat');

// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike(E);
        doesNotExceedSafeInteger(n + len);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        doesNotExceedSafeInteger(n + 1);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});

},{"../internals/array-method-has-species-support":260,"../internals/array-species-create":267,"../internals/create-property":278,"../internals/does-not-exceed-safe-integer":286,"../internals/engine-v8-version":297,"../internals/export":304,"../internals/fails":305,"../internals/is-array":331,"../internals/is-object":338,"../internals/length-of-array-like":348,"../internals/to-object":399,"../internals/well-known-symbol":412}],417:[function(require,module,exports){
var $ = require('../internals/export');
var fill = require('../internals/array-fill');
var addToUnscopables = require('../internals/add-to-unscopables');

// `Array.prototype.fill` method
// https://tc39.es/ecma262/#sec-array.prototype.fill
$({ target: 'Array', proto: true }, {
  fill: fill
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('fill');

},{"../internals/add-to-unscopables":253,"../internals/array-fill":256,"../internals/export":304}],418:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $filter = require('../internals/array-iteration').filter;
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');

// `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"../internals/array-iteration":259,"../internals/array-method-has-species-support":260,"../internals/export":304}],419:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $findIndex = require('../internals/array-iteration').findIndex;
var addToUnscopables = require('../internals/add-to-unscopables');

var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true;

// Shouldn't skip holes
// eslint-disable-next-line es/no-array-prototype-findindex -- testing
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });

// `Array.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-array.prototype.findindex
$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND_INDEX);

},{"../internals/add-to-unscopables":253,"../internals/array-iteration":259,"../internals/export":304}],420:[function(require,module,exports){
var $ = require('../internals/export');
var from = require('../internals/array-from');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  // eslint-disable-next-line es/no-array-from -- required for testing
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.es/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});

},{"../internals/array-from":257,"../internals/check-correctness-of-iteration":269,"../internals/export":304}],421:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $includes = require('../internals/array-includes').includes;
var fails = require('../internals/fails');
var addToUnscopables = require('../internals/add-to-unscopables');

// FF99+ bug
var BROKEN_ON_SPARSE = fails(function () {
  // eslint-disable-next-line es/no-array-prototype-includes -- detection
  return !Array(1).includes();
});

// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');

},{"../internals/add-to-unscopables":253,"../internals/array-includes":258,"../internals/export":304,"../internals/fails":305}],422:[function(require,module,exports){
var $ = require('../internals/export');
var isArray = require('../internals/is-array');

// `Array.isArray` method
// https://tc39.es/ecma262/#sec-array.isarray
$({ target: 'Array', stat: true }, {
  isArray: isArray
});

},{"../internals/export":304,"../internals/is-array":331}],423:[function(require,module,exports){
'use strict';
var toIndexedObject = require('../internals/to-indexed-object');
var addToUnscopables = require('../internals/add-to-unscopables');
var Iterators = require('../internals/iterators');
var InternalStateModule = require('../internals/internal-state');
var defineProperty = require('../internals/object-define-property').f;
var defineIterator = require('../internals/iterator-define');
var createIterResultObject = require('../internals/create-iter-result-object');
var IS_PURE = require('../internals/is-pure');
var DESCRIPTORS = require('../internals/descriptors');

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return createIterResultObject(undefined, true);
  }
  if (kind == 'keys') return createIterResultObject(index, false);
  if (kind == 'values') return createIterResultObject(target[index], false);
  return createIterResultObject([index, target[index]], false);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

// V8 ~ Chrome 45- bug
if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
  defineProperty(values, 'name', { value: 'values' });
} catch (error) { /* empty */ }

},{"../internals/add-to-unscopables":253,"../internals/create-iter-result-object":275,"../internals/descriptors":283,"../internals/internal-state":329,"../internals/is-pure":339,"../internals/iterator-define":345,"../internals/iterators":347,"../internals/object-define-property":358,"../internals/to-indexed-object":396}],424:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $map = require('../internals/array-iteration').map;
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');

// `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"../internals/array-iteration":259,"../internals/array-method-has-species-support":260,"../internals/export":304}],425:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var isArray = require('../internals/is-array');
var isConstructor = require('../internals/is-constructor');
var isObject = require('../internals/is-object');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var toIndexedObject = require('../internals/to-indexed-object');
var createProperty = require('../internals/create-property');
var wellKnownSymbol = require('../internals/well-known-symbol');
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
var nativeSlice = require('../internals/array-slice');

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');

var SPECIES = wellKnownSymbol('species');
var $Array = Array;
var max = Math.max;

// `Array.prototype.slice` method
// https://tc39.es/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = lengthOfArrayLike(O);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (isConstructor(Constructor) && (Constructor === $Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === $Array || Constructor === undefined) {
        return nativeSlice(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? $Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});

},{"../internals/array-method-has-species-support":260,"../internals/array-slice":264,"../internals/create-property":278,"../internals/export":304,"../internals/is-array":331,"../internals/is-constructor":333,"../internals/is-object":338,"../internals/length-of-array-like":348,"../internals/to-absolute-index":395,"../internals/to-indexed-object":396,"../internals/well-known-symbol":412}],426:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var aCallable = require('../internals/a-callable');
var toObject = require('../internals/to-object');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var deletePropertyOrThrow = require('../internals/delete-property-or-throw');
var toString = require('../internals/to-string');
var fails = require('../internals/fails');
var internalSort = require('../internals/array-sort');
var arrayMethodIsStrict = require('../internals/array-method-is-strict');
var FF = require('../internals/engine-ff-version');
var IE_OR_EDGE = require('../internals/engine-is-ie-or-edge');
var V8 = require('../internals/engine-v8-version');
var WEBKIT = require('../internals/engine-webkit-version');

var test = [];
var nativeSort = uncurryThis(test.sort);
var push = uncurryThis(test.push);

// IE8-
var FAILS_ON_UNDEFINED = fails(function () {
  test.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function () {
  test.sort(null);
});
// Old WebKit
var STRICT_METHOD = arrayMethodIsStrict('sort');

var STABLE_SORT = !fails(function () {
  // feature detection can be too slow, so check engines versions
  if (V8) return V8 < 70;
  if (FF && FF > 3) return;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 603;

  var result = '';
  var code, chr, value, index;

  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)
  for (code = 65; code < 76; code++) {
    chr = String.fromCharCode(code);

    switch (code) {
      case 66: case 69: case 70: case 72: value = 3; break;
      case 68: case 71: value = 4; break;
      default: value = 2;
    }

    for (index = 0; index < 47; index++) {
      test.push({ k: chr + index, v: value });
    }
  }

  test.sort(function (a, b) { return b.v - a.v; });

  for (index = 0; index < test.length; index++) {
    chr = test[index].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr) result += chr;
  }

  return result !== 'DGBEFHACIJK';
});

var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;

var getSortCompare = function (comparefn) {
  return function (x, y) {
    if (y === undefined) return -1;
    if (x === undefined) return 1;
    if (comparefn !== undefined) return +comparefn(x, y) || 0;
    return toString(x) > toString(y) ? 1 : -1;
  };
};

// `Array.prototype.sort` method
// https://tc39.es/ecma262/#sec-array.prototype.sort
$({ target: 'Array', proto: true, forced: FORCED }, {
  sort: function sort(comparefn) {
    if (comparefn !== undefined) aCallable(comparefn);

    var array = toObject(this);

    if (STABLE_SORT) return comparefn === undefined ? nativeSort(array) : nativeSort(array, comparefn);

    var items = [];
    var arrayLength = lengthOfArrayLike(array);
    var itemsLength, index;

    for (index = 0; index < arrayLength; index++) {
      if (index in array) push(items, array[index]);
    }

    internalSort(items, getSortCompare(comparefn));

    itemsLength = lengthOfArrayLike(items);
    index = 0;

    while (index < itemsLength) array[index] = items[index++];
    while (index < arrayLength) deletePropertyOrThrow(array, index++);

    return array;
  }
});

},{"../internals/a-callable":250,"../internals/array-method-is-strict":261,"../internals/array-sort":265,"../internals/delete-property-or-throw":282,"../internals/engine-ff-version":288,"../internals/engine-is-ie-or-edge":291,"../internals/engine-v8-version":297,"../internals/engine-webkit-version":298,"../internals/export":304,"../internals/fails":305,"../internals/function-uncurry-this":314,"../internals/length-of-array-like":348,"../internals/to-object":399,"../internals/to-string":403}],427:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var toObject = require('../internals/to-object');
var toAbsoluteIndex = require('../internals/to-absolute-index');
var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');
var lengthOfArrayLike = require('../internals/length-of-array-like');
var setArrayLength = require('../internals/array-set-length');
var doesNotExceedSafeInteger = require('../internals/does-not-exceed-safe-integer');
var arraySpeciesCreate = require('../internals/array-species-create');
var createProperty = require('../internals/create-property');
var deletePropertyOrThrow = require('../internals/delete-property-or-throw');
var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');

var max = Math.max;
var min = Math.min;

// `Array.prototype.splice` method
// https://tc39.es/ecma262/#sec-array.prototype.splice
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  splice: function splice(start, deleteCount /* , ...items */) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
    }
    doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];
        else deletePropertyOrThrow(O, to);
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) deletePropertyOrThrow(O, k - 1);
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];
        else deletePropertyOrThrow(O, to);
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    setArrayLength(O, len - actualDeleteCount + insertCount);
    return A;
  }
});

},{"../internals/array-method-has-species-support":260,"../internals/array-set-length":262,"../internals/array-species-create":267,"../internals/create-property":278,"../internals/delete-property-or-throw":282,"../internals/does-not-exceed-safe-integer":286,"../internals/export":304,"../internals/length-of-array-like":348,"../internals/to-absolute-index":395,"../internals/to-integer-or-infinity":397,"../internals/to-object":399}],428:[function(require,module,exports){
// empty

},{}],429:[function(require,module,exports){
// TODO: Remove from `core-js@4`
var $ = require('../internals/export');
var bind = require('../internals/function-bind');

// `Function.prototype.bind` method
// https://tc39.es/ecma262/#sec-function.prototype.bind
// eslint-disable-next-line es/no-function-prototype-bind -- detection
$({ target: 'Function', proto: true, forced: Function.bind !== bind }, {
  bind: bind
});

},{"../internals/export":304,"../internals/function-bind":309}],430:[function(require,module,exports){
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var apply = require('../internals/function-apply');
var call = require('../internals/function-call');
var uncurryThis = require('../internals/function-uncurry-this');
var fails = require('../internals/fails');
var isCallable = require('../internals/is-callable');
var isSymbol = require('../internals/is-symbol');
var arraySlice = require('../internals/array-slice');
var getReplacerFunction = require('../internals/get-json-replacer-function');
var NATIVE_SYMBOL = require('../internals/symbol-constructor-detection');

var $String = String;
var $stringify = getBuiltIn('JSON', 'stringify');
var exec = uncurryThis(/./.exec);
var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var replace = uncurryThis(''.replace);
var numberToString = uncurryThis(1.0.toString);

var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;

var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function () {
  var symbol = getBuiltIn('Symbol')();
  // MS Edge converts symbol values to JSON as {}
  return $stringify([symbol]) != '[null]'
    // WebKit converts symbol values to JSON as null
    || $stringify({ a: symbol }) != '{}'
    // V8 throws on boxed symbols
    || $stringify(Object(symbol)) != '{}';
});

// https://github.com/tc39/proposal-well-formed-stringify
var ILL_FORMED_UNICODE = fails(function () {
  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
    || $stringify('\uDEAD') !== '"\\udead"';
});

var stringifyWithSymbolsFix = function (it, replacer) {
  var args = arraySlice(arguments);
  var $replacer = getReplacerFunction(replacer);
  if (!isCallable($replacer) && (it === undefined || isSymbol(it))) return; // IE8 returns string on undefined
  args[1] = function (key, value) {
    // some old implementations (like WebKit) could pass numbers as keys
    if (isCallable($replacer)) value = call($replacer, this, $String(key), value);
    if (!isSymbol(value)) return value;
  };
  return apply($stringify, null, args);
};

var fixIllFormed = function (match, offset, string) {
  var prev = charAt(string, offset - 1);
  var next = charAt(string, offset + 1);
  if ((exec(low, match) && !exec(hi, next)) || (exec(hi, match) && !exec(low, prev))) {
    return '\\u' + numberToString(charCodeAt(match, 0), 16);
  } return match;
};

if ($stringify) {
  // `JSON.stringify` method
  // https://tc39.es/ecma262/#sec-json.stringify
  $({ target: 'JSON', stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = arraySlice(arguments);
      var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
      return ILL_FORMED_UNICODE && typeof result == 'string' ? replace(result, tester, fixIllFormed) : result;
    }
  });
}

},{"../internals/array-slice":264,"../internals/export":304,"../internals/fails":305,"../internals/function-apply":306,"../internals/function-call":310,"../internals/function-uncurry-this":314,"../internals/get-built-in":315,"../internals/get-json-replacer-function":318,"../internals/is-callable":332,"../internals/is-symbol":341,"../internals/symbol-constructor-detection":391}],431:[function(require,module,exports){
var global = require('../internals/global');
var setToStringTag = require('../internals/set-to-string-tag');

// JSON[@@toStringTag] property
// https://tc39.es/ecma262/#sec-json-@@tostringtag
setToStringTag(global.JSON, 'JSON', true);

},{"../internals/global":320,"../internals/set-to-string-tag":381}],432:[function(require,module,exports){
arguments[4][428][0].apply(exports,arguments)
},{"dup":428}],433:[function(require,module,exports){
var $ = require('../internals/export');
var isIntegralNumber = require('../internals/is-integral-number');

// `Number.isInteger` method
// https://tc39.es/ecma262/#sec-number.isinteger
$({ target: 'Number', stat: true }, {
  isInteger: isIntegralNumber
});

},{"../internals/export":304,"../internals/is-integral-number":336}],434:[function(require,module,exports){
var $ = require('../internals/export');
var parseFloat = require('../internals/number-parse-float');

// `Number.parseFloat` method
// https://tc39.es/ecma262/#sec-number.parseFloat
// eslint-disable-next-line es/no-number-parsefloat -- required for testing
$({ target: 'Number', stat: true, forced: Number.parseFloat != parseFloat }, {
  parseFloat: parseFloat
});

},{"../internals/export":304,"../internals/number-parse-float":354}],435:[function(require,module,exports){
var $ = require('../internals/export');
var assign = require('../internals/object-assign');

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
// eslint-disable-next-line es/no-object-assign -- required for testing
$({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign }, {
  assign: assign
});

},{"../internals/export":304,"../internals/object-assign":355}],436:[function(require,module,exports){
// TODO: Remove from `core-js@4`
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var create = require('../internals/object-create');

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  create: create
});

},{"../internals/descriptors":283,"../internals/export":304,"../internals/object-create":356}],437:[function(require,module,exports){
var $ = require('../internals/export');
var DESCRIPTORS = require('../internals/descriptors');
var defineProperty = require('../internals/object-define-property').f;

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
// eslint-disable-next-line es/no-object-defineproperty -- safe
$({ target: 'Object', stat: true, forced: Object.defineProperty !== defineProperty, sham: !DESCRIPTORS }, {
  defineProperty: defineProperty
});

},{"../internals/descriptors":283,"../internals/export":304,"../internals/object-define-property":358}],438:[function(require,module,exports){
var $ = require('../internals/export');
var fails = require('../internals/fails');
var toIndexedObject = require('../internals/to-indexed-object');
var nativeGetOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var DESCRIPTORS = require('../internals/descriptors');

var FORCED = !DESCRIPTORS || fails(function () { nativeGetOwnPropertyDescriptor(1); });

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});

},{"../internals/descriptors":283,"../internals/export":304,"../internals/fails":305,"../internals/object-get-own-property-descriptor":359,"../internals/to-indexed-object":396}],439:[function(require,module,exports){
var $ = require('../internals/export');
var NATIVE_SYMBOL = require('../internals/symbol-constructor-detection');
var fails = require('../internals/fails');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var toObject = require('../internals/to-object');

// V8 ~ Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FORCED = !NATIVE_SYMBOL || fails(function () { getOwnPropertySymbolsModule.f(1); });

// `Object.getOwnPropertySymbols` method
// https://tc39.es/ecma262/#sec-object.getownpropertysymbols
$({ target: 'Object', stat: true, forced: FORCED }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
  }
});

},{"../internals/export":304,"../internals/fails":305,"../internals/object-get-own-property-symbols":362,"../internals/symbol-constructor-detection":391,"../internals/to-object":399}],440:[function(require,module,exports){
var $ = require('../internals/export');
var fails = require('../internals/fails');
var toObject = require('../internals/to-object');
var nativeGetPrototypeOf = require('../internals/object-get-prototype-of');
var CORRECT_PROTOTYPE_GETTER = require('../internals/correct-prototype-getter');

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetPrototypeOf(1); });

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});


},{"../internals/correct-prototype-getter":274,"../internals/export":304,"../internals/fails":305,"../internals/object-get-prototype-of":363,"../internals/to-object":399}],441:[function(require,module,exports){
var $ = require('../internals/export');
var toObject = require('../internals/to-object');
var nativeKeys = require('../internals/object-keys');
var fails = require('../internals/fails');

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});

},{"../internals/export":304,"../internals/fails":305,"../internals/object-keys":366,"../internals/to-object":399}],442:[function(require,module,exports){
var $ = require('../internals/export');
var setPrototypeOf = require('../internals/object-set-prototype-of');

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
$({ target: 'Object', stat: true }, {
  setPrototypeOf: setPrototypeOf
});

},{"../internals/export":304,"../internals/object-set-prototype-of":368}],443:[function(require,module,exports){
arguments[4][428][0].apply(exports,arguments)
},{"dup":428}],444:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');
var iterate = require('../internals/iterate');
var PROMISE_STATICS_INCORRECT_ITERATION = require('../internals/promise-statics-incorrect-iteration');

// `Promise.allSettled` method
// https://tc39.es/ecma262/#sec-promise.allsettled
$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
  allSettled: function allSettled(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var promiseResolve = aCallable(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        remaining++;
        call(promiseResolve, C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = { status: 'fulfilled', value: value };
          --remaining || resolve(values);
        }, function (error) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = { status: 'rejected', reason: error };
          --remaining || resolve(values);
        });
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

},{"../internals/a-callable":250,"../internals/export":304,"../internals/function-call":310,"../internals/iterate":342,"../internals/new-promise-capability":351,"../internals/perform":373,"../internals/promise-statics-incorrect-iteration":377}],445:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');
var iterate = require('../internals/iterate');
var PROMISE_STATICS_INCORRECT_ITERATION = require('../internals/promise-statics-incorrect-iteration');

// `Promise.all` method
// https://tc39.es/ecma262/#sec-promise.all
$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aCallable(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        remaining++;
        call($promiseResolve, C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

},{"../internals/a-callable":250,"../internals/export":304,"../internals/function-call":310,"../internals/iterate":342,"../internals/new-promise-capability":351,"../internals/perform":373,"../internals/promise-statics-incorrect-iteration":377}],446:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var getBuiltIn = require('../internals/get-built-in');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');
var iterate = require('../internals/iterate');
var PROMISE_STATICS_INCORRECT_ITERATION = require('../internals/promise-statics-incorrect-iteration');

var PROMISE_ANY_ERROR = 'No one promise resolved';

// `Promise.any` method
// https://tc39.es/ecma262/#sec-promise.any
$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
  any: function any(iterable) {
    var C = this;
    var AggregateError = getBuiltIn('AggregateError');
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var promiseResolve = aCallable(C.resolve);
      var errors = [];
      var counter = 0;
      var remaining = 1;
      var alreadyResolved = false;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyRejected = false;
        remaining++;
        call(promiseResolve, C, promise).then(function (value) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyResolved = true;
          resolve(value);
        }, function (error) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyRejected = true;
          errors[index] = error;
          --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
        });
      });
      --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

},{"../internals/a-callable":250,"../internals/export":304,"../internals/function-call":310,"../internals/get-built-in":315,"../internals/iterate":342,"../internals/new-promise-capability":351,"../internals/perform":373,"../internals/promise-statics-incorrect-iteration":377}],447:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var FORCED_PROMISE_CONSTRUCTOR = require('../internals/promise-constructor-detection').CONSTRUCTOR;
var NativePromiseConstructor = require('../internals/promise-native-constructor');
var getBuiltIn = require('../internals/get-built-in');
var isCallable = require('../internals/is-callable');
var defineBuiltIn = require('../internals/define-built-in');

var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;

// `Promise.prototype.catch` method
// https://tc39.es/ecma262/#sec-promise.prototype.catch
$({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
  'catch': function (onRejected) {
    return this.then(undefined, onRejected);
  }
});

// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
if (!IS_PURE && isCallable(NativePromiseConstructor)) {
  var method = getBuiltIn('Promise').prototype['catch'];
  if (NativePromisePrototype['catch'] !== method) {
    defineBuiltIn(NativePromisePrototype, 'catch', method, { unsafe: true });
  }
}

},{"../internals/define-built-in":280,"../internals/export":304,"../internals/get-built-in":315,"../internals/is-callable":332,"../internals/is-pure":339,"../internals/promise-constructor-detection":374,"../internals/promise-native-constructor":375}],448:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var IS_NODE = require('../internals/engine-is-node');
var global = require('../internals/global');
var call = require('../internals/function-call');
var defineBuiltIn = require('../internals/define-built-in');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var setToStringTag = require('../internals/set-to-string-tag');
var setSpecies = require('../internals/set-species');
var aCallable = require('../internals/a-callable');
var isCallable = require('../internals/is-callable');
var isObject = require('../internals/is-object');
var anInstance = require('../internals/an-instance');
var speciesConstructor = require('../internals/species-constructor');
var task = require('../internals/task').set;
var microtask = require('../internals/microtask');
var hostReportErrors = require('../internals/host-report-errors');
var perform = require('../internals/perform');
var Queue = require('../internals/queue');
var InternalStateModule = require('../internals/internal-state');
var NativePromiseConstructor = require('../internals/promise-native-constructor');
var PromiseConstructorDetection = require('../internals/promise-constructor-detection');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');

var PROMISE = 'Promise';
var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var setInternalState = InternalStateModule.set;
var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
var PromiseConstructor = NativePromiseConstructor;
var PromisePrototype = NativePromisePrototype;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;

var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;

var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && isCallable(then = it.then) ? then : false;
};

var callReaction = function (reaction, state) {
  var value = state.value;
  var ok = state.state == FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve = reaction.resolve;
  var reject = reaction.reject;
  var domain = reaction.domain;
  var result, then, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true) result = value;
      else {
        if (domain) domain.enter();
        result = handler(value); // can throw
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject(TypeError('Promise-chain cycle'));
      } else if (then = isThenable(result)) {
        call(then, result, resolve, reject);
      } else resolve(result);
    } else reject(value);
  } catch (error) {
    if (domain && !exited) domain.exit();
    reject(error);
  }
};

var notify = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  microtask(function () {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global['on' + name])) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (state) {
  call(task, global, function () {
    var promise = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (state) {
  call(task, global, function () {
    var promise = state.facade;
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};

var internalReject = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};

var internalResolve = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          call(then, value,
            bind(internalResolve, wrapper, state),
            bind(internalReject, wrapper, state)
          );
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED_PROMISE_CONSTRUCTOR) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromisePrototype);
    aCallable(executor);
    call(Internal, this);
    var state = getInternalPromiseState(this);
    try {
      executor(bind(internalResolve, state), bind(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };

  PromisePrototype = PromiseConstructor.prototype;

  // eslint-disable-next-line no-unused-vars -- required for `.length`
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue(),
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };

  // `Promise.prototype.then` method
  // https://tc39.es/ecma262/#sec-promise.prototype.then
  Internal.prototype = defineBuiltIn(PromisePrototype, 'then', function then(onFulfilled, onRejected) {
    var state = getInternalPromiseState(this);
    var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
    state.parent = true;
    reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
    reaction.fail = isCallable(onRejected) && onRejected;
    reaction.domain = IS_NODE ? process.domain : undefined;
    if (state.state == PENDING) state.reactions.add(reaction);
    else microtask(function () {
      callReaction(reaction, state);
    });
    return reaction.promise;
  });

  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalPromiseState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, state);
    this.reject = bind(internalReject, state);
  };

  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
    nativeThen = NativePromisePrototype.then;

    if (!NATIVE_PROMISE_SUBCLASSING) {
      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
      defineBuiltIn(NativePromisePrototype, 'then', function then(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function (resolve, reject) {
          call(nativeThen, that, resolve, reject);
        }).then(onFulfilled, onRejected);
      // https://github.com/zloirock/core-js/issues/640
      }, { unsafe: true });
    }

    // make `.constructor === Promise` work for native promise-based APIs
    try {
      delete NativePromisePrototype.constructor;
    } catch (error) { /* empty */ }

    // make `instanceof Promise` work for native promise-based APIs
    if (setPrototypeOf) {
      setPrototypeOf(NativePromisePrototype, PromisePrototype);
    }
  }
}

$({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);

},{"../internals/a-callable":250,"../internals/an-instance":254,"../internals/define-built-in":280,"../internals/engine-is-node":294,"../internals/export":304,"../internals/function-call":310,"../internals/global":320,"../internals/host-report-errors":323,"../internals/internal-state":329,"../internals/is-callable":332,"../internals/is-object":338,"../internals/is-pure":339,"../internals/microtask":350,"../internals/new-promise-capability":351,"../internals/object-set-prototype-of":368,"../internals/perform":373,"../internals/promise-constructor-detection":374,"../internals/promise-native-constructor":375,"../internals/queue":378,"../internals/set-species":380,"../internals/set-to-string-tag":381,"../internals/species-constructor":385,"../internals/task":394}],449:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var NativePromiseConstructor = require('../internals/promise-native-constructor');
var fails = require('../internals/fails');
var getBuiltIn = require('../internals/get-built-in');
var isCallable = require('../internals/is-callable');
var speciesConstructor = require('../internals/species-constructor');
var promiseResolve = require('../internals/promise-resolve');
var defineBuiltIn = require('../internals/define-built-in');

var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;

// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
var NON_GENERIC = !!NativePromiseConstructor && fails(function () {
  // eslint-disable-next-line unicorn/no-thenable -- required for testing
  NativePromisePrototype['finally'].call({ then: function () { /* empty */ } }, function () { /* empty */ });
});

// `Promise.prototype.finally` method
// https://tc39.es/ecma262/#sec-promise.prototype.finally
$({ target: 'Promise', proto: true, real: true, forced: NON_GENERIC }, {
  'finally': function (onFinally) {
    var C = speciesConstructor(this, getBuiltIn('Promise'));
    var isFunction = isCallable(onFinally);
    return this.then(
      isFunction ? function (x) {
        return promiseResolve(C, onFinally()).then(function () { return x; });
      } : onFinally,
      isFunction ? function (e) {
        return promiseResolve(C, onFinally()).then(function () { throw e; });
      } : onFinally
    );
  }
});

// makes sure that native promise-based APIs `Promise#finally` properly works with patched `Promise#then`
if (!IS_PURE && isCallable(NativePromiseConstructor)) {
  var method = getBuiltIn('Promise').prototype['finally'];
  if (NativePromisePrototype['finally'] !== method) {
    defineBuiltIn(NativePromisePrototype, 'finally', method, { unsafe: true });
  }
}

},{"../internals/define-built-in":280,"../internals/export":304,"../internals/fails":305,"../internals/get-built-in":315,"../internals/is-callable":332,"../internals/is-pure":339,"../internals/promise-native-constructor":375,"../internals/promise-resolve":376,"../internals/species-constructor":385}],450:[function(require,module,exports){
// TODO: Remove this module from `core-js@4` since it's split to modules listed below
require('../modules/es.promise.constructor');
require('../modules/es.promise.all');
require('../modules/es.promise.catch');
require('../modules/es.promise.race');
require('../modules/es.promise.reject');
require('../modules/es.promise.resolve');

},{"../modules/es.promise.all":445,"../modules/es.promise.catch":447,"../modules/es.promise.constructor":448,"../modules/es.promise.race":451,"../modules/es.promise.reject":452,"../modules/es.promise.resolve":453}],451:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var call = require('../internals/function-call');
var aCallable = require('../internals/a-callable');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');
var iterate = require('../internals/iterate');
var PROMISE_STATICS_INCORRECT_ITERATION = require('../internals/promise-statics-incorrect-iteration');

// `Promise.race` method
// https://tc39.es/ecma262/#sec-promise.race
$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aCallable(C.resolve);
      iterate(iterable, function (promise) {
        call($promiseResolve, C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

},{"../internals/a-callable":250,"../internals/export":304,"../internals/function-call":310,"../internals/iterate":342,"../internals/new-promise-capability":351,"../internals/perform":373,"../internals/promise-statics-incorrect-iteration":377}],452:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var call = require('../internals/function-call');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var FORCED_PROMISE_CONSTRUCTOR = require('../internals/promise-constructor-detection').CONSTRUCTOR;

// `Promise.reject` method
// https://tc39.es/ecma262/#sec-promise.reject
$({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
  reject: function reject(r) {
    var capability = newPromiseCapabilityModule.f(this);
    call(capability.reject, undefined, r);
    return capability.promise;
  }
});

},{"../internals/export":304,"../internals/function-call":310,"../internals/new-promise-capability":351,"../internals/promise-constructor-detection":374}],453:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var IS_PURE = require('../internals/is-pure');
var NativePromiseConstructor = require('../internals/promise-native-constructor');
var FORCED_PROMISE_CONSTRUCTOR = require('../internals/promise-constructor-detection').CONSTRUCTOR;
var promiseResolve = require('../internals/promise-resolve');

var PromiseConstructorWrapper = getBuiltIn('Promise');
var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;

// `Promise.resolve` method
// https://tc39.es/ecma262/#sec-promise.resolve
$({ target: 'Promise', stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
  resolve: function resolve(x) {
    return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x);
  }
});

},{"../internals/export":304,"../internals/get-built-in":315,"../internals/is-pure":339,"../internals/promise-constructor-detection":374,"../internals/promise-native-constructor":375,"../internals/promise-resolve":376}],454:[function(require,module,exports){
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var apply = require('../internals/function-apply');
var bind = require('../internals/function-bind');
var aConstructor = require('../internals/a-constructor');
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var create = require('../internals/object-create');
var fails = require('../internals/fails');

var nativeConstruct = getBuiltIn('Reflect', 'construct');
var ObjectPrototype = Object.prototype;
var push = [].push;

// `Reflect.construct` method
// https://tc39.es/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
});

var ARGS_BUG = !fails(function () {
  nativeConstruct(function () { /* empty */ });
});

var FORCED = NEW_TARGET_BUG || ARGS_BUG;

$({ target: 'Reflect', stat: true, forced: FORCED, sham: FORCED }, {
  construct: function construct(Target, args /* , newTarget */) {
    aConstructor(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      apply(push, $args, args);
      return new (apply(bind, Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : ObjectPrototype);
    var result = apply(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"../internals/a-constructor":251,"../internals/an-object":255,"../internals/export":304,"../internals/fails":305,"../internals/function-apply":306,"../internals/function-bind":309,"../internals/get-built-in":315,"../internals/is-object":338,"../internals/object-create":356}],455:[function(require,module,exports){
var $ = require('../internals/export');
var call = require('../internals/function-call');
var isObject = require('../internals/is-object');
var anObject = require('../internals/an-object');
var isDataDescriptor = require('../internals/is-data-descriptor');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var getPrototypeOf = require('../internals/object-get-prototype-of');

// `Reflect.get` method
// https://tc39.es/ecma262/#sec-reflect.get
function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject(target) === receiver) return target[propertyKey];
  descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey);
  if (descriptor) return isDataDescriptor(descriptor)
    ? descriptor.value
    : descriptor.get === undefined ? undefined : call(descriptor.get, receiver);
  if (isObject(prototype = getPrototypeOf(target))) return get(prototype, propertyKey, receiver);
}

$({ target: 'Reflect', stat: true }, {
  get: get
});

},{"../internals/an-object":255,"../internals/export":304,"../internals/function-call":310,"../internals/is-data-descriptor":334,"../internals/is-object":338,"../internals/object-get-own-property-descriptor":359,"../internals/object-get-prototype-of":363}],456:[function(require,module,exports){
arguments[4][428][0].apply(exports,arguments)
},{"dup":428}],457:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this');
var notARegExp = require('../internals/not-a-regexp');
var requireObjectCoercible = require('../internals/require-object-coercible');
var toString = require('../internals/to-string');
var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');

var stringIndexOf = uncurryThis(''.indexOf);

// `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~stringIndexOf(
      toString(requireObjectCoercible(this)),
      toString(notARegExp(searchString)),
      arguments.length > 1 ? arguments[1] : undefined
    );
  }
});

},{"../internals/correct-is-regexp-logic":273,"../internals/export":304,"../internals/function-uncurry-this":314,"../internals/not-a-regexp":353,"../internals/require-object-coercible":379,"../internals/to-string":403}],458:[function(require,module,exports){
'use strict';
var charAt = require('../internals/string-multibyte').charAt;
var toString = require('../internals/to-string');
var InternalStateModule = require('../internals/internal-state');
var defineIterator = require('../internals/iterator-define');
var createIterResultObject = require('../internals/create-iter-result-object');

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: toString(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return createIterResultObject(undefined, true);
  point = charAt(string, index);
  state.index += point.length;
  return createIterResultObject(point, false);
});

},{"../internals/create-iter-result-object":275,"../internals/internal-state":329,"../internals/iterator-define":345,"../internals/string-multibyte":386,"../internals/to-string":403}],459:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $padStart = require('../internals/string-pad').start;
var WEBKIT_BUG = require('../internals/string-pad-webkit-bug');

// `String.prototype.padStart` method
// https://tc39.es/ecma262/#sec-string.prototype.padstart
$({ target: 'String', proto: true, forced: WEBKIT_BUG }, {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"../internals/export":304,"../internals/string-pad":388,"../internals/string-pad-webkit-bug":387}],460:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var uncurryThis = require('../internals/function-uncurry-this-clause');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var toLength = require('../internals/to-length');
var toString = require('../internals/to-string');
var notARegExp = require('../internals/not-a-regexp');
var requireObjectCoercible = require('../internals/require-object-coercible');
var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');
var IS_PURE = require('../internals/is-pure');

// eslint-disable-next-line es/no-string-prototype-startswith -- safe
var nativeStartsWith = uncurryThis(''.startsWith);
var stringSlice = uncurryThis(''.slice);
var min = Math.min;

var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith');
// https://github.com/zloirock/core-js/pull/702
var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
  var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');
  return descriptor && !descriptor.writable;
}();

// `String.prototype.startsWith` method
// https://tc39.es/ecma262/#sec-string.prototype.startswith
$({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = toString(requireObjectCoercible(this));
    notARegExp(searchString);
    var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = toString(searchString);
    return nativeStartsWith
      ? nativeStartsWith(that, search, index)
      : stringSlice(that, index, index + search.length) === search;
  }
});

},{"../internals/correct-is-regexp-logic":273,"../internals/export":304,"../internals/function-uncurry-this-clause":313,"../internals/is-pure":339,"../internals/not-a-regexp":353,"../internals/object-get-own-property-descriptor":359,"../internals/require-object-coercible":379,"../internals/to-length":398,"../internals/to-string":403}],461:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

// `Symbol.asyncIterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.asynciterator
defineWellKnownSymbol('asyncIterator');

},{"../internals/well-known-symbol-define":410}],462:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var global = require('../internals/global');
var call = require('../internals/function-call');
var uncurryThis = require('../internals/function-uncurry-this');
var IS_PURE = require('../internals/is-pure');
var DESCRIPTORS = require('../internals/descriptors');
var NATIVE_SYMBOL = require('../internals/symbol-constructor-detection');
var fails = require('../internals/fails');
var hasOwn = require('../internals/has-own-property');
var isPrototypeOf = require('../internals/object-is-prototype-of');
var anObject = require('../internals/an-object');
var toIndexedObject = require('../internals/to-indexed-object');
var toPropertyKey = require('../internals/to-property-key');
var $toString = require('../internals/to-string');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var nativeObjectCreate = require('../internals/object-create');
var objectKeys = require('../internals/object-keys');
var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
var getOwnPropertyNamesExternal = require('../internals/object-get-own-property-names-external');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var definePropertyModule = require('../internals/object-define-property');
var definePropertiesModule = require('../internals/object-define-properties');
var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
var defineBuiltIn = require('../internals/define-built-in');
var defineBuiltInAccessor = require('../internals/define-built-in-accessor');
var shared = require('../internals/shared');
var sharedKey = require('../internals/shared-key');
var hiddenKeys = require('../internals/hidden-keys');
var uid = require('../internals/uid');
var wellKnownSymbol = require('../internals/well-known-symbol');
var wrappedWellKnownSymbolModule = require('../internals/well-known-symbol-wrapped');
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');
var defineSymbolToPrimitive = require('../internals/symbol-define-to-primitive');
var setToStringTag = require('../internals/set-to-string-tag');
var InternalStateModule = require('../internals/internal-state');
var $forEach = require('../internals/array-iteration').forEach;

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';

var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);

var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var TypeError = global.TypeError;
var QObject = global.QObject;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var push = uncurryThis([].push);

var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var WellKnownSymbolsStore = shared('wks');

// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPropertyKey(P);
  anObject(Attributes);
  if (hasOwn(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPropertyKey(V);
  var enumerable = call(nativePropertyIsEnumerable, this, P);
  if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P]
    ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPropertyKey(P);
  if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
  });
  return result;
};

var $getOwnPropertySymbols = function (O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
      push(result, AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (isPrototypeOf(SymbolPrototype, this)) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
      if (hasOwn(this, HIDDEN) && hasOwn(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  SymbolPrototype = $Symbol[PROTOTYPE];

  defineBuiltIn(SymbolPrototype, 'toString', function toString() {
    return getInternalState(this).tag;
  });

  defineBuiltIn($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    defineBuiltInAccessor(SymbolPrototype, 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      defineBuiltIn(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames
});

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;

},{"../internals/an-object":255,"../internals/array-iteration":259,"../internals/create-property-descriptor":277,"../internals/define-built-in":280,"../internals/define-built-in-accessor":279,"../internals/descriptors":283,"../internals/export":304,"../internals/fails":305,"../internals/function-call":310,"../internals/function-uncurry-this":314,"../internals/global":320,"../internals/has-own-property":321,"../internals/hidden-keys":322,"../internals/internal-state":329,"../internals/is-pure":339,"../internals/object-create":356,"../internals/object-define-properties":357,"../internals/object-define-property":358,"../internals/object-get-own-property-descriptor":359,"../internals/object-get-own-property-names":361,"../internals/object-get-own-property-names-external":360,"../internals/object-get-own-property-symbols":362,"../internals/object-is-prototype-of":364,"../internals/object-keys":366,"../internals/object-property-is-enumerable":367,"../internals/set-to-string-tag":381,"../internals/shared":384,"../internals/shared-key":382,"../internals/symbol-constructor-detection":391,"../internals/symbol-define-to-primitive":392,"../internals/to-indexed-object":396,"../internals/to-property-key":401,"../internals/to-string":403,"../internals/uid":405,"../internals/well-known-symbol":412,"../internals/well-known-symbol-define":410,"../internals/well-known-symbol-wrapped":411}],463:[function(require,module,exports){
arguments[4][428][0].apply(exports,arguments)
},{"dup":428}],464:[function(require,module,exports){
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var hasOwn = require('../internals/has-own-property');
var toString = require('../internals/to-string');
var shared = require('../internals/shared');
var NATIVE_SYMBOL_REGISTRY = require('../internals/symbol-registry-detection');

var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.for` method
// https://tc39.es/ecma262/#sec-symbol.for
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  'for': function (key) {
    var string = toString(key);
    if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = getBuiltIn('Symbol')(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  }
});

},{"../internals/export":304,"../internals/get-built-in":315,"../internals/has-own-property":321,"../internals/shared":384,"../internals/symbol-registry-detection":393,"../internals/to-string":403}],465:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

// `Symbol.hasInstance` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.hasinstance
defineWellKnownSymbol('hasInstance');

},{"../internals/well-known-symbol-define":410}],466:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

// `Symbol.isConcatSpreadable` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.isconcatspreadable
defineWellKnownSymbol('isConcatSpreadable');

},{"../internals/well-known-symbol-define":410}],467:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

// `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');

},{"../internals/well-known-symbol-define":410}],468:[function(require,module,exports){
// TODO: Remove this module from `core-js@4` since it's split to modules listed below
require('../modules/es.symbol.constructor');
require('../modules/es.symbol.for');
require('../modules/es.symbol.key-for');
require('../modules/es.json.stringify');
require('../modules/es.object.get-own-property-symbols');

},{"../modules/es.json.stringify":430,"../modules/es.object.get-own-property-symbols":439,"../modules/es.symbol.constructor":462,"../modules/es.symbol.for":464,"../modules/es.symbol.key-for":469}],469:[function(require,module,exports){
var $ = require('../internals/export');
var hasOwn = require('../internals/has-own-property');
var isSymbol = require('../internals/is-symbol');
var tryToString = require('../internals/try-to-string');
var shared = require('../internals/shared');
var NATIVE_SYMBOL_REGISTRY = require('../internals/symbol-registry-detection');

var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.keyFor` method
// https://tc39.es/ecma262/#sec-symbol.keyfor
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(tryToString(sym) + ' is not a symbol');
    if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  }
});

},{"../internals/export":304,"../internals/has-own-property":321,"../internals/is-symbol":341,"../internals/shared":384,"../internals/symbol-registry-detection":393,"../internals/try-to-string":404}],470:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

// `Symbol.matchAll` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.matchall
defineWellKnownSymbol('matchAll');

},{"../internals/well-known-symbol-define":410}],471:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

// `Symbol.match` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.match
defineWellKnownSymbol('match');

},{"../internals/well-known-symbol-define":410}],472:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

// `Symbol.replace` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.replace
defineWellKnownSymbol('replace');

},{"../internals/well-known-symbol-define":410}],473:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

// `Symbol.search` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.search
defineWellKnownSymbol('search');

},{"../internals/well-known-symbol-define":410}],474:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

// `Symbol.species` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.species
defineWellKnownSymbol('species');

},{"../internals/well-known-symbol-define":410}],475:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

// `Symbol.split` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.split
defineWellKnownSymbol('split');

},{"../internals/well-known-symbol-define":410}],476:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');
var defineSymbolToPrimitive = require('../internals/symbol-define-to-primitive');

// `Symbol.toPrimitive` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.toprimitive
defineWellKnownSymbol('toPrimitive');

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();

},{"../internals/symbol-define-to-primitive":392,"../internals/well-known-symbol-define":410}],477:[function(require,module,exports){
var getBuiltIn = require('../internals/get-built-in');
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');
var setToStringTag = require('../internals/set-to-string-tag');

// `Symbol.toStringTag` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.tostringtag
defineWellKnownSymbol('toStringTag');

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag(getBuiltIn('Symbol'), 'Symbol');

},{"../internals/get-built-in":315,"../internals/set-to-string-tag":381,"../internals/well-known-symbol-define":410}],478:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

// `Symbol.unscopables` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.unscopables
defineWellKnownSymbol('unscopables');

},{"../internals/well-known-symbol-define":410}],479:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

// `Symbol.asyncDispose` well-known symbol
// https://github.com/tc39/proposal-async-explicit-resource-management
defineWellKnownSymbol('asyncDispose');

},{"../internals/well-known-symbol-define":410}],480:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

// `Symbol.dispose` well-known symbol
// https://github.com/tc39/proposal-explicit-resource-management
defineWellKnownSymbol('dispose');

},{"../internals/well-known-symbol-define":410}],481:[function(require,module,exports){
var $ = require('../internals/export');
var getBuiltIn = require('../internals/get-built-in');
var uncurryThis = require('../internals/function-uncurry-this');

var Symbol = getBuiltIn('Symbol');
var keyFor = Symbol.keyFor;
var thisSymbolValue = uncurryThis(Symbol.prototype.valueOf);

// `Symbol.isRegistered` method
// https://tc39.es/proposal-symbol-predicates/#sec-symbol-isregistered
$({ target: 'Symbol', stat: true }, {
  isRegistered: function isRegistered(value) {
    try {
      return keyFor(thisSymbolValue(value)) !== undefined;
    } catch (error) {
      return false;
    }
  }
});

},{"../internals/export":304,"../internals/function-uncurry-this":314,"../internals/get-built-in":315}],482:[function(require,module,exports){
var $ = require('../internals/export');
var shared = require('../internals/shared');
var getBuiltIn = require('../internals/get-built-in');
var uncurryThis = require('../internals/function-uncurry-this');
var isSymbol = require('../internals/is-symbol');
var wellKnownSymbol = require('../internals/well-known-symbol');

var Symbol = getBuiltIn('Symbol');
var $isWellKnown = Symbol.isWellKnown;
var getOwnPropertyNames = getBuiltIn('Object', 'getOwnPropertyNames');
var thisSymbolValue = uncurryThis(Symbol.prototype.valueOf);
var WellKnownSymbolsStore = shared('wks');

for (var i = 0, symbolKeys = getOwnPropertyNames(Symbol), symbolKeysLength = symbolKeys.length; i < symbolKeysLength; i++) {
  // some old engines throws on access to some keys like `arguments` or `caller`
  try {
    var symbolKey = symbolKeys[i];
    if (isSymbol(Symbol[symbolKey])) wellKnownSymbol(symbolKey);
  } catch (error) { /* empty */ }
}

// `Symbol.isWellKnown` method
// https://tc39.es/proposal-symbol-predicates/#sec-symbol-iswellknown
// We should patch it for newly added well-known symbols. If it's not required, this module just will not be injected
$({ target: 'Symbol', stat: true, forced: true }, {
  isWellKnown: function isWellKnown(value) {
    if ($isWellKnown && $isWellKnown(value)) return true;
    try {
      var symbol = thisSymbolValue(value);
      for (var j = 0, keys = getOwnPropertyNames(WellKnownSymbolsStore), keysLength = keys.length; j < keysLength; j++) {
        if (WellKnownSymbolsStore[keys[j]] == symbol) return true;
      }
    } catch (error) { /* empty */ }
    return false;
  }
});

},{"../internals/export":304,"../internals/function-uncurry-this":314,"../internals/get-built-in":315,"../internals/is-symbol":341,"../internals/shared":384,"../internals/well-known-symbol":412}],483:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

// `Symbol.matcher` well-known symbol
// https://github.com/tc39/proposal-pattern-matching
defineWellKnownSymbol('matcher');

},{"../internals/well-known-symbol-define":410}],484:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

// `Symbol.metadataKey` well-known symbol
// https://github.com/tc39/proposal-decorator-metadata
defineWellKnownSymbol('metadataKey');

},{"../internals/well-known-symbol-define":410}],485:[function(require,module,exports){
// TODO: Remove from `core-js@4`
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

// `Symbol.metadata` well-known symbol
// https://github.com/tc39/proposal-decorators
defineWellKnownSymbol('metadata');

},{"../internals/well-known-symbol-define":410}],486:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

// `Symbol.observable` well-known symbol
// https://github.com/tc39/proposal-observable
defineWellKnownSymbol('observable');

},{"../internals/well-known-symbol-define":410}],487:[function(require,module,exports){
// TODO: remove from `core-js@4`
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

// `Symbol.patternMatch` well-known symbol
// https://github.com/tc39/proposal-pattern-matching
defineWellKnownSymbol('patternMatch');

},{"../internals/well-known-symbol-define":410}],488:[function(require,module,exports){
// TODO: remove from `core-js@4`
var defineWellKnownSymbol = require('../internals/well-known-symbol-define');

defineWellKnownSymbol('replaceAll');

},{"../internals/well-known-symbol-define":410}],489:[function(require,module,exports){
require('../modules/es.array.iterator');
var DOMIterables = require('../internals/dom-iterables');
var global = require('../internals/global');
var classof = require('../internals/classof');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var Iterators = require('../internals/iterators');
var wellKnownSymbol = require('../internals/well-known-symbol');

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype && classof(CollectionPrototype) !== TO_STRING_TAG) {
    createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
  }
  Iterators[COLLECTION_NAME] = Iterators.Array;
}

},{"../internals/classof":271,"../internals/create-non-enumerable-property":276,"../internals/dom-iterables":287,"../internals/global":320,"../internals/iterators":347,"../internals/well-known-symbol":412,"../modules/es.array.iterator":423}],490:[function(require,module,exports){
var parent = require('../../es/array/from');

module.exports = parent;

},{"../../es/array/from":178}],491:[function(require,module,exports){
var parent = require('../../es/array/is-array');

module.exports = parent;

},{"../../es/array/is-array":179}],492:[function(require,module,exports){
var parent = require('../../../es/array/virtual/values');

module.exports = parent;

},{"../../../es/array/virtual/values":189}],493:[function(require,module,exports){
var parent = require('../es/get-iterator-method');
require('../modules/web.dom-collections.iterator');

module.exports = parent;

},{"../es/get-iterator-method":191,"../modules/web.dom-collections.iterator":489}],494:[function(require,module,exports){
var parent = require('../../es/instance/bind');

module.exports = parent;

},{"../../es/instance/bind":192}],495:[function(require,module,exports){
var parent = require('../../es/instance/concat');

module.exports = parent;

},{"../../es/instance/concat":193}],496:[function(require,module,exports){
var parent = require('../../es/instance/fill');

module.exports = parent;

},{"../../es/instance/fill":194}],497:[function(require,module,exports){
var parent = require('../../es/instance/filter');

module.exports = parent;

},{"../../es/instance/filter":195}],498:[function(require,module,exports){
var parent = require('../../es/instance/find-index');

module.exports = parent;

},{"../../es/instance/find-index":196}],499:[function(require,module,exports){
var parent = require('../../es/instance/includes');

module.exports = parent;

},{"../../es/instance/includes":197}],500:[function(require,module,exports){
var parent = require('../../es/instance/map');

module.exports = parent;

},{"../../es/instance/map":198}],501:[function(require,module,exports){
var parent = require('../../es/instance/pad-start');

module.exports = parent;

},{"../../es/instance/pad-start":199}],502:[function(require,module,exports){
var parent = require('../../es/instance/slice');

module.exports = parent;

},{"../../es/instance/slice":200}],503:[function(require,module,exports){
var parent = require('../../es/instance/sort');

module.exports = parent;

},{"../../es/instance/sort":201}],504:[function(require,module,exports){
var parent = require('../../es/instance/splice');

module.exports = parent;

},{"../../es/instance/splice":202}],505:[function(require,module,exports){
var parent = require('../../es/instance/starts-with');

module.exports = parent;

},{"../../es/instance/starts-with":203}],506:[function(require,module,exports){
require('../../modules/web.dom-collections.iterator');
var classof = require('../../internals/classof');
var hasOwn = require('../../internals/has-own-property');
var isPrototypeOf = require('../../internals/object-is-prototype-of');
var method = require('../array/virtual/values');

var ArrayPrototype = Array.prototype;

var DOMIterables = {
  DOMTokenList: true,
  NodeList: true
};

module.exports = function (it) {
  var own = it.values;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.values)
    || hasOwn(DOMIterables, classof(it)) ? method : own;
};

},{"../../internals/classof":271,"../../internals/has-own-property":321,"../../internals/object-is-prototype-of":364,"../../modules/web.dom-collections.iterator":489,"../array/virtual/values":492}],507:[function(require,module,exports){
var parent = require('../../es/number/is-integer');

module.exports = parent;

},{"../../es/number/is-integer":204}],508:[function(require,module,exports){
var parent = require('../../es/number/parse-float');

module.exports = parent;

},{"../../es/number/parse-float":205}],509:[function(require,module,exports){
var parent = require('../../es/object/assign');

module.exports = parent;

},{"../../es/object/assign":206}],510:[function(require,module,exports){
var parent = require('../../es/object/create');

module.exports = parent;

},{"../../es/object/create":207}],511:[function(require,module,exports){
var parent = require('../../es/object/define-property');

module.exports = parent;

},{"../../es/object/define-property":208}],512:[function(require,module,exports){
var parent = require('../../es/object/get-own-property-descriptor');

module.exports = parent;

},{"../../es/object/get-own-property-descriptor":209}],513:[function(require,module,exports){
var parent = require('../../es/object/get-prototype-of');

module.exports = parent;

},{"../../es/object/get-prototype-of":210}],514:[function(require,module,exports){
var parent = require('../../es/object/keys');

module.exports = parent;

},{"../../es/object/keys":211}],515:[function(require,module,exports){
var parent = require('../../es/object/set-prototype-of');

module.exports = parent;

},{"../../es/object/set-prototype-of":212}],516:[function(require,module,exports){
var parent = require('../../es/promise');
require('../../modules/web.dom-collections.iterator');

module.exports = parent;

},{"../../es/promise":213,"../../modules/web.dom-collections.iterator":489}],517:[function(require,module,exports){
var parent = require('../../es/reflect/construct');

module.exports = parent;

},{"../../es/reflect/construct":214}],518:[function(require,module,exports){
var parent = require('../../es/reflect/get');

module.exports = parent;

},{"../../es/reflect/get":215}],519:[function(require,module,exports){
var parent = require('../../es/symbol');
require('../../modules/web.dom-collections.iterator');

module.exports = parent;

},{"../../es/symbol":219,"../../modules/web.dom-collections.iterator":489}],520:[function(require,module,exports){
var parent = require('../../es/symbol/iterator');
require('../../modules/web.dom-collections.iterator');

module.exports = parent;

},{"../../es/symbol/iterator":220,"../../modules/web.dom-collections.iterator":489}],521:[function(require,module,exports){
var parent = require('../../es/symbol/to-primitive');

module.exports = parent;

},{"../../es/symbol/to-primitive":221}],522:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[106])(106)
});
